//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Agnisys
// generated from    : D:\AgnisysProjects\git_test\Allegro_test\Merger\merg4.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AXI
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

//------------------------------------------------
//  BLOCK : MERG45 MODULE
//

module merg45_ids(
    
    // REGISTER : REG_NAM PORT SIGNAL
    regnam_enb,
    regnam_ff_r,
    
    regnam_fxy_r,
    
    regnam_fx1_r,
    
    
    // REGISTER : REG_NAME2 PORT SIGNAL
    reggroupname_regname2_enb,
    reggroupname_regname2_f12_r,
    
    reggroupname_regname2_f1_r,
    
    reggroupname_regname2_f13_r,
    
    reggroupname_regname2_f11_r,
    
    
    
    //AXI signals
    aclk,   // Bus clock
    aresetn,   // Reset
    awaddr,   // Write address
    awvalid,   // Write address valid : This signal indicates that write address is valid
    awready,   // Write address ready : This signal indicates that the slave is ready to accept an address
    awprot,   // Write Protection Type
    wdata,   // Write data
    wvalid,   // Write valid         : This signal indicates that valid write data and strobes are available
    wready,   // Write ready         : This signal indicates that the slave can accept the write data
    wstrb,   // Write Strobes
    bresp,   // Write Response
    bready,   // Response Ready
    bvalid,   // Response valid
    araddr,   // Read  address
    arvalid,   // Read address valid  : This signal indicates that the read address is valid and will remain stable until ARREADY is high
    arready,   // Read address ready  : This signal indicates that the slave is ready to accept an address
    arprot,   // Read Protection Type
    rdata,   // Read data
    rvalid,   // Read valid          : This signal indicates that the required read data is available and the read transfer can complete
    rready,   // Read ready          : This signal indicates that the master can accept the read data
    rresp   // Read Response
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 12;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REGGROUP_NAME
    parameter reggroupname_count         = 1;
    parameter reggroupname_address_width = addr_width;
    
    
    parameter merg45_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : REG_NAM SIGNALS
    
    
    wire    regnam_decode;         // Write DECODE
    wire    regnam_rdecode;        // Read  DECODE
    wire    regnam_wr_valid;       // WRITE VALID
    wire    regnam_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] regnam_rd_data;          // READ DATA
    wire    [64-1 : 0] regnam_offset;  // OFFSET
    output  regnam_enb;    // REGISTER ENABLE
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [1 : 0] regnam_ff_q  ;      // FIELD : FF
    reg          regnam_fxy_q ;      // FIELD : FXY
    reg          regnam_fx1_q ;      // FIELD : FX1
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [1 : 0] regnam_ff_r  ;      // FIELD : FF
    output           regnam_fxy_r ;      // FIELD : FXY
    output           regnam_fx1_r ;      // FIELD : FX1
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME2 SIGNALS
    
    
    wire    reggroupname_regname2_decode;         // Write DECODE
    wire    reggroupname_regname2_rdecode;        // Read  DECODE
    wire    reggroupname_regname2_wr_valid;       // WRITE VALID
    wire    reggroupname_regname2_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reggroupname_regname2_rd_data;          // READ DATA
    wire    [64-1 : 0] reggroupname_regname2_offset;  // OFFSET
    output  reggroupname_regname2_enb;    // REGISTER ENABLE
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [1 : 0] reggroupname_regname2_f12_q ;      // FIELD : F12
    reg  [1 : 0] reggroupname_regname2_f1_q  ;      // FIELD : F1
    reg          reggroupname_regname2_f13_q ;      // FIELD : F13
    reg          reggroupname_regname2_f11_q ;      // FIELD : F11
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [1 : 0] reggroupname_regname2_f12_r ;      // FIELD : F12
    output   [1 : 0] reggroupname_regname2_f1_r  ;      // FIELD : F1
    output           reggroupname_regname2_f13_r ;      // FIELD : F13
    output           reggroupname_regname2_f11_r ;      // FIELD : F11
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    //-----------------------------------------------------
    
    
    
    //AXI signals
    input aclk;
    input aresetn;
    input [addr_width-1 : 0] awaddr;
    input awvalid;
    output awready;
    input [2 : 0] awprot;
    wire  [2 : 0] awprot_i;
    input [bus_width-1 : 0] wdata;
    input wvalid;
    output wready;
    input [bus_width/8-1 : 0] wstrb;
    output [1 : 0] bresp;
    input bready;
    output bvalid;
    input [addr_width-1 : 0] araddr;
    input arvalid;
    output arready;
    input [2 : 0] arprot;
    wire  [2 : 0] arprot_i;
    output [bus_width-1 : 0] rdata;
    output rvalid;
    input rready;
    output [1 : 0] rresp;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire [addr_width-1 : 0] raddress;
    wire  wr_error;
    wire  rd_error;
    wire  wr_decode_error;
    wire  rd_decode_error;
    wire  wr_slave_select;
    wire  rd_slave_select;
    wire  [addr_width-1:0] slvwaddr;
    wire  [addr_width-1:0] slvraddr;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    axi_widget #(.addr_width(addr_width), .bus_width(bus_width)) axi(
            .aclk(aclk),
            .aresetn(aresetn),
            .awaddr(awaddr),
            .awvalid(awvalid),
            .awready(awready),
            .awprot(awprot),
            .awprot_i(awprot_i),
            .wdata(wdata),
            .wvalid(wvalid),
            .wready(wready),
            .wstrb(wstrb),
            .bresp(bresp),
            .bready(bready),
            .bvalid(bvalid),
            .araddr(araddr),
            .arvalid(arvalid),
            .arready(arready),
            .arprot(arprot),
            .arprot_i(arprot_i),
            .rdata(rdata),
            .rvalid(rvalid),
            .rready(rready),
            .rresp(rresp),
            .clk(clk),
            .reset_l(reset_l),
            .request(request),
            .wr_stb(wr_stb),
            .wr_decode_error(wr_decode_error),
            .rd_decode_error(rd_decode_error),
            .wr_slave_select(wr_slave_select),
            .rd_slave_select(rd_slave_select),
            .slvwaddr(slvwaddr),
            .slvraddr(slvraddr),
            .rd_stb(rd_stb),
            .rd_wait(rd_wait),
            .wr_error(wr_error),
            .rd_error(rd_error),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .raddress(raddress),
            .rd_data_vld(rd_data_vld),
            .byte_enb(byte_enb));
    //end widget
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG_NAM
    // ADDRESS       :  block_offset+'h0                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:1 : ff   ( SW : Read-Write HW : Read-only )
    //        4 : fxy  ( SW : Read-Write HW : Read-only )
    //        7 : fx1  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign regnam_wr_valid = regnam_decode && wr_stb;
    assign regnam_rd_valid = regnam_rdecode && rd_stb;
    assign regnam_enb      = regnam_wr_valid;
    assign regnam_offset = block_offset+'h0;
    assign regnam_decode  = (address[merg45_address_width-1 : 0]    == regnam_offset[merg45_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign regnam_rdecode = (raddress[merg45_address_width-1 : 0]   == regnam_offset[merg45_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FF
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                regnam_ff_q   <= 2'd0;
            end
        else
            begin
                
            if (regnam_wr_valid)   // FF : SW Write
                begin
                    regnam_ff_q <=  ( wr_data[1 : 0] & reg_enb[1 : 0] ) | (regnam_ff_q & (~reg_enb[1 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FXY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                regnam_fxy_q  <= 1'd0;
            end
        else
            begin
                
            if (regnam_wr_valid)   // FXY : SW Write
                begin
                    regnam_fxy_q <=  ( wr_data[4] & reg_enb[4] ) | (regnam_fxy_q & (~reg_enb[4]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FX1
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                regnam_fx1_q  <= 1'd0;
            end
        else
            begin
                
            if (regnam_wr_valid)   // FX1 : SW Write
                begin
                    regnam_fx1_q <=  ( wr_data[7] & reg_enb[7] ) | (regnam_fx1_q & (~reg_enb[7]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign regnam_ff_r   =  regnam_ff_q  ;    // Field : FF
    assign regnam_fxy_r  =  regnam_fxy_q ;    // Field : FXY
    assign regnam_fx1_r  =  regnam_fx1_q ;    // Field : FX1
    
    
    assign regnam_rd_data = regnam_rd_valid ? {24'b0 ,regnam_fx1_q , 2'b0 ,regnam_fxy_q , 2'b0 ,regnam_ff_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG_NAME2
    // ADDRESS       :  block_offset+'h4 + 'h0                WIDTH : 8
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      3:4 : f12  ( SW : Read-Write HW : Read-only )
    //      2:1 : f1   ( SW : Read-Write HW : Read-only )
    //        6 : f13  ( SW : Read-Write HW : Read-only )
    //        7 : f11  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reggroupname_regname2_wr_valid = reggroupname_regname2_decode && wr_stb;
    assign reggroupname_regname2_rd_valid = reggroupname_regname2_rdecode && rd_stb;
    assign reggroupname_regname2_enb      = reggroupname_regname2_wr_valid;
    assign reggroupname_regname2_offset = block_offset+'h4 + 'h0;
    assign reggroupname_regname2_decode  = (address[reggroupname_address_width-1 : 0]    == reggroupname_regname2_offset[reggroupname_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reggroupname_regname2_rdecode = (raddress[reggroupname_address_width-1 : 0]   == reggroupname_regname2_offset[reggroupname_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F12
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroupname_regname2_f12_q <= 2'd0;
            end
        else
            begin
                
            if (reggroupname_regname2_wr_valid)   // F12 : SW Write
                begin
                    reggroupname_regname2_f12_q <=  ( wr_data[4 : 3] & reg_enb[4 : 3] ) | (reggroupname_regname2_f12_q & (~reg_enb[4 : 3]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroupname_regname2_f1_q <= 2'd1;
            end
        else
            begin
                
            if (reggroupname_regname2_wr_valid)   // F1 : SW Write
                begin
                    reggroupname_regname2_f1_q <=  ( wr_data[2 : 1] & reg_enb[2 : 1] ) | (reggroupname_regname2_f1_q & (~reg_enb[2 : 1]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F13
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  6
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroupname_regname2_f13_q <= 1'd0;
            end
        else
            begin
                
            if (reggroupname_regname2_wr_valid)   // F13 : SW Write
                begin
                    reggroupname_regname2_f13_q <=  ( wr_data[6] & reg_enb[6] ) | (reggroupname_regname2_f13_q & (~reg_enb[6]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F11
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroupname_regname2_f11_q <= 1'd1;
            end
        else
            begin
                
            if (reggroupname_regname2_wr_valid)   // F11 : SW Write
                begin
                    reggroupname_regname2_f11_q <=  ( wr_data[7] & reg_enb[7] ) | (reggroupname_regname2_f11_q & (~reg_enb[7]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reggroupname_regname2_f12_r =  reggroupname_regname2_f12_q;    // Field : F12
    assign reggroupname_regname2_f1_r =  reggroupname_regname2_f1_q;    // Field : F1
    assign reggroupname_regname2_f13_r =  reggroupname_regname2_f13_q;    // Field : F13
    assign reggroupname_regname2_f11_r =  reggroupname_regname2_f11_q;    // Field : F11
    
    
    assign reggroupname_regname2_rd_data = reggroupname_regname2_rd_valid ? {reggroupname_regname2_f11_q , reggroupname_regname2_f13_q , 1'b0 ,reggroupname_regname2_f12_q , reggroupname_regname2_f1_q , 1'b0} : 8'b00000000;
    
    
    
    
    
    assign rd_data = regnam_rd_data |
    reggroupname_regname2_rd_data ;
    
    
    
    assign wr_error = 0;
    
    assign rd_error = 0;
    
    assign wr_decode_error = 0;
    
    assign rd_decode_error = 0;
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    assign wr_slave_select = ((slvwaddr[addr_width - 1 : 0]  >= block_offset) && (slvwaddr[addr_width - 1 : 0]  <= block_offset + 'hFFF)) ? 1'b1 : 1'b0;
    assign rd_slave_select = ((slvraddr[addr_width - 1 : 0]  >= block_offset) && (slvraddr[addr_width - 1 : 0]  <= block_offset + 'hFFF)) ? 1'b1 : 1'b0;
    
endmodule
