//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Agnisys
// generated from    : D:\AgnisysProjects\git_test\Allegro_test\Test\Book1.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : PROPRIETARY
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

module chip1_ids(
    block4_idsreggroup1_wr_req_in,
    block4_idsreggroup1_rd_ack_in,
    block4_idsreggroup1_rd_data_in,
    block4_idsreggroup1_wr_valid_out,
    block4_idsreggroup1_rd_valid_out,
    
    block4_idsaddress_out,
    block4_idswr_data_out,
    block1_idsreggroup1_reg2_enb,
    block1_idsreggroup1_reg2_f1_in,
    block1_idsreggroup1_reg2_f1_in_enb,
    block1_idsreggroup1_reg2_f1_r,
    block1_idsreggroup1_reg2_f2_in,
    block1_idsreggroup1_reg2_f2_in_enb,
    block1_idsreggroup1_reg2_f2_r,
    
    block3_idsreggroup1_reg2_f1_in,
    block3_idsreggroup1_reg2_f1_in_enb,
    block3_idsreggroup1_reg2_f1_r,
    block3_idsreggroup1_reg2_f2_in,
    block3_idsreggroup1_reg2_f2_in_enb,
    block3_idsreggroup1_reg2_f2_r,
    
    
    //CUSTOM signals
    
    clk,    // Bus clock
    reset_l,    // Reset
    rd_stb,    // Read strobe        : This signal should be HIGH during read operation and LOW during write operation
    rd_wait,    // Read wait
    wr_stb,    // Write strobe       : This signal should be HIGH during write operation and LOW during read operation
    address,    // Address for write/read
    wr_data,    // Write data
    byteenable,    // Specify which bytes are being written or during read which bytes the master is reading
    request,    // Bus request signal : HIGH indicates bus is free and LOW indicates bus is busy
    rd_data_vld,    // Read data valid : Asserted by the slave to indicate that the read data signal contains valid data
    rd_data    // Read data
    
    );
    
    
    parameter block4_count = 10;
    
    parameter block4_ids_offset = 'h0;
    
    parameter block1_ids_offset = 'h190;
    
    parameter block3_ids_offset = 'h194;
    parameter addr_width  = 9;
    parameter bus_width   = 32;
    
    //CUSTOM signals
    input clk;
    input reset_l;
    input rd_stb;
    output  wand rd_wait;
    input wr_stb;
    input [addr_width-1 : 0] address;
    input [bus_width-1 : 0] wr_data;
    input [bus_width/8-1 : 0] byteenable;
    output  wand request;
    output  wor rd_data_vld;
    output  wor [bus_width-1 : 0] rd_data;
    
    output wor  [ block4_count * addr_width-1:0] block4_idsaddress_out;
    output wor  [ block4_count * bus_width-1:0] block4_idswr_data_out;
    
    wire [ block4_count * addr_width-1:0] block4_ids_address_out;
    wire [ block4_count * bus_width-1:0] block4_ids_wr_data_out;
    
    wire [block4_count * bus_width-1:0] block4_ids_rd_data;
    wire  [block4_count - 1: 0] block4_ids_rd_data_vld;
    wire  [block4_count - 1: 0] block4_ids_request;
    wire  [block4_count - 1: 0] block4_ids_rd_wait;
    
    wire [bus_width-1:0] block1_ids_rd_data;
    wire block1_ids_rd_data_vld;
    wire block1_ids_request;
    wire block1_ids_rd_wait;
    
    wire [bus_width-1:0] block3_ids_rd_data;
    wire block3_ids_rd_data_vld;
    wire block3_ids_request;
    wire block3_ids_rd_wait;
    
    //block4_ids
    input  [ block4_count-1 : 0] block4_idsreggroup1_rd_ack_in;
    input   [block4_count * bus_width-1 : 0] block4_idsreggroup1_rd_data_in;
    output [ block4_count-1 : 0] block4_idsreggroup1_rd_valid_out;
    input  [ block4_count-1 : 0] block4_idsreggroup1_wr_req_in;
    output [ block4_count-1 : 0] block4_idsreggroup1_wr_valid_out;
    
    
    
    
    generate
        genvar  block4_i;
        for (block4_i =  0 ; block4_i < block4_count ; block4_i = block4_i + 1  )
        begin : block4_gen
            block4_ids #(.addr_width(addr_width),.block_offset( 'h0 + block4_i * ( 'h190 / block4_count ))) block4_idsinst(
            .reggroup1_wr_req_in(block4_idsreggroup1_wr_req_in[block4_i]),
            .reggroup1_rd_ack_in(block4_idsreggroup1_rd_ack_in[block4_i]),
            .reggroup1_rd_data_in(block4_idsreggroup1_rd_data_in[bus_width *  (block4_i + 1 ) - 1 : bus_width * block4_i ]),
            .reggroup1_wr_valid_out(block4_idsreggroup1_wr_valid_out[block4_i]),
            .reggroup1_rd_valid_out(block4_idsreggroup1_rd_valid_out[block4_i]),
            
            .clk(clk),
            .reset_l(reset_l),
            .rd_stb(rd_stb),
            .rd_wait(block4_ids_rd_wait[block4_i]),
            .wr_stb(wr_stb),
            .address(address),
            .wr_data(wr_data),
            .byteenable(byteenable),
            .request(block4_ids_request[block4_i]),
            .rd_data_vld(block4_ids_rd_data_vld[block4_i]),
            .rd_data(block4_ids_rd_data[bus_width * (block4_i + 1 ) - 1 :bus_width * block4_i]),
            .address_out(block4_ids_address_out[addr_width * (block4_i + 1 ) - 1 :addr_width * block4_i]),
            .wr_data_out(block4_ids_wr_data_out[bus_width * (block4_i + 1 ) - 1 :bus_width * block4_i]));
        end
    endgenerate
    
    //block1_ids
    
    output   block1_idsreggroup1_reg2_enb;
    input  [15 : 0] block1_idsreggroup1_reg2_f1_in;
    input   block1_idsreggroup1_reg2_f1_in_enb;
    output [15 : 0] block1_idsreggroup1_reg2_f1_r;
    input  [15 : 0] block1_idsreggroup1_reg2_f2_in;
    input   block1_idsreggroup1_reg2_f2_in_enb;
    output [15 : 0] block1_idsreggroup1_reg2_f2_r;
    
    
    
    
    block1_ids #(.addr_width(addr_width),.block_offset( 'h190)) block1_idsinst(
    .reggroup1_reg2_enb(block1_idsreggroup1_reg2_enb),
    .reggroup1_reg2_f1_in(block1_idsreggroup1_reg2_f1_in),
    .reggroup1_reg2_f1_in_enb(block1_idsreggroup1_reg2_f1_in_enb),
    .reggroup1_reg2_f1_r(block1_idsreggroup1_reg2_f1_r),
    .reggroup1_reg2_f2_in(block1_idsreggroup1_reg2_f2_in),
    .reggroup1_reg2_f2_in_enb(block1_idsreggroup1_reg2_f2_in_enb),
    .reggroup1_reg2_f2_r(block1_idsreggroup1_reg2_f2_r),
    
    .clk(clk),
    .reset_l(reset_l),
    .rd_stb(rd_stb),
    .rd_wait(block1_ids_rd_wait),
    .wr_stb(wr_stb),
    .address(address),
    .wr_data(wr_data),
    .byteenable(byteenable),
    .request(block1_ids_request),
    .rd_data_vld(block1_ids_rd_data_vld),
    .rd_data(block1_ids_rd_data));
    
    //block3_ids
    
    input  [15 : 0] block3_idsreggroup1_reg2_f1_in;
    input   block3_idsreggroup1_reg2_f1_in_enb;
    output [15 : 0] block3_idsreggroup1_reg2_f1_r;
    input  [15 : 0] block3_idsreggroup1_reg2_f2_in;
    input   block3_idsreggroup1_reg2_f2_in_enb;
    output [15 : 0] block3_idsreggroup1_reg2_f2_r;
    
    
    
    
    block3_ids #(.addr_width(addr_width),.block_offset( 'h194)) block3_idsinst(
    .reggroup1_reg2_f1_in(block3_idsreggroup1_reg2_f1_in),
    .reggroup1_reg2_f1_in_enb(block3_idsreggroup1_reg2_f1_in_enb),
    .reggroup1_reg2_f1_r(block3_idsreggroup1_reg2_f1_r),
    .reggroup1_reg2_f2_in(block3_idsreggroup1_reg2_f2_in),
    .reggroup1_reg2_f2_in_enb(block3_idsreggroup1_reg2_f2_in_enb),
    .reggroup1_reg2_f2_r(block3_idsreggroup1_reg2_f2_r),
    
    .clk(clk),
    .reset_l(reset_l),
    .rd_stb(rd_stb),
    .rd_wait(block3_ids_rd_wait),
    .wr_stb(wr_stb),
    .address(address),
    .wr_data(wr_data),
    .byteenable(byteenable),
    .request(block3_ids_request),
    .rd_data_vld(block3_ids_rd_data_vld),
    .rd_data(block3_ids_rd_data));
    
    
    generate
        genvar block4_ext_i;
        for (block4_ext_i = 0 ; block4_ext_i < block4_count ; block4_ext_i = block4_ext_i + 1 )
        begin : block4_ext_gen
            assign block4_idswr_data_out = block4_ids_wr_data_out[ bus_width * (block4_ext_i + 1) - 1 :  bus_width * block4_ext_i];
            assign block4_idsaddress_out = block4_ids_address_out[ addr_width * (block4_ext_i + 1) - 1 :  addr_width * block4_ext_i];
        end
    endgenerate
    
    
    
    
    assign request =   (  &  block4_ids_request )  &  (  block1_ids_request )  &  (  block3_ids_request ) ;
    generate
        genvar block4_default_map_itr;
        for (block4_default_map_itr = 0 ; block4_default_map_itr < block4_count ; block4_default_map_itr = block4_default_map_itr + 1 )
        begin : block4_default_map_rd_data_gen
            assign rd_data = block4_ids_rd_data[ bus_width * (block4_default_map_itr + 1) - 1 : bus_width * block4_default_map_itr];
        end
    endgenerate
    
    assign rd_data_vld =   (  |  block4_ids_rd_data_vld )  |  (  block1_ids_rd_data_vld )  |  (  block3_ids_rd_data_vld ) ;
    assign rd_wait =   (  &  block4_ids_rd_wait )  &  (  block1_ids_rd_wait )  &  (  block3_ids_rd_wait ) ;
endmodule

//------------------------------------------------
//  BLOCK : BLOCK4 MODULE
//

module block4_ids(
    
    // SECTION(EXTERNAL) : REGGROUP1 PORT SIGNAL
    reggroup1_rd_ack_in,
    reggroup1_rd_data_in,
    reggroup1_rd_valid_out,
    reggroup1_wr_req_in,
    reggroup1_wr_valid_out,
    
    
    address_out,
    wr_data_out,
    
    //CUSTOM signals
    clk,   // Bus clock
    reset_l,   // Reset
    rd_stb,   // Read strobe        : This signal should be HIGH during read operation and LOW during write operation
    rd_wait,   // Read wait
    wr_stb,   // Write strobe       : This signal should be HIGH during write operation and LOW during read operation
    address,   // Address for write/read
    wr_data,   // Write data
    byteenable,   // Specify which bytes are being written or during read which bytes the master is reading
    request,   // Bus request signal : HIGH indicates bus is free and LOW indicates bus is busy
    rd_data_vld,   // Read data valid : Asserted by the slave to indicate that the read data signal contains valid data
    rd_data   // Read data
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 9;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REGGROUP1
    parameter reggroup1_count         = 10;
    parameter reggroup1_address_width = addr_width - 6;
    
    
    parameter block4_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : REGGROUP1 SIGNALS
    input   reggroup1_rd_ack_in;
    input  [bus_width-1 : 0] reggroup1_rd_data_in;
    output  reggroup1_rd_valid_out;
    input   reggroup1_wr_req_in;
    output  reggroup1_wr_valid_out;
    wire    reggroup1_decode;
    wire    [64-1 : 0] reggroup1_offset;
    wire     reggroup1_rd_valid;
    wire     reggroup1_wr_valid;
    wor     reggroup1_wr_req_wor;
    wor     reggroup1_rd_ack_wor;
    wor     reggroup1_decode_wor;
    
    wire    [bus_width-1 : 0] reggroup1_rd_data;
    
    //-----------------------------------------------------
    
    
    output [addr_width-1:0] address_out;
    output [bus_width-1:0] wr_data_out;
    wire external_rd_valid;
    reg  rd_wait_state;
    wire external_rd_ack;
    wire external_wr_req;
    wire external_access;
    
    //CUSTOM signals
    input clk;
    input reset_l;
    input rd_stb;
    output rd_wait;
    input wr_stb;
    input [addr_width-1 : 0] address;
    input [bus_width-1 : 0] wr_data;
    input [bus_width/8-1 : 0] byteenable;
    output request;
    output rd_data_vld;
    output [bus_width-1 : 0] rd_data;
    
    wire  [bus_width-1:0] rd_data;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    assign address_out = address;
    assign wr_data_out = wr_data;
    
    assign byte_enb = byteenable;
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    assign reggroup1_offset       = (block_offset/'h40) +'h0;
    assign reggroup1_decode       = ((address[addr_width - 1 : 0] >= block_offset +  'h0) && (address[addr_width - 1 : 0] <= block_offset +  'h27)) ? 1'b1 : 1'b0;
    assign reggroup1_wr_valid     = reggroup1_decode &&  wr_stb;
    assign reggroup1_rd_valid     = reggroup1_decode && rd_stb && rd_wait_state;
    assign reggroup1_wr_valid_out = reggroup1_wr_valid;
    assign reggroup1_rd_valid_out = reggroup1_rd_valid;
    assign reggroup1_decode_wor   = reggroup1_decode;
    
    assign reggroup1_wr_req_wor   = reggroup1_wr_req_in;
    assign reggroup1_rd_ack_wor   = reggroup1_rd_ack_in;
    
    assign reggroup1_rd_data      = reggroup1_rd_ack_in ? reggroup1_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    
    
    
    assign rd_data = reggroup1_rd_data ;
    
    
    
    assign external_rd_valid = reggroup1_rd_valid;
    // END external_rd_valid
    
    assign external_rd_ack = reggroup1_rd_ack_wor;
    // END external_rd_ack
    
    assign external_wr_req = reggroup1_wr_req_wor;
    // END external_wr_req
    
    assign external_access = (reggroup1_decode_wor) & (rd_stb | wr_stb);
    // END external_access
    
    always @(posedge clk)
        begin
        if ( !reset_l )
            begin
                rd_wait_state <= 1'b1;
            end
        else
            begin
                case(rd_wait_state)
                    1'b1:
                    begin
                    if (external_rd_valid == 1'b1 && external_rd_ack == 1'b0 )
                        begin
                            rd_wait_state <= 1'b0;
                        end
                    end
                    1'b0:
                    begin
                    if (external_rd_ack == 1'b1)
                        begin
                            rd_wait_state <= 1'b1;
                        end
                    end
                endcase
            end
    end // always END
    
    
    assign request     = external_wr_req;
    assign rd_data_vld = external_rd_ack |(~external_access & rd_stb & rd_wait_state);
    assign rd_wait     = rd_wait_state;
    
    
endmodule

//------------------------------------------------
//  BLOCK : BLOCK1 MODULE
//

module block1_ids(
    
    // REGISTER : REG2 PORT SIGNAL
    reggroup1_reg2_enb,
    reggroup1_reg2_f1_in,
    reggroup1_reg2_f1_in_enb,
    reggroup1_reg2_f1_r,
    
    reggroup1_reg2_f2_in,
    reggroup1_reg2_f2_in_enb,
    reggroup1_reg2_f2_r,
    
    
    
    //CUSTOM signals
    clk,   // Bus clock
    reset_l,   // Reset
    rd_stb,   // Read strobe        : This signal should be HIGH during read operation and LOW during write operation
    rd_wait,   // Read wait
    wr_stb,   // Write strobe       : This signal should be HIGH during write operation and LOW during read operation
    address,   // Address for write/read
    wr_data,   // Write data
    byteenable,   // Specify which bytes are being written or during read which bytes the master is reading
    request,   // Bus request signal : HIGH indicates bus is free and LOW indicates bus is busy
    rd_data_vld,   // Read data valid : Asserted by the slave to indicate that the read data signal contains valid data
    rd_data   // Read data
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 2;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REGGROUP1
    parameter reggroup1_count         = 1;
    parameter reggroup1_address_width = addr_width;
    
    
    parameter block1_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : REG2 SIGNALS
    
    
    wire    reggroup1_reg2_decode;         // DECODE
    wire    reggroup1_reg2_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] reggroup1_reg2_rd_data;          // READ DATA
    wire    [64-1 : 0] reggroup1_reg2_offset;  // OFFSET
    output  reggroup1_reg2_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reggroup1_reg2_f1_in_enb ;      // FIELD : F1
    input   reggroup1_reg2_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reggroup1_reg2_f1_q ;      // FIELD : F1
    reg [15 : 0] reggroup1_reg2_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reggroup1_reg2_f1_r ;      // FIELD : F1
    output  [15 : 0] reggroup1_reg2_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reggroup1_reg2_f1_in ;      // FIELD : F1
    input   [15 : 0] reggroup1_reg2_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    
    //CUSTOM signals
    input clk;
    input reset_l;
    input rd_stb;
    output rd_wait;
    input wr_stb;
    input [addr_width-1 : 0] address;
    input [bus_width-1 : 0] wr_data;
    input [bus_width/8-1 : 0] byteenable;
    output request;
    output rd_data_vld;
    output [bus_width-1 : 0] rd_data;
    
    wire  [bus_width-1:0] rd_data;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    assign byte_enb = byteenable;
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG2
    // ADDRESS       :  block_offset+'h0 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-Write HW : Read-Write )
    //    31:16 : f2  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reggroup1_reg2_wr_valid = reggroup1_reg2_decode && wr_stb;
    assign reggroup1_reg2_enb      = reggroup1_reg2_wr_valid;
    assign reggroup1_reg2_offset = block_offset+'h0 + 'h0;
    assign reggroup1_reg2_decode  = (address[reggroup1_address_width-1 : 0]    == reggroup1_reg2_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f1_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f1_in_enb)   // F1 : HW Write
                begin
                    reggroup1_reg2_f1_q <= reggroup1_reg2_f1_in;
                end
            else
                begin
                    
                if (reggroup1_reg2_wr_valid)   // F1 : SW Write
                    begin
                        reggroup1_reg2_f1_q <=  ( wr_data[15 : 0] & reg_enb[15 : 0] ) | (reggroup1_reg2_f1_q & (~reg_enb[15 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f2_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f2_in_enb)   // F2 : HW Write
                begin
                    reggroup1_reg2_f2_q <= reggroup1_reg2_f2_in;
                end
            else
                begin
                    
                if (reggroup1_reg2_wr_valid)   // F2 : SW Write
                    begin
                        reggroup1_reg2_f2_q <=  ( wr_data[31 : 16] & reg_enb[31 : 16] ) | (reggroup1_reg2_f2_q & (~reg_enb[31 : 16]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reggroup1_reg2_f1_r =  reggroup1_reg2_f1_q;    // Field : F1
    assign reggroup1_reg2_f2_r =  reggroup1_reg2_f2_q;    // Field : F2
    
    
    assign reggroup1_reg2_rd_data = reggroup1_reg2_decode ? {reggroup1_reg2_f2_q , reggroup1_reg2_f1_q} : 32'b00000000000000000000000000000000;
    
    
    
    
    
    assign rd_data = reggroup1_reg2_rd_data ;
    
    
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    
endmodule

//------------------------------------------------
//  BLOCK : BLOCK3 MODULE
//

module block3_ids(
    
    // REGISTER : REG2 PORT SIGNAL
    reggroup1_reg2_f1_in,
    reggroup1_reg2_f1_in_enb,
    reggroup1_reg2_f1_r,
    
    reggroup1_reg2_f2_in,
    reggroup1_reg2_f2_in_enb,
    reggroup1_reg2_f2_r,
    
    
    
    //CUSTOM signals
    clk,   // Bus clock
    reset_l,   // Reset
    rd_stb,   // Read strobe        : This signal should be HIGH during read operation and LOW during write operation
    rd_wait,   // Read wait
    wr_stb,   // Write strobe       : This signal should be HIGH during write operation and LOW during read operation
    address,   // Address for write/read
    wr_data,   // Write data
    byteenable,   // Specify which bytes are being written or during read which bytes the master is reading
    request,   // Bus request signal : HIGH indicates bus is free and LOW indicates bus is busy
    rd_data_vld,   // Read data valid : Asserted by the slave to indicate that the read data signal contains valid data
    rd_data   // Read data
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 2;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REGGROUP1
    parameter reggroup1_count         = 1;
    parameter reggroup1_address_width = addr_width;
    
    
    parameter block3_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : REG2 SIGNALS
    
    
    wire    reggroup1_reg2_decode;         // DECODE
    wire    [bus_width-1 : 0] reggroup1_reg2_rd_data;          // READ DATA
    wire    [64-1 : 0] reggroup1_reg2_offset;  // OFFSET
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reggroup1_reg2_f1_in_enb ;      // FIELD : F1
    input   reggroup1_reg2_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reggroup1_reg2_f1_q ;      // FIELD : F1
    reg [15 : 0] reggroup1_reg2_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reggroup1_reg2_f1_r ;      // FIELD : F1
    output  [15 : 0] reggroup1_reg2_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reggroup1_reg2_f1_in ;      // FIELD : F1
    input   [15 : 0] reggroup1_reg2_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    
    //CUSTOM signals
    input clk;
    input reset_l;
    input rd_stb;
    output rd_wait;
    input wr_stb;
    input [addr_width-1 : 0] address;
    input [bus_width-1 : 0] wr_data;
    input [bus_width/8-1 : 0] byteenable;
    output request;
    output rd_data_vld;
    output [bus_width-1 : 0] rd_data;
    
    wire  [bus_width-1:0] rd_data;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    assign byte_enb = byteenable;
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG2
    // ADDRESS       :  block_offset+'h0 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-only HW : Read-Write )
    //    31:16 : f2  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign reggroup1_reg2_offset = block_offset+'h0 + 'h0;
    assign reggroup1_reg2_decode  = (address[reggroup1_address_width-1 : 0]    == reggroup1_reg2_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f1_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f1_in_enb)   // F1 : HW Write
                begin
                    reggroup1_reg2_f1_q <= reggroup1_reg2_f1_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f2_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f2_in_enb)   // F2 : HW Write
                begin
                    reggroup1_reg2_f2_q <= reggroup1_reg2_f2_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reggroup1_reg2_f1_r =  reggroup1_reg2_f1_q;    // Field : F1
    assign reggroup1_reg2_f2_r =  reggroup1_reg2_f2_q;    // Field : F2
    
    
    assign reggroup1_reg2_rd_data = reggroup1_reg2_decode ? {reggroup1_reg2_f2_q , reggroup1_reg2_f1_q} : 32'b00000000000000000000000000000000;
    
    
    
    
    
    assign rd_data = reggroup1_reg2_rd_data ;
    
    
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    
endmodule
