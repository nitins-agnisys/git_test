//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Agnisys
// generated from    : D:\AgnisysProjects\git_test\Allegro_test\Test\test33.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : PROPRIETARY
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------
/*----------------------------------------------------------------------
Class       : block_name_volatile_Reg0
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_volatile_Reg0
`define CLASS_block_name_volatile_Reg0
class block_name_volatile_Reg0 extends uvm_reg;
    `uvm_object_utils(block_name_volatile_Reg0)

    rand uvm_reg_field mag_in_e;
    rand uvm_reg_field mag_in;
    rand uvm_reg_field hptest_half_scale;
    rand uvm_reg_field hall_dis;
    rand uvm_reg_field afe_zero_cm;
    rand uvm_reg_field afe_zero;
    rand uvm_reg_field afe_hptest_chop;
    rand uvm_reg_field afe_hallph_ext;
    rand uvm_reg_field water;

    // Function : new
    function new(string name = "block_name_volatile_Reg0");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.mag_in_e = uvm_reg_field::type_id::create("mag_in_e");

        this.mag_in = uvm_reg_field::type_id::create("mag_in");

        this.hptest_half_scale = uvm_reg_field::type_id::create("hptest_half_scale");

        this.hall_dis = uvm_reg_field::type_id::create("hall_dis");

        this.afe_zero_cm = uvm_reg_field::type_id::create("afe_zero_cm");

        this.afe_zero = uvm_reg_field::type_id::create("afe_zero");

        this.afe_hptest_chop = uvm_reg_field::type_id::create("afe_hptest_chop");

        this.afe_hallph_ext = uvm_reg_field::type_id::create("afe_hallph_ext");

        this.water = uvm_reg_field::type_id::create("water");

        this.mag_in_e.configure(this, 1,  0, "RW", 0, 'd0, 1, 1, 0);
        this.mag_in.configure(this, 18,  1, "RW", 0, 'd0, 1, 1, 0);
        this.hptest_half_scale.configure(this, 1,  19, "RW", 0, 'd0, 1, 1, 0);
        this.hall_dis.configure(this, 1,  20, "RW", 0, 'd0, 1, 1, 0);
        this.afe_zero_cm.configure(this, 1,  21, "RW", 0, 'd0, 1, 1, 0);
        this.afe_zero.configure(this, 1,  22, "RW", 0, 'd0, 1, 1, 0);
        this.afe_hptest_chop.configure(this, 2,  23, "RW", 0, 'd0, 1, 1, 0);
        this.afe_hallph_ext.configure(this, 3,  25, "RW", 0, 'd0, 1, 1, 0);
        this.water.configure(this, 2,  28, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_volatile_Reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_volatile_Reg1
`define CLASS_block_name_volatile_Reg1
class block_name_volatile_Reg1 extends uvm_reg;
    `uvm_object_utils(block_name_volatile_Reg1)

    rand uvm_reg_field temp_in_e;
    rand uvm_reg_field temp_in;
    rand uvm_reg_field spdiag_single;
    rand uvm_reg_field sdm_order2;
    rand uvm_reg_field refsigmon_sel;
    rand uvm_reg_field refsigmon_eval_start;
    rand uvm_reg_field byp_tsen_trim;
    rand uvm_reg_field byp_trim_f;
    rand uvm_reg_field byp_trim_diag;
    rand uvm_reg_field byp_trim_c;
    rand uvm_reg_field byp_tc_f;
    rand uvm_reg_field byp_tc_diag;
    rand uvm_reg_field byp_tc_c;
    rand uvm_reg_field byp_plin;
    rand uvm_reg_field byp_lin;
    rand uvm_reg_field byp_diag_filt;
    rand uvm_reg_field byp_clamp;
    rand uvm_reg_field byp_bw_sel;
    rand uvm_reg_field byp_adc_iir;

    // Function : new
    function new(string name = "block_name_volatile_Reg1");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.temp_in_e = uvm_reg_field::type_id::create("temp_in_e");

        this.temp_in = uvm_reg_field::type_id::create("temp_in");

        this.spdiag_single = uvm_reg_field::type_id::create("spdiag_single");

        this.sdm_order2 = uvm_reg_field::type_id::create("sdm_order2");

        this.refsigmon_sel = uvm_reg_field::type_id::create("refsigmon_sel");

        this.refsigmon_eval_start = uvm_reg_field::type_id::create("refsigmon_eval_start");

        this.byp_tsen_trim = uvm_reg_field::type_id::create("byp_tsen_trim");

        this.byp_trim_f = uvm_reg_field::type_id::create("byp_trim_f");

        this.byp_trim_diag = uvm_reg_field::type_id::create("byp_trim_diag");

        this.byp_trim_c = uvm_reg_field::type_id::create("byp_trim_c");

        this.byp_tc_f = uvm_reg_field::type_id::create("byp_tc_f");

        this.byp_tc_diag = uvm_reg_field::type_id::create("byp_tc_diag");

        this.byp_tc_c = uvm_reg_field::type_id::create("byp_tc_c");

        this.byp_plin = uvm_reg_field::type_id::create("byp_plin");

        this.byp_lin = uvm_reg_field::type_id::create("byp_lin");

        this.byp_diag_filt = uvm_reg_field::type_id::create("byp_diag_filt");

        this.byp_clamp = uvm_reg_field::type_id::create("byp_clamp");

        this.byp_bw_sel = uvm_reg_field::type_id::create("byp_bw_sel");

        this.byp_adc_iir = uvm_reg_field::type_id::create("byp_adc_iir");

        this.temp_in_e.configure(this, 1,  0, "RW", 0, 'd0, 1, 1, 0);
        this.temp_in.configure(this, 12,  1, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_single.configure(this, 1,  13, "RW", 0, 'd0, 1, 1, 0);
        this.sdm_order2.configure(this, 1,  14, "RW", 0, 'd0, 1, 1, 0);
        this.refsigmon_sel.configure(this, 3,  15, "RW", 0, 'd0, 1, 1, 0);
        this.refsigmon_eval_start.configure(this, 1,  18, "RW", 0, 'd0, 1, 1, 0);
        this.byp_tsen_trim.configure(this, 1,  19, "RW", 0, 'd0, 1, 1, 0);
        this.byp_trim_f.configure(this, 1,  20, "RW", 0, 'd0, 1, 1, 0);
        this.byp_trim_diag.configure(this, 1,  21, "RW", 0, 'd0, 1, 1, 0);
        this.byp_trim_c.configure(this, 1,  22, "RW", 0, 'd0, 1, 1, 0);
        this.byp_tc_f.configure(this, 1,  23, "RW", 0, 'd0, 1, 1, 0);
        this.byp_tc_diag.configure(this, 1,  24, "RW", 0, 'd0, 1, 1, 0);
        this.byp_tc_c.configure(this, 1,  25, "RW", 0, 'd0, 1, 1, 0);
        this.byp_plin.configure(this, 1,  26, "RW", 0, 'd0, 1, 1, 0);
        this.byp_lin.configure(this, 1,  27, "RW", 0, 'd0, 1, 1, 0);
        this.byp_diag_filt.configure(this, 1,  28, "RW", 0, 'd0, 1, 1, 0);
        this.byp_clamp.configure(this, 1,  29, "RW", 0, 'd0, 1, 1, 0);
        this.byp_bw_sel.configure(this, 1,  30, "RW", 0, 'd0, 1, 1, 0);
        this.byp_adc_iir.configure(this, 1,  31, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg2
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg2
`define CLASS_block_name_shadow_Reg2
class block_name_shadow_Reg2 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg2)

    rand uvm_reg_field lint_bin_hyst;
    rand uvm_reg_field lint_bin_e;
    rand uvm_reg_field lin_scalar;
    rand uvm_reg_field hptest_lvl;
    rand uvm_reg_field hall_isel;
    rand uvm_reg_field bw_sel;
    rand uvm_reg_field bg_adc_ref_err_max;
    rand uvm_reg_field asil_ftt;
    rand uvm_reg_field afe_zero_config;
    rand uvm_reg_field afe_hpdrv_chop;
    rand uvm_reg_field afe_gain;
    rand uvm_reg_field afe_adcchp;
    rand uvm_reg_field adc_zero;

    // Function : new
    function new(string name = "block_name_shadow_Reg2");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.lint_bin_hyst = uvm_reg_field::type_id::create("lint_bin_hyst");

        this.lint_bin_e = uvm_reg_field::type_id::create("lint_bin_e");

        this.lin_scalar = uvm_reg_field::type_id::create("lin_scalar");

        this.hptest_lvl = uvm_reg_field::type_id::create("hptest_lvl");

        this.hall_isel = uvm_reg_field::type_id::create("hall_isel");

        this.bw_sel = uvm_reg_field::type_id::create("bw_sel");

        this.bg_adc_ref_err_max = uvm_reg_field::type_id::create("bg_adc_ref_err_max");

        this.asil_ftt = uvm_reg_field::type_id::create("asil_ftt");

        this.afe_zero_config = uvm_reg_field::type_id::create("afe_zero_config");

        this.afe_hpdrv_chop = uvm_reg_field::type_id::create("afe_hpdrv_chop");

        this.afe_gain = uvm_reg_field::type_id::create("afe_gain");

        this.afe_adcchp = uvm_reg_field::type_id::create("afe_adcchp");

        this.adc_zero = uvm_reg_field::type_id::create("adc_zero");

        this.lint_bin_hyst.configure(this, 8,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint_bin_e.configure(this, 1,  8, "RW", 0, 'd0, 1, 1, 0);
        this.lin_scalar.configure(this, 1,  9, "RW", 0, 'd0, 1, 1, 0);
        this.hptest_lvl.configure(this, 4,  10, "RW", 0, 'd0, 1, 1, 0);
        this.hall_isel.configure(this, 5,  14, "RW", 0, 'd0, 1, 1, 0);
        this.bw_sel.configure(this, 3,  19, "RW", 0, 'd0, 1, 1, 0);
        this.bg_adc_ref_err_max.configure(this, 1,  22, "RW", 0, 'd0, 1, 1, 0);
        this.asil_ftt.configure(this, 1,  23, "RW", 0, 'd0, 1, 1, 0);
        this.afe_zero_config.configure(this, 1,  24, "RW", 0, 'd0, 1, 1, 0);
        this.afe_hpdrv_chop.configure(this, 2,  25, "RW", 0, 'd0, 1, 1, 0);
        this.afe_gain.configure(this, 2,  27, "RW", 0, 'd0, 1, 1, 0);
        this.afe_adcchp.configure(this, 2,  29, "RW", 0, 'd0, 1, 1, 0);
        this.adc_zero.configure(this, 1,  31, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg3
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg3
`define CLASS_block_name_shadow_Reg3
class block_name_shadow_Reg3 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg3)

    rand uvm_reg_field pol_f;
    rand uvm_reg_field pol_diag;
    rand uvm_reg_field pol_c;
    rand uvm_reg_field lint01;
    rand uvm_reg_field lint00;
    rand uvm_reg_field lint_out_inv;
    rand uvm_reg_field lint_in_inv;
    rand uvm_reg_field lint_e;

    // Function : new
    function new(string name = "block_name_shadow_Reg3");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.pol_f = uvm_reg_field::type_id::create("pol_f");

        this.pol_diag = uvm_reg_field::type_id::create("pol_diag");

        this.pol_c = uvm_reg_field::type_id::create("pol_c");

        this.lint01 = uvm_reg_field::type_id::create("lint01");

        this.lint00 = uvm_reg_field::type_id::create("lint00");

        this.lint_out_inv = uvm_reg_field::type_id::create("lint_out_inv");

        this.lint_in_inv = uvm_reg_field::type_id::create("lint_in_inv");

        this.lint_e = uvm_reg_field::type_id::create("lint_e");

        this.pol_f.configure(this, 1,  0, "RW", 0, 'd0, 1, 1, 0);
        this.pol_diag.configure(this, 1,  1, "RW", 0, 'd0, 1, 1, 0);
        this.pol_c.configure(this, 1,  2, "RW", 0, 'd0, 1, 1, 0);
        this.lint01.configure(this, 13,  3, "RW", 0, 'd0, 1, 1, 0);
        this.lint00.configure(this, 13,  16, "RW", 0, 'd0, 1, 1, 0);
        this.lint_out_inv.configure(this, 1,  29, "RW", 0, 'd0, 1, 1, 0);
        this.lint_in_inv.configure(this, 1,  30, "RW", 0, 'd0, 1, 1, 0);
        this.lint_e.configure(this, 1,  31, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg4
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg4
`define CLASS_block_name_shadow_Reg4
class block_name_shadow_Reg4 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg4)

    rand uvm_reg_field d_reg_ldo_boost;
    rand uvm_reg_field bw_sel_min;
    rand uvm_reg_field afe_hpsig_phase;
    rand uvm_reg_field lint03;
    rand uvm_reg_field lint02;

    // Function : new
    function new(string name = "block_name_shadow_Reg4");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.d_reg_ldo_boost = uvm_reg_field::type_id::create("d_reg_ldo_boost");

        this.bw_sel_min = uvm_reg_field::type_id::create("bw_sel_min");

        this.afe_hpsig_phase = uvm_reg_field::type_id::create("afe_hpsig_phase");

        this.lint03 = uvm_reg_field::type_id::create("lint03");

        this.lint02 = uvm_reg_field::type_id::create("lint02");

        this.d_reg_ldo_boost.configure(this, 2,  0, "RW", 0, 'd0, 1, 1, 0);
        this.bw_sel_min.configure(this, 3,  2, "RW", 0, 'd0, 1, 1, 0);
        this.afe_hpsig_phase.configure(this, 1,  5, "RW", 0, 'd0, 1, 1, 0);
        this.lint03.configure(this, 13,  6, "RW", 0, 'd0, 1, 1, 0);
        this.lint02.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg5
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg5
`define CLASS_block_name_shadow_Reg5
class block_name_shadow_Reg5 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg5)

    rand uvm_reg_field regref_err_max;
    rand uvm_reg_field refsigmon_en;
    rand uvm_reg_field hall_ref_err_max;
    rand uvm_reg_field filt_ada_gain;
    rand uvm_reg_field lint05;
    rand uvm_reg_field lint04;

    // Function : new
    function new(string name = "block_name_shadow_Reg5");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.regref_err_max = uvm_reg_field::type_id::create("regref_err_max");

        this.refsigmon_en = uvm_reg_field::type_id::create("refsigmon_en");

        this.hall_ref_err_max = uvm_reg_field::type_id::create("hall_ref_err_max");

        this.filt_ada_gain = uvm_reg_field::type_id::create("filt_ada_gain");

        this.lint05 = uvm_reg_field::type_id::create("lint05");

        this.lint04 = uvm_reg_field::type_id::create("lint04");

        this.regref_err_max.configure(this, 1,  0, "RW", 0, 'd0, 1, 1, 0);
        this.refsigmon_en.configure(this, 1,  1, "RW", 0, 'd0, 1, 1, 0);
        this.hall_ref_err_max.configure(this, 1,  2, "RW", 0, 'd0, 1, 1, 0);
        this.filt_ada_gain.configure(this, 3,  3, "RW", 0, 'd0, 1, 1, 0);
        this.lint05.configure(this, 13,  6, "RW", 0, 'd0, 1, 1, 0);
        this.lint04.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg6
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg6
`define CLASS_block_name_shadow_Reg6
class block_name_shadow_Reg6 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg6)

    rand uvm_reg_field spdiag_in_e;
    rand uvm_reg_field spdiag_en;
    rand uvm_reg_field sensm_c;
    rand uvm_reg_field lint07;
    rand uvm_reg_field lint06;

    /*new addition*/
    rand uvm_reg_field water1111;

    // Function : new
    function new(string name = "block_name_shadow_Reg6");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.spdiag_in_e = uvm_reg_field::type_id::create("spdiag_in_e");

        this.spdiag_en = uvm_reg_field::type_id::create("spdiag_en");

        this.sensm_c = uvm_reg_field::type_id::create("sensm_c");

        this.lint07 = uvm_reg_field::type_id::create("lint07");

        this.lint06 = uvm_reg_field::type_id::create("lint06");

        this.water1111 = uvm_reg_field::type_id::create("water1111");

        this.spdiag_in_e.configure(this, 1,  0, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_en.configure(this, 1,  1, "RW", 0, 'd0, 1, 1, 0);
        this.sensm_c.configure(this, 3,  2, "RW", 0, 'd0, 1, 1, 0);
        this.lint07.configure(this, 13,  5, "RW", 0, 'd0, 1, 1, 0);
        this.lint06.configure(this, 13,  18, "RW", 0, 'd0, 1, 1, 0);
        this.water1111.configure(this, 1,  31, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg7
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg7
`define CLASS_block_name_shadow_Reg7
class block_name_shadow_Reg7 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg7)

    rand uvm_reg_field tsen_chop_cfg;
    rand uvm_reg_field spdiag_rate;
    rand uvm_reg_field lint09;
    rand uvm_reg_field lint08;

    /*water1 changed to fire*/
    rand uvm_reg_field fire;

    // Function : new
    function new(string name = "block_name_shadow_Reg7");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.tsen_chop_cfg = uvm_reg_field::type_id::create("tsen_chop_cfg");

        this.spdiag_rate = uvm_reg_field::type_id::create("spdiag_rate");

        this.lint09 = uvm_reg_field::type_id::create("lint09");

        this.lint08 = uvm_reg_field::type_id::create("lint08");

        this.fire = uvm_reg_field::type_id::create("fire");

        this.tsen_chop_cfg.configure(this, 2,  0, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_rate.configure(this, 2,  2, "RW", 0, 'd0, 1, 1, 0);
        this.lint09.configure(this, 13,  4, "RW", 0, 'd0, 1, 1, 0);
        this.lint08.configure(this, 13,  17, "RW", 0, 'd0, 1, 1, 0);
        this.fire.configure(this, 1,  30, "RO", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg8
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg8
`define CLASS_block_name_shadow_Reg8
class block_name_shadow_Reg8 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg8)

    rand uvm_reg_field toff;
    rand uvm_reg_field lint11;
    rand uvm_reg_field lint10;

    // Function : new
    function new(string name = "block_name_shadow_Reg8");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.toff = uvm_reg_field::type_id::create("toff");

        this.lint11 = uvm_reg_field::type_id::create("lint11");

        this.lint10 = uvm_reg_field::type_id::create("lint10");

        this.toff.configure(this, 5,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint11.configure(this, 13,  5, "RW", 0, 'd0, 1, 1, 0);
        this.lint10.configure(this, 13,  18, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg9
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg9
`define CLASS_block_name_shadow_Reg9
class block_name_shadow_Reg9 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg9)

    rand uvm_reg_field lint13;
    rand uvm_reg_field lint12;

    // Function : new
    function new(string name = "block_name_shadow_Reg9");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.lint13 = uvm_reg_field::type_id::create("lint13");

        this.lint12 = uvm_reg_field::type_id::create("lint12");

        this.lint13.configure(this, 13,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint12.configure(this, 13,  13, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg10
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg10
`define CLASS_block_name_shadow_Reg10
class block_name_shadow_Reg10 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg10)

    rand uvm_reg_field lint15;
    rand uvm_reg_field lint14;

    // Function : new
    function new(string name = "block_name_shadow_Reg10");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.lint15 = uvm_reg_field::type_id::create("lint15");

        this.lint14 = uvm_reg_field::type_id::create("lint14");

        this.lint15.configure(this, 13,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint14.configure(this, 13,  13, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg11
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg11
`define CLASS_block_name_shadow_Reg11
class block_name_shadow_Reg11 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg11)

    rand uvm_reg_field tslp;
    rand uvm_reg_field plin_qvo;
    rand uvm_reg_field lint16;

    // Function : new
    function new(string name = "block_name_shadow_Reg11");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.tslp = uvm_reg_field::type_id::create("tslp");

        this.plin_qvo = uvm_reg_field::type_id::create("plin_qvo");

        this.lint16 = uvm_reg_field::type_id::create("lint16");

        this.tslp.configure(this, 7,  0, "RW", 0, 'd0, 1, 1, 0);
        this.plin_qvo.configure(this, 12,  7, "RW", 0, 'd0, 1, 1, 0);
        this.lint16.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg12
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg12
`define CLASS_block_name_shadow_Reg12
class block_name_shadow_Reg12 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg12)

    rand uvm_reg_field qo_c;
    rand uvm_reg_field plin_sens;

    // Function : new
    function new(string name = "block_name_shadow_Reg12");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.qo_c = uvm_reg_field::type_id::create("qo_c");

        this.plin_sens = uvm_reg_field::type_id::create("plin_sens");

        this.qo_c.configure(this, 18,  0, "RW", 0, 'd0, 1, 1, 0);
        this.plin_sens.configure(this, 12,  18, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg13
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg13
`define CLASS_block_name_shadow_Reg13
class block_name_shadow_Reg13 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg13)

    rand uvm_reg_field tzero;
    rand uvm_reg_field qotc_hot_c;
    rand uvm_reg_field qotc_cld_c;

    // Function : new
    function new(string name = "block_name_shadow_Reg13");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.tzero = uvm_reg_field::type_id::create("tzero");

        this.qotc_hot_c = uvm_reg_field::type_id::create("qotc_hot_c");

        this.qotc_cld_c = uvm_reg_field::type_id::create("qotc_cld_c");

        this.tzero.configure(this, 7,  0, "RW", 0, 'd0, 1, 1, 0);
        this.qotc_hot_c.configure(this, 12,  7, "RW", 0, 'd0, 1, 1, 0);
        this.qotc_cld_c.configure(this, 12,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg14
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg14
`define CLASS_block_name_shadow_Reg14
class block_name_shadow_Reg14 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg14)

    rand uvm_reg_field refsigmon_hall;
    rand uvm_reg_field clamp_h;
    rand uvm_reg_field refsigmon_bg;

    // Function : new
    function new(string name = "block_name_shadow_Reg14");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.refsigmon_hall = uvm_reg_field::type_id::create("refsigmon_hall");

        this.clamp_h = uvm_reg_field::type_id::create("clamp_h");

        this.refsigmon_bg = uvm_reg_field::type_id::create("refsigmon_bg");

        this.refsigmon_hall.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.clamp_h.configure(this, 12,  10, "RW", 0, 'd0, 1, 1, 0);
        this.refsigmon_bg.configure(this, 10,  22, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg15
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg15
`define CLASS_block_name_shadow_Reg15
class block_name_shadow_Reg15 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg15)

    rand uvm_reg_field sens_c;
    rand uvm_reg_field clamp_l;

    // Function : new
    function new(string name = "block_name_shadow_Reg15");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.sens_c = uvm_reg_field::type_id::create("sens_c");

        this.clamp_l = uvm_reg_field::type_id::create("clamp_l");

        this.sens_c.configure(this, 11,  0, "RW", 0, 'd0, 1, 1, 0);
        this.clamp_l.configure(this, 12,  11, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg16
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg16
`define CLASS_block_name_shadow_Reg16
class block_name_shadow_Reg16 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg16)

    rand uvm_reg_field senstc2_cld_c;
    rand uvm_reg_field sens_f;
    rand uvm_reg_field sens_diag;

    // Function : new
    function new(string name = "block_name_shadow_Reg16");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_cld_c = uvm_reg_field::type_id::create("senstc2_cld_c");

        this.sens_f = uvm_reg_field::type_id::create("sens_f");

        this.sens_diag = uvm_reg_field::type_id::create("sens_diag");

        this.senstc2_cld_c.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.sens_f.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.sens_diag.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg17
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg17
`define CLASS_block_name_shadow_Reg17
class block_name_shadow_Reg17 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg17)

    rand uvm_reg_field senstc2_cld_f;
    rand uvm_reg_field senstc1_cld_diag;
    rand uvm_reg_field senstc1_cld_c;

    // Function : new
    function new(string name = "block_name_shadow_Reg17");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_cld_f = uvm_reg_field::type_id::create("senstc2_cld_f");

        this.senstc1_cld_diag = uvm_reg_field::type_id::create("senstc1_cld_diag");

        this.senstc1_cld_c = uvm_reg_field::type_id::create("senstc1_cld_c");

        this.senstc2_cld_f.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_cld_diag.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_cld_c.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg18
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg18
`define CLASS_block_name_shadow_Reg18
class block_name_shadow_Reg18 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg18)

    rand uvm_reg_field senstc2_hot_c;
    rand uvm_reg_field senstc1_hot_c;
    rand uvm_reg_field senstc1_cld_f;

    // Function : new
    function new(string name = "block_name_shadow_Reg18");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_hot_c = uvm_reg_field::type_id::create("senstc2_hot_c");

        this.senstc1_hot_c = uvm_reg_field::type_id::create("senstc1_hot_c");

        this.senstc1_cld_f = uvm_reg_field::type_id::create("senstc1_cld_f");

        this.senstc2_hot_c.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_hot_c.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_cld_f.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg19
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg19
`define CLASS_block_name_shadow_Reg19
class block_name_shadow_Reg19 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg19)

    rand uvm_reg_field senstc2_hot_f;
    rand uvm_reg_field senstc1_hot_f;
    rand uvm_reg_field senstc1_hot_diag;

    // Function : new
    function new(string name = "block_name_shadow_Reg19");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_hot_f = uvm_reg_field::type_id::create("senstc2_hot_f");

        this.senstc1_hot_f = uvm_reg_field::type_id::create("senstc1_hot_f");

        this.senstc1_hot_diag = uvm_reg_field::type_id::create("senstc1_hot_diag");

        this.senstc2_hot_f.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_hot_f.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_hot_diag.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg20
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg20
`define CLASS_block_name_shadow_Reg20
class block_name_shadow_Reg20 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg20)

    rand uvm_reg_field vos_f;
    rand uvm_reg_field spdiag_in;

    // Function : new
    function new(string name = "block_name_shadow_Reg20");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.vos_f = uvm_reg_field::type_id::create("vos_f");

        this.spdiag_in = uvm_reg_field::type_id::create("spdiag_in");

        this.vos_f.configure(this, 14,  0, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_in.configure(this, 18,  14, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow_Reg21
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_shadow_Reg21
`define CLASS_block_name_shadow_Reg21
class block_name_shadow_Reg21 extends uvm_reg;
    `uvm_object_utils(block_name_shadow_Reg21)

    rand uvm_reg_field vostc_hot_f;
    rand uvm_reg_field vostc_cld_f;

    // Function : new
    function new(string name = "block_name_shadow_Reg21");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.vostc_hot_f = uvm_reg_field::type_id::create("vostc_hot_f");

        this.vostc_cld_f = uvm_reg_field::type_id::create("vostc_cld_f");

        this.vostc_hot_f.configure(this, 12,  0, "RW", 0, 'd0, 1, 1, 0);
        this.vostc_cld_f.configure(this, 12,  12, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg22
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg22
`define CLASS_block_name_eeprom_Reg22
class block_name_eeprom_Reg22 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg22)

    rand uvm_reg_field lint_out_inv;
    rand uvm_reg_field lint_in_inv;
    rand uvm_reg_field lint_e;
    rand uvm_reg_field lint_bin_hyst;
    rand uvm_reg_field lint_bin_e;
    rand uvm_reg_field lin_scalar;
    rand uvm_reg_field hptest_lvl;
    rand uvm_reg_field hall_isel;
    rand uvm_reg_field bw_sel;
    rand uvm_reg_field bg_adc_ref_err_max;
    rand uvm_reg_field asil_ftt;
    rand uvm_reg_field afe_zero_config;
    rand uvm_reg_field afe_hpdrv_chop;
    rand uvm_reg_field afe_gain;

    // Function : new
    function new(string name = "block_name_eeprom_Reg22");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.lint_out_inv = uvm_reg_field::type_id::create("lint_out_inv");

        this.lint_in_inv = uvm_reg_field::type_id::create("lint_in_inv");

        this.lint_e = uvm_reg_field::type_id::create("lint_e");

        this.lint_bin_hyst = uvm_reg_field::type_id::create("lint_bin_hyst");

        this.lint_bin_e = uvm_reg_field::type_id::create("lint_bin_e");

        this.lin_scalar = uvm_reg_field::type_id::create("lin_scalar");

        this.hptest_lvl = uvm_reg_field::type_id::create("hptest_lvl");

        this.hall_isel = uvm_reg_field::type_id::create("hall_isel");

        this.bw_sel = uvm_reg_field::type_id::create("bw_sel");

        this.bg_adc_ref_err_max = uvm_reg_field::type_id::create("bg_adc_ref_err_max");

        this.asil_ftt = uvm_reg_field::type_id::create("asil_ftt");

        this.afe_zero_config = uvm_reg_field::type_id::create("afe_zero_config");

        this.afe_hpdrv_chop = uvm_reg_field::type_id::create("afe_hpdrv_chop");

        this.afe_gain = uvm_reg_field::type_id::create("afe_gain");

        this.lint_out_inv.configure(this, 1,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint_in_inv.configure(this, 1,  1, "RW", 0, 'd0, 1, 1, 0);
        this.lint_e.configure(this, 1,  2, "RW", 0, 'd0, 1, 1, 0);
        this.lint_bin_hyst.configure(this, 8,  3, "RW", 0, 'd0, 1, 1, 0);
        this.lint_bin_e.configure(this, 1,  11, "RW", 0, 'd0, 1, 1, 0);
        this.lin_scalar.configure(this, 1,  12, "RW", 0, 'd0, 1, 1, 0);
        this.hptest_lvl.configure(this, 4,  13, "RW", 0, 'd0, 1, 1, 0);
        this.hall_isel.configure(this, 5,  17, "RW", 0, 'd0, 1, 1, 0);
        this.bw_sel.configure(this, 3,  22, "RW", 0, 'd0, 1, 1, 0);
        this.bg_adc_ref_err_max.configure(this, 1,  25, "RW", 0, 'd0, 1, 1, 0);
        this.asil_ftt.configure(this, 1,  26, "RW", 0, 'd0, 1, 1, 0);
        this.afe_zero_config.configure(this, 1,  27, "RW", 0, 'd0, 1, 1, 0);
        this.afe_hpdrv_chop.configure(this, 2,  28, "RW", 0, 'd0, 1, 1, 0);
        this.afe_gain.configure(this, 2,  30, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg23
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg23
`define CLASS_block_name_eeprom_Reg23
class block_name_eeprom_Reg23 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg23)

    rand uvm_reg_field d_reg_ldo_boost;
    rand uvm_reg_field afe_hpsig_phase;
    rand uvm_reg_field pol_f;
    rand uvm_reg_field pol_diag;
    rand uvm_reg_field pol_c;
    rand uvm_reg_field lint01;
    rand uvm_reg_field lint00;

    // Function : new
    function new(string name = "block_name_eeprom_Reg23");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.d_reg_ldo_boost = uvm_reg_field::type_id::create("d_reg_ldo_boost");

        this.afe_hpsig_phase = uvm_reg_field::type_id::create("afe_hpsig_phase");

        this.pol_f = uvm_reg_field::type_id::create("pol_f");

        this.pol_diag = uvm_reg_field::type_id::create("pol_diag");

        this.pol_c = uvm_reg_field::type_id::create("pol_c");

        this.lint01 = uvm_reg_field::type_id::create("lint01");

        this.lint00 = uvm_reg_field::type_id::create("lint00");

        this.d_reg_ldo_boost.configure(this, 2,  0, "RW", 0, 'd0, 1, 1, 0);
        this.afe_hpsig_phase.configure(this, 1,  2, "RW", 0, 'd0, 1, 1, 0);
        this.pol_f.configure(this, 1,  3, "RW", 0, 'd0, 1, 1, 0);
        this.pol_diag.configure(this, 1,  4, "RW", 0, 'd0, 1, 1, 0);
        this.pol_c.configure(this, 1,  5, "RW", 0, 'd0, 1, 1, 0);
        this.lint01.configure(this, 13,  6, "RW", 0, 'd0, 1, 1, 0);
        this.lint00.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg24
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg24
`define CLASS_block_name_eeprom_Reg24
class block_name_eeprom_Reg24 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg24)

    rand uvm_reg_field filt_ada_gain;
    rand uvm_reg_field bw_sel_min;
    rand uvm_reg_field lint03;
    rand uvm_reg_field lint02;

    // Function : new
    function new(string name = "block_name_eeprom_Reg24");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.filt_ada_gain = uvm_reg_field::type_id::create("filt_ada_gain");

        this.bw_sel_min = uvm_reg_field::type_id::create("bw_sel_min");

        this.lint03 = uvm_reg_field::type_id::create("lint03");

        this.lint02 = uvm_reg_field::type_id::create("lint02");

        this.filt_ada_gain.configure(this, 3,  0, "RW", 0, 'd0, 1, 1, 0);
        this.bw_sel_min.configure(this, 3,  3, "RW", 0, 'd0, 1, 1, 0);
        this.lint03.configure(this, 13,  6, "RW", 0, 'd0, 1, 1, 0);
        this.lint02.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg25
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg25
`define CLASS_block_name_eeprom_Reg25
class block_name_eeprom_Reg25 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg25)

    rand uvm_reg_field sensm_c;
    rand uvm_reg_field regref_err_max;
    rand uvm_reg_field refsigmon_en;
    rand uvm_reg_field hall_ref_err_max;
    rand uvm_reg_field lint05;
    rand uvm_reg_field lint04;

    // Function : new
    function new(string name = "block_name_eeprom_Reg25");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.sensm_c = uvm_reg_field::type_id::create("sensm_c");

        this.regref_err_max = uvm_reg_field::type_id::create("regref_err_max");

        this.refsigmon_en = uvm_reg_field::type_id::create("refsigmon_en");

        this.hall_ref_err_max = uvm_reg_field::type_id::create("hall_ref_err_max");

        this.lint05 = uvm_reg_field::type_id::create("lint05");

        this.lint04 = uvm_reg_field::type_id::create("lint04");

        this.sensm_c.configure(this, 3,  0, "RW", 0, 'd0, 1, 1, 0);
        this.regref_err_max.configure(this, 1,  3, "RW", 0, 'd0, 1, 1, 0);
        this.refsigmon_en.configure(this, 1,  4, "RW", 0, 'd0, 1, 1, 0);
        this.hall_ref_err_max.configure(this, 1,  5, "RW", 0, 'd0, 1, 1, 0);
        this.lint05.configure(this, 13,  6, "RW", 0, 'd0, 1, 1, 0);
        this.lint04.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg26
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg26
`define CLASS_block_name_eeprom_Reg26
class block_name_eeprom_Reg26 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg26)

    rand uvm_reg_field tsen_chop_cfg;
    rand uvm_reg_field spdiag_rate;
    rand uvm_reg_field spdiag_in_e;
    rand uvm_reg_field spdiag_en;
    rand uvm_reg_field lint07;
    rand uvm_reg_field lint06;

    // Function : new
    function new(string name = "block_name_eeprom_Reg26");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.tsen_chop_cfg = uvm_reg_field::type_id::create("tsen_chop_cfg");

        this.spdiag_rate = uvm_reg_field::type_id::create("spdiag_rate");

        this.spdiag_in_e = uvm_reg_field::type_id::create("spdiag_in_e");

        this.spdiag_en = uvm_reg_field::type_id::create("spdiag_en");

        this.lint07 = uvm_reg_field::type_id::create("lint07");

        this.lint06 = uvm_reg_field::type_id::create("lint06");

        this.tsen_chop_cfg.configure(this, 2,  0, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_rate.configure(this, 2,  2, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_in_e.configure(this, 1,  4, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_en.configure(this, 1,  5, "RW", 0, 'd0, 1, 1, 0);
        this.lint07.configure(this, 13,  6, "RW", 0, 'd0, 1, 1, 0);
        this.lint06.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg27
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg27
`define CLASS_block_name_eeprom_Reg27
class block_name_eeprom_Reg27 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg27)

    rand uvm_reg_field toff;
    rand uvm_reg_field lint09;
    rand uvm_reg_field lint08;

    // Function : new
    function new(string name = "block_name_eeprom_Reg27");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.toff = uvm_reg_field::type_id::create("toff");

        this.lint09 = uvm_reg_field::type_id::create("lint09");

        this.lint08 = uvm_reg_field::type_id::create("lint08");

        this.toff.configure(this, 5,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint09.configure(this, 13,  5, "RW", 0, 'd0, 1, 1, 0);
        this.lint08.configure(this, 13,  18, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg28
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg28
`define CLASS_block_name_eeprom_Reg28
class block_name_eeprom_Reg28 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg28)

    rand uvm_reg_field lint11;
    rand uvm_reg_field lint10;

    // Function : new
    function new(string name = "block_name_eeprom_Reg28");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.lint11 = uvm_reg_field::type_id::create("lint11");

        this.lint10 = uvm_reg_field::type_id::create("lint10");

        this.lint11.configure(this, 13,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint10.configure(this, 13,  13, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg29
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg29
`define CLASS_block_name_eeprom_Reg29
class block_name_eeprom_Reg29 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg29)

    rand uvm_reg_field lint13;
    rand uvm_reg_field lint12;

    // Function : new
    function new(string name = "block_name_eeprom_Reg29");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.lint13 = uvm_reg_field::type_id::create("lint13");

        this.lint12 = uvm_reg_field::type_id::create("lint12");

        this.lint13.configure(this, 13,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint12.configure(this, 13,  13, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg30
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg30
`define CLASS_block_name_eeprom_Reg30
class block_name_eeprom_Reg30 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg30)

    rand uvm_reg_field lint15;
    rand uvm_reg_field lint14;

    // Function : new
    function new(string name = "block_name_eeprom_Reg30");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.lint15 = uvm_reg_field::type_id::create("lint15");

        this.lint14 = uvm_reg_field::type_id::create("lint14");

        this.lint15.configure(this, 13,  0, "RW", 0, 'd0, 1, 1, 0);
        this.lint14.configure(this, 13,  13, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg31
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg31
`define CLASS_block_name_eeprom_Reg31
class block_name_eeprom_Reg31 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg31)

    rand uvm_reg_field tslp;
    rand uvm_reg_field plin_qvo;
    rand uvm_reg_field lint16;

    // Function : new
    function new(string name = "block_name_eeprom_Reg31");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.tslp = uvm_reg_field::type_id::create("tslp");

        this.plin_qvo = uvm_reg_field::type_id::create("plin_qvo");

        this.lint16 = uvm_reg_field::type_id::create("lint16");

        this.tslp.configure(this, 7,  0, "RW", 0, 'd0, 1, 1, 0);
        this.plin_qvo.configure(this, 12,  7, "RW", 0, 'd0, 1, 1, 0);
        this.lint16.configure(this, 13,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg32
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg32
`define CLASS_block_name_eeprom_Reg32
class block_name_eeprom_Reg32 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg32)

    rand uvm_reg_field qo_c;
    rand uvm_reg_field plin_sens;

    // Function : new
    function new(string name = "block_name_eeprom_Reg32");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.qo_c = uvm_reg_field::type_id::create("qo_c");

        this.plin_sens = uvm_reg_field::type_id::create("plin_sens");

        this.qo_c.configure(this, 18,  0, "RW", 0, 'd0, 1, 1, 0);
        this.plin_sens.configure(this, 12,  18, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg33
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg33
`define CLASS_block_name_eeprom_Reg33
class block_name_eeprom_Reg33 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg33)

    rand uvm_reg_field tzero;
    rand uvm_reg_field qotc_hot_c;
    rand uvm_reg_field qotc_cld_c;

    // Function : new
    function new(string name = "block_name_eeprom_Reg33");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.tzero = uvm_reg_field::type_id::create("tzero");

        this.qotc_hot_c = uvm_reg_field::type_id::create("qotc_hot_c");

        this.qotc_cld_c = uvm_reg_field::type_id::create("qotc_cld_c");

        this.tzero.configure(this, 7,  0, "RW", 0, 'd0, 1, 1, 0);
        this.qotc_hot_c.configure(this, 12,  7, "RW", 0, 'd0, 1, 1, 0);
        this.qotc_cld_c.configure(this, 12,  19, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg34
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg34
`define CLASS_block_name_eeprom_Reg34
class block_name_eeprom_Reg34 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg34)

    rand uvm_reg_field refsigmon_hall;
    rand uvm_reg_field clamp_h;
    rand uvm_reg_field refsigmon_bg;

    // Function : new
    function new(string name = "block_name_eeprom_Reg34");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.refsigmon_hall = uvm_reg_field::type_id::create("refsigmon_hall");

        this.clamp_h = uvm_reg_field::type_id::create("clamp_h");

        this.refsigmon_bg = uvm_reg_field::type_id::create("refsigmon_bg");

        this.refsigmon_hall.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.clamp_h.configure(this, 12,  10, "RW", 0, 'd0, 1, 1, 0);
        this.refsigmon_bg.configure(this, 10,  22, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg35
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg35
`define CLASS_block_name_eeprom_Reg35
class block_name_eeprom_Reg35 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg35)

    rand uvm_reg_field sens_c;
    rand uvm_reg_field clamp_l;

    // Function : new
    function new(string name = "block_name_eeprom_Reg35");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.sens_c = uvm_reg_field::type_id::create("sens_c");

        this.clamp_l = uvm_reg_field::type_id::create("clamp_l");

        this.sens_c.configure(this, 11,  0, "RW", 0, 'd0, 1, 1, 0);
        this.clamp_l.configure(this, 12,  11, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg36
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg36
`define CLASS_block_name_eeprom_Reg36
class block_name_eeprom_Reg36 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg36)

    rand uvm_reg_field senstc2_cld_c;
    rand uvm_reg_field sens_f;
    rand uvm_reg_field sens_diag;

    // Function : new
    function new(string name = "block_name_eeprom_Reg36");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_cld_c = uvm_reg_field::type_id::create("senstc2_cld_c");

        this.sens_f = uvm_reg_field::type_id::create("sens_f");

        this.sens_diag = uvm_reg_field::type_id::create("sens_diag");

        this.senstc2_cld_c.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.sens_f.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.sens_diag.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg37
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg37
`define CLASS_block_name_eeprom_Reg37
class block_name_eeprom_Reg37 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg37)

    rand uvm_reg_field senstc2_cld_f;
    rand uvm_reg_field senstc1_cld_diag;
    rand uvm_reg_field senstc1_cld_c;

    // Function : new
    function new(string name = "block_name_eeprom_Reg37");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_cld_f = uvm_reg_field::type_id::create("senstc2_cld_f");

        this.senstc1_cld_diag = uvm_reg_field::type_id::create("senstc1_cld_diag");

        this.senstc1_cld_c = uvm_reg_field::type_id::create("senstc1_cld_c");

        this.senstc2_cld_f.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_cld_diag.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_cld_c.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg38
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg38
`define CLASS_block_name_eeprom_Reg38
class block_name_eeprom_Reg38 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg38)

    rand uvm_reg_field senstc2_hot_c;
    rand uvm_reg_field senstc1_hot_c;
    rand uvm_reg_field senstc1_cld_f;

    // Function : new
    function new(string name = "block_name_eeprom_Reg38");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_hot_c = uvm_reg_field::type_id::create("senstc2_hot_c");

        this.senstc1_hot_c = uvm_reg_field::type_id::create("senstc1_hot_c");

        this.senstc1_cld_f = uvm_reg_field::type_id::create("senstc1_cld_f");

        this.senstc2_hot_c.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_hot_c.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_cld_f.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg39
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg39
`define CLASS_block_name_eeprom_Reg39
class block_name_eeprom_Reg39 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg39)

    rand uvm_reg_field senstc2_hot_f;
    rand uvm_reg_field senstc1_hot_f;
    rand uvm_reg_field senstc1_hot_diag;

    // Function : new
    function new(string name = "block_name_eeprom_Reg39");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.senstc2_hot_f = uvm_reg_field::type_id::create("senstc2_hot_f");

        this.senstc1_hot_f = uvm_reg_field::type_id::create("senstc1_hot_f");

        this.senstc1_hot_diag = uvm_reg_field::type_id::create("senstc1_hot_diag");

        this.senstc2_hot_f.configure(this, 10,  0, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_hot_f.configure(this, 11,  10, "RW", 0, 'd0, 1, 1, 0);
        this.senstc1_hot_diag.configure(this, 11,  21, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg40
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg40
`define CLASS_block_name_eeprom_Reg40
class block_name_eeprom_Reg40 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg40)

    rand uvm_reg_field vos_f;
    rand uvm_reg_field spdiag_in;

    // Function : new
    function new(string name = "block_name_eeprom_Reg40");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.vos_f = uvm_reg_field::type_id::create("vos_f");

        this.spdiag_in = uvm_reg_field::type_id::create("spdiag_in");

        this.vos_f.configure(this, 14,  0, "RW", 0, 'd0, 1, 1, 0);
        this.spdiag_in.configure(this, 18,  14, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom_Reg41
-----------------------------------------------------------------------*/

`ifndef CLASS_block_name_eeprom_Reg41
`define CLASS_block_name_eeprom_Reg41
class block_name_eeprom_Reg41 extends uvm_reg;
    `uvm_object_utils(block_name_eeprom_Reg41)

    rand uvm_reg_field vostc_hot_f;
    rand uvm_reg_field vostc_cld_f;

    // Function : new
    function new(string name = "block_name_eeprom_Reg41");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.vostc_hot_f = uvm_reg_field::type_id::create("vostc_hot_f");

        this.vostc_cld_f = uvm_reg_field::type_id::create("vostc_cld_f");

        this.vostc_hot_f.configure(this, 12,  0, "RW", 0, 'd0, 1, 1, 0);
        this.vostc_cld_f.configure(this, 12,  12, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_eeprom
-----------------------------------------------------------------------*/
`ifndef CLASS_block_name_eeprom
`define CLASS_block_name_eeprom
class block_name_eeprom extends uvm_reg_file;
    `uvm_object_utils(block_name_eeprom)

    rand block_name_eeprom_Reg22 Reg22;

    rand block_name_eeprom_Reg23 Reg23;

    rand block_name_eeprom_Reg24 Reg24;

    rand block_name_eeprom_Reg25 Reg25;

    rand block_name_eeprom_Reg26 Reg26;

    rand block_name_eeprom_Reg27 Reg27;

    rand block_name_eeprom_Reg28 Reg28;

    rand block_name_eeprom_Reg29 Reg29;

    rand block_name_eeprom_Reg30 Reg30;

    rand block_name_eeprom_Reg31 Reg31;

    rand block_name_eeprom_Reg32 Reg32;

    rand block_name_eeprom_Reg33 Reg33;

    rand block_name_eeprom_Reg34 Reg34;

    rand block_name_eeprom_Reg35 Reg35;

    rand block_name_eeprom_Reg36 Reg36;

    rand block_name_eeprom_Reg37 Reg37;

    rand block_name_eeprom_Reg38 Reg38;

    rand block_name_eeprom_Reg39 Reg39;

    rand block_name_eeprom_Reg40 Reg40;

    rand block_name_eeprom_Reg41 Reg41;

    // Function : new
    function new(string name = "block_name_eeprom");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        Reg22   =   block_name_eeprom_Reg22::type_id::create("Reg22");
        Reg23   =   block_name_eeprom_Reg23::type_id::create("Reg23");
        Reg24   =   block_name_eeprom_Reg24::type_id::create("Reg24");
        Reg25   =   block_name_eeprom_Reg25::type_id::create("Reg25");
        Reg26   =   block_name_eeprom_Reg26::type_id::create("Reg26");
        Reg27   =   block_name_eeprom_Reg27::type_id::create("Reg27");
        Reg28   =   block_name_eeprom_Reg28::type_id::create("Reg28");
        Reg29   =   block_name_eeprom_Reg29::type_id::create("Reg29");
        Reg30   =   block_name_eeprom_Reg30::type_id::create("Reg30");
        Reg31   =   block_name_eeprom_Reg31::type_id::create("Reg31");
        Reg32   =   block_name_eeprom_Reg32::type_id::create("Reg32");
        Reg33   =   block_name_eeprom_Reg33::type_id::create("Reg33");
        Reg34   =   block_name_eeprom_Reg34::type_id::create("Reg34");
        Reg35   =   block_name_eeprom_Reg35::type_id::create("Reg35");
        Reg36   =   block_name_eeprom_Reg36::type_id::create("Reg36");
        Reg37   =   block_name_eeprom_Reg37::type_id::create("Reg37");
        Reg38   =   block_name_eeprom_Reg38::type_id::create("Reg38");
        Reg39   =   block_name_eeprom_Reg39::type_id::create("Reg39");
        Reg40   =   block_name_eeprom_Reg40::type_id::create("Reg40");
        Reg41   =   block_name_eeprom_Reg41::type_id::create("Reg41");

        //config
        Reg22.configure(get_block(), this, "Reg22");
        Reg23.configure(get_block(), this, "Reg23");
        Reg24.configure(get_block(), this, "Reg24");
        Reg25.configure(get_block(), this, "Reg25");
        Reg26.configure(get_block(), this, "Reg26");
        Reg27.configure(get_block(), this, "Reg27");
        Reg28.configure(get_block(), this, "Reg28");
        Reg29.configure(get_block(), this, "Reg29");
        Reg30.configure(get_block(), this, "Reg30");
        Reg31.configure(get_block(), this, "Reg31");
        Reg32.configure(get_block(), this, "Reg32");
        Reg33.configure(get_block(), this, "Reg33");
        Reg34.configure(get_block(), this, "Reg34");
        Reg35.configure(get_block(), this, "Reg35");
        Reg36.configure(get_block(), this, "Reg36");
        Reg37.configure(get_block(), this, "Reg37");
        Reg38.configure(get_block(), this, "Reg38");
        Reg39.configure(get_block(), this, "Reg39");
        Reg40.configure(get_block(), this, "Reg40");
        Reg41.configure(get_block(), this, "Reg41");

        //build
        Reg22.build();
        Reg23.build();
        Reg24.build();
        Reg25.build();
        Reg26.build();
        Reg27.build();
        Reg28.build();
        Reg29.build();
        Reg30.build();
        Reg31.build();
        Reg32.build();
        Reg33.build();
        Reg34.build();
        Reg35.build();
        Reg36.build();
        Reg37.build();
        Reg38.build();
        Reg39.build();
        Reg40.build();
        Reg41.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg( Reg22, offset +  'h0, "RW");
        mp.add_reg( Reg23, offset +  'h4, "RW");
        mp.add_reg( Reg24, offset +  'h8, "RW");
        mp.add_reg( Reg25, offset +  'hC, "RW");
        mp.add_reg( Reg26, offset +  'h10, "RW");
        mp.add_reg( Reg27, offset +  'h14, "RW");
        mp.add_reg( Reg28, offset +  'h18, "RW");
        mp.add_reg( Reg29, offset +  'h1C, "RW");
        mp.add_reg( Reg30, offset +  'h20, "RW");
        mp.add_reg( Reg31, offset +  'h24, "RW");
        mp.add_reg( Reg32, offset +  'h28, "RW");
        mp.add_reg( Reg33, offset +  'h2C, "RW");
        mp.add_reg( Reg34, offset +  'h30, "RW");
        mp.add_reg( Reg35, offset +  'h34, "RW");
        mp.add_reg( Reg36, offset +  'h38, "RW");
        mp.add_reg( Reg37, offset +  'h3C, "RW");
        mp.add_reg( Reg38, offset +  'h40, "RW");
        mp.add_reg( Reg39, offset +  'h44, "RW");
        mp.add_reg( Reg40, offset +  'h48, "RW");
        mp.add_reg( Reg41, offset +  'h4C, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        Reg22.set_offset(mp, offset +  'h0);
        Reg23.set_offset(mp, offset +  'h4);
        Reg24.set_offset(mp, offset +  'h8);
        Reg25.set_offset(mp, offset +  'hC);
        Reg26.set_offset(mp, offset +  'h10);
        Reg27.set_offset(mp, offset +  'h14);
        Reg28.set_offset(mp, offset +  'h18);
        Reg29.set_offset(mp, offset +  'h1C);
        Reg30.set_offset(mp, offset +  'h20);
        Reg31.set_offset(mp, offset +  'h24);
        Reg32.set_offset(mp, offset +  'h28);
        Reg33.set_offset(mp, offset +  'h2C);
        Reg34.set_offset(mp, offset +  'h30);
        Reg35.set_offset(mp, offset +  'h34);
        Reg36.set_offset(mp, offset +  'h38);
        Reg37.set_offset(mp, offset +  'h3C);
        Reg38.set_offset(mp, offset +  'h40);
        Reg39.set_offset(mp, offset +  'h44);
        Reg40.set_offset(mp, offset +  'h48);
        Reg41.set_offset(mp, offset +  'h4C);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_shadow
-----------------------------------------------------------------------*/
`ifndef CLASS_block_name_shadow
`define CLASS_block_name_shadow
class block_name_shadow extends uvm_reg_file;
    `uvm_object_utils(block_name_shadow)

    rand block_name_shadow_Reg2 Reg2;

    rand block_name_shadow_Reg3 Reg3;

    rand block_name_shadow_Reg4 Reg4;

    rand block_name_shadow_Reg5 Reg5;

    rand block_name_shadow_Reg6 Reg6;

    rand block_name_shadow_Reg7 Reg7;

    rand block_name_shadow_Reg8 Reg8;

    rand block_name_shadow_Reg9 Reg9;

    rand block_name_shadow_Reg10 Reg10;

    rand block_name_shadow_Reg11 Reg11;

    rand block_name_shadow_Reg12 Reg12;

    rand block_name_shadow_Reg13 Reg13;

    rand block_name_shadow_Reg14 Reg14;

    rand block_name_shadow_Reg15 Reg15;

    rand block_name_shadow_Reg16 Reg16;

    rand block_name_shadow_Reg17 Reg17;

    rand block_name_shadow_Reg18 Reg18;

    rand block_name_shadow_Reg19 Reg19;

    rand block_name_shadow_Reg20 Reg20;

    rand block_name_shadow_Reg21 Reg21;

    // Function : new
    function new(string name = "block_name_shadow");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        Reg2   =   block_name_shadow_Reg2::type_id::create("Reg2");
        Reg3   =   block_name_shadow_Reg3::type_id::create("Reg3");
        Reg4   =   block_name_shadow_Reg4::type_id::create("Reg4");
        Reg5   =   block_name_shadow_Reg5::type_id::create("Reg5");
        Reg6   =   block_name_shadow_Reg6::type_id::create("Reg6");
        Reg7   =   block_name_shadow_Reg7::type_id::create("Reg7");
        Reg8   =   block_name_shadow_Reg8::type_id::create("Reg8");
        Reg9   =   block_name_shadow_Reg9::type_id::create("Reg9");
        Reg10   =   block_name_shadow_Reg10::type_id::create("Reg10");
        Reg11   =   block_name_shadow_Reg11::type_id::create("Reg11");
        Reg12   =   block_name_shadow_Reg12::type_id::create("Reg12");
        Reg13   =   block_name_shadow_Reg13::type_id::create("Reg13");
        Reg14   =   block_name_shadow_Reg14::type_id::create("Reg14");
        Reg15   =   block_name_shadow_Reg15::type_id::create("Reg15");
        Reg16   =   block_name_shadow_Reg16::type_id::create("Reg16");
        Reg17   =   block_name_shadow_Reg17::type_id::create("Reg17");
        Reg18   =   block_name_shadow_Reg18::type_id::create("Reg18");
        Reg19   =   block_name_shadow_Reg19::type_id::create("Reg19");
        Reg20   =   block_name_shadow_Reg20::type_id::create("Reg20");
        Reg21   =   block_name_shadow_Reg21::type_id::create("Reg21");

        //config
        Reg2.configure(get_block(), this, "Reg2");
        Reg3.configure(get_block(), this, "Reg3");
        Reg4.configure(get_block(), this, "Reg4");
        Reg5.configure(get_block(), this, "Reg5");
        Reg6.configure(get_block(), this, "Reg6");
        Reg7.configure(get_block(), this, "Reg7");
        Reg8.configure(get_block(), this, "Reg8");
        Reg9.configure(get_block(), this, "Reg9");
        Reg10.configure(get_block(), this, "Reg10");
        Reg11.configure(get_block(), this, "Reg11");
        Reg12.configure(get_block(), this, "Reg12");
        Reg13.configure(get_block(), this, "Reg13");
        Reg14.configure(get_block(), this, "Reg14");
        Reg15.configure(get_block(), this, "Reg15");
        Reg16.configure(get_block(), this, "Reg16");
        Reg17.configure(get_block(), this, "Reg17");
        Reg18.configure(get_block(), this, "Reg18");
        Reg19.configure(get_block(), this, "Reg19");
        Reg20.configure(get_block(), this, "Reg20");
        Reg21.configure(get_block(), this, "Reg21");

        //build
        Reg2.build();
        Reg3.build();
        Reg4.build();
        Reg5.build();
        Reg6.build();
        Reg7.build();
        Reg8.build();
        Reg9.build();
        Reg10.build();
        Reg11.build();
        Reg12.build();
        Reg13.build();
        Reg14.build();
        Reg15.build();
        Reg16.build();
        Reg17.build();
        Reg18.build();
        Reg19.build();
        Reg20.build();
        Reg21.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg( Reg2, offset +  'h0, "RW");
        mp.add_reg( Reg3, offset +  'h4, "RW");
        mp.add_reg( Reg4, offset +  'h8, "RW");
        mp.add_reg( Reg5, offset +  'hC, "RW");
        mp.add_reg( Reg6, offset +  'h10, "RW");
        mp.add_reg( Reg7, offset +  'h14, "RW");
        mp.add_reg( Reg8, offset +  'h18, "RW");
        mp.add_reg( Reg9, offset +  'h1C, "RW");
        mp.add_reg( Reg10, offset +  'h20, "RW");
        mp.add_reg( Reg11, offset +  'h24, "RW");
        mp.add_reg( Reg12, offset +  'h28, "RW");
        mp.add_reg( Reg13, offset +  'h2C, "RW");
        mp.add_reg( Reg14, offset +  'h30, "RW");
        mp.add_reg( Reg15, offset +  'h34, "RW");
        mp.add_reg( Reg16, offset +  'h38, "RW");
        mp.add_reg( Reg17, offset +  'h3C, "RW");
        mp.add_reg( Reg18, offset +  'h40, "RW");
        mp.add_reg( Reg19, offset +  'h44, "RW");
        mp.add_reg( Reg20, offset +  'h48, "RW");
        mp.add_reg( Reg21, offset +  'h4C, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        Reg2.set_offset(mp, offset +  'h0);
        Reg3.set_offset(mp, offset +  'h4);
        Reg4.set_offset(mp, offset +  'h8);
        Reg5.set_offset(mp, offset +  'hC);
        Reg6.set_offset(mp, offset +  'h10);
        Reg7.set_offset(mp, offset +  'h14);
        Reg8.set_offset(mp, offset +  'h18);
        Reg9.set_offset(mp, offset +  'h1C);
        Reg10.set_offset(mp, offset +  'h20);
        Reg11.set_offset(mp, offset +  'h24);
        Reg12.set_offset(mp, offset +  'h28);
        Reg13.set_offset(mp, offset +  'h2C);
        Reg14.set_offset(mp, offset +  'h30);
        Reg15.set_offset(mp, offset +  'h34);
        Reg16.set_offset(mp, offset +  'h38);
        Reg17.set_offset(mp, offset +  'h3C);
        Reg18.set_offset(mp, offset +  'h40);
        Reg19.set_offset(mp, offset +  'h44);
        Reg20.set_offset(mp, offset +  'h48);
        Reg21.set_offset(mp, offset +  'h4C);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block_name_volatile
-----------------------------------------------------------------------*/
`ifndef CLASS_block_name_volatile
`define CLASS_block_name_volatile
class block_name_volatile extends uvm_reg_file;
    `uvm_object_utils(block_name_volatile)

    rand block_name_volatile_Reg0 Reg0;

    rand block_name_volatile_Reg1 Reg1;

    // Function : new
    function new(string name = "block_name_volatile");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        Reg0   =   block_name_volatile_Reg0::type_id::create("Reg0");
        Reg1   =   block_name_volatile_Reg1::type_id::create("Reg1");

        //config
        Reg0.configure(get_block(), this, "Reg0");
        Reg1.configure(get_block(), this, "Reg1");

        //build
        Reg0.build();
        Reg1.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg( Reg0, offset +  'h0, "RW");
        mp.add_reg( Reg1, offset +  'h4, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        Reg0.set_offset(mp, offset +  'h0);
        Reg1.set_offset(mp, offset +  'h4);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class      : block_name_block
-----------------------------------------------------------------------*/
`ifndef CLASS_block_name_block
`define CLASS_block_name_block
class block_name_block extends uvm_reg_block;
    `uvm_object_utils(block_name_block)

    rand block_name_volatile volatile;
    rand block_name_shadow shadow;
    rand block_name_eeprom eeprom;

    // Function : new
    function new(string name = "block_name_block");
        super.new(name, UVM_NO_COVERAGE);
    endfunction

    // Function : build
    virtual function void build();
        //VOLATILE
        volatile   =   block_name_volatile::type_id::create("volatile");
        volatile.configure(this, null, "volatile");
        volatile.build();

        //SHADOW
        shadow   =   block_name_shadow::type_id::create("shadow");
        shadow.configure(this, null, "shadow");
        shadow.build();

        //EEPROM
        eeprom   =   block_name_eeprom::type_id::create("eeprom");
        eeprom.configure(this, null, "eeprom");
        eeprom.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
        volatile.map( default_map, 'h0);
        shadow.map( default_map, 'h8);
        eeprom.map( default_map, 'h58);

        lock_model();
    endfunction

endclass : block_name_block
`endif
