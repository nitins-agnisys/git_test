//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Agnisys
// generated from    : D:\AgnisysProjects\git_test\Allegro_test\Test\test38.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : PROPRIETARY
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

//------------------------------------------------
//  BLOCK : BLK MODULE
//

module blk_ids(
    
    // REGISTER : RG1 PORT SIGNAL
    rg1_enb,
    rg1_f1_in,
    rg1_f1_in_enb,
    rg1_f1_r,
    
    
    // REGISTER : RG11 PORT SIGNAL
    reg_grp1_rg11_enb,
    reg_grp1_rg11_f11_in,
    reg_grp1_rg11_f11_in_enb,
    reg_grp1_rg11_f11_r,
    
    
    
    //CUSTOM signals
    clk,   // Bus clock
    reset_l,   // Reset
    rd_stb,   // Read strobe        : This signal should be HIGH during read operation and LOW during write operation
    rd_wait,   // Read wait
    wr_stb,   // Write strobe       : This signal should be HIGH during write operation and LOW during read operation
    address,   // Address for write/read
    wr_data,   // Write data
    byteenable,   // Specify which bytes are being written or during read which bytes the master is reading
    request,   // Bus request signal : HIGH indicates bus is free and LOW indicates bus is busy
    rd_data_vld,   // Read data valid : Asserted by the slave to indicate that the read data signal contains valid data
    rd_data   // Read data
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 2;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REG_GRP1
    parameter reg_grp1_count         = 1;
    parameter reg_grp1_address_width = addr_width;
    
    
    parameter blk_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : RG1 SIGNALS
    
    
    wire    rg1_decode;         // DECODE
    wire    rg1_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] rg1_rd_data;          // READ DATA
    wire    [64-1 : 0] rg1_offset;  // OFFSET
    output  rg1_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   rg1_f1_in_enb ;      // FIELD : F1
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [7 : 0] rg1_f1_q ;      // FIELD : F1
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [7 : 0] rg1_f1_r ;      // FIELD : F1
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [7 : 0] rg1_f1_in ;      // FIELD : F1
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : RG11 SIGNALS
    
    
    wire    reg_grp1_rg11_decode;         // DECODE
    wire    reg_grp1_rg11_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] reg_grp1_rg11_rd_data;          // READ DATA
    wire    [64-1 : 0] reg_grp1_rg11_offset;  // OFFSET
    output  reg_grp1_rg11_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reg_grp1_rg11_f11_in_enb ;      // FIELD : F11
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [5 : 0] reg_grp1_rg11_f11_q ;      // FIELD : F11
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [5 : 0] reg_grp1_rg11_f11_r ;      // FIELD : F11
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [5 : 0] reg_grp1_rg11_f11_in ;      // FIELD : F11
    
    //-----------------------------------------------------
    
    
    
    //CUSTOM signals
    input clk;
    input reset_l;
    input rd_stb;
    output rd_wait;
    input wr_stb;
    input [addr_width-1 : 0] address;
    input [bus_width-1 : 0] wr_data;
    input [bus_width/8-1 : 0] byteenable;
    output request;
    output rd_data_vld;
    output [bus_width-1 : 0] rd_data;
    
    wire  [bus_width-1:0] rd_data;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    assign byte_enb = byteenable;
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  RG1
    // ADDRESS       :  block_offset+'h0                WIDTH : 16
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:7 : f1  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign rg1_wr_valid = rg1_decode && wr_stb;
    assign rg1_enb      = rg1_wr_valid;
    assign rg1_offset = block_offset+'h0;
    assign rg1_decode  = (address[blk_address_width-1 : 0]    == rg1_offset[blk_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  8
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                rg1_f1_q  <= 8'd0;
            end
        else
            begin
            if (rg1_f1_in_enb)   // F1 : HW Write
                begin
                    rg1_f1_q <= rg1_f1_in;
                end
            else
                begin
                    
                if (rg1_wr_valid)   // F1 : SW Write
                    begin
                        rg1_f1_q <=  ( wr_data[7 : 0] & reg_enb[7 : 0] ) | (rg1_f1_q & (~reg_enb[7 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign rg1_f1_r  =  rg1_f1_q ;    // Field : F1
    
    
    assign rg1_rd_data = rg1_decode ? {8'b0 ,rg1_f1_q} : 16'b0000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  RG11
    // ADDRESS       :  block_offset+'h2 + 'h0                WIDTH : 8
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:5 : f11  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reg_grp1_rg11_wr_valid = reg_grp1_rg11_decode && wr_stb;
    assign reg_grp1_rg11_enb      = reg_grp1_rg11_wr_valid;
    assign reg_grp1_rg11_offset = block_offset+'h2 + 'h0;
    assign reg_grp1_rg11_decode  = (address[reg_grp1_address_width-1 : 0]    == reg_grp1_rg11_offset[reg_grp1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F11
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  6
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg_grp1_rg11_f11_q <= 6'd1;
            end
        else
            begin
            if (reg_grp1_rg11_f11_in_enb)   // F11 : HW Write
                begin
                    reg_grp1_rg11_f11_q <= reg_grp1_rg11_f11_in;
                end
            else
                begin
                    
                if (reg_grp1_rg11_wr_valid)   // F11 : SW Write
                    begin
                        reg_grp1_rg11_f11_q <=  ( wr_data[5 : 0] & reg_enb[5 : 0] ) | (reg_grp1_rg11_f11_q & (~reg_enb[5 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg_grp1_rg11_f11_r =  reg_grp1_rg11_f11_q;    // Field : F11
    
    
    assign reg_grp1_rg11_rd_data = reg_grp1_rg11_decode ? {2'b0 ,reg_grp1_rg11_f11_q} : 8'b00000000;
    
    
    
    
    
    assign rd_data = rg1_rd_data |
    reg_grp1_rg11_rd_data ;
    
    
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    
endmodule
