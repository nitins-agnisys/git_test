//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Admin
// generated from    : C:\Users\Admin\Documents\GitHub\git_test\Allegro_test\case1\Book1.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AXI
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------
/*----------------------------------------------------------------------
Class       : block4_reggroup1_reggroup1
----------------------------------------------------------------------*/
`ifndef CLASS_block4_reggroup1_reggroup1
`define CLASS_block4_reggroup1_reggroup1
class block4_reggroup1_reggroup1 extends uvm_mem;
    `uvm_object_utils(block4_reggroup1_reggroup1)

    // Function : new
    function new(string name = "block4_reggroup1_reggroup1");
        super.new(name, 'hA, 32, "RO", UVM_NO_COVERAGE);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block4_reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block4_reg1
`define CLASS_block4_reg1
class block4_reg1 extends uvm_reg;
    `uvm_object_utils(block4_reg1)

    rand uvm_reg_field f1;
    rand uvm_reg_field f2;

    // Function : new
    function new(string name = "block4_reg1");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f2 = uvm_reg_field::type_id::create("f2");

        this.f1.configure(this, 16,  0, "RO", 0, 'd0, 1, 1, 0);
        this.f2.configure(this, 16,  16, "RO", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class      : block4_block
-----------------------------------------------------------------------*/
`ifndef CLASS_block4_block
`define CLASS_block4_block
class block4_block extends uvm_reg_block;
    `uvm_object_utils(block4_block)

    rand block4_reggroup1_reggroup1 reggroup1;

    rand block4_reg1 reg1;

    // Function : new
    function new(string name = "block4_block");
        super.new(name, UVM_NO_COVERAGE);
    endfunction

    // Function : build
    virtual function void build();
        //REGGROUP1
        reggroup1   =   block4_reggroup1_reggroup1::type_id::create("reggroup1");
        reggroup1.configure(this, "reggroup1");

        //REG1
        reg1   =   block4_reg1::type_id::create("reg1");
        reg1.configure(this, null, "reg1");
        reg1.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
        default_map.add_mem(reggroup1, 'h0);

        default_map.add_reg( reg1, 'h28, "RW");

        lock_model();
    endfunction

endclass : block4_block
`endif

/*----------------------------------------------------------------------
Class       : block1_reggroup1_reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block1_reggroup1_reg1
`define CLASS_block1_reggroup1_reg1
class block1_reggroup1_reg1 extends uvm_reg;
    `uvm_object_utils(block1_reggroup1_reg1)

    rand uvm_reg_field f1;
    rand uvm_reg_field f2;

    // Function : new
    function new(string name = "block1_reggroup1_reg1");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f2 = uvm_reg_field::type_id::create("f2");

        this.f1.configure(this, 16,  0, "RW", 0, 'd0, 1, 1, 0);
        this.f2.configure(this, 16,  16, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block1_reggroup1_reg2
-----------------------------------------------------------------------*/

`ifndef CLASS_block1_reggroup1_reg2
`define CLASS_block1_reggroup1_reg2
class block1_reggroup1_reg2 extends uvm_reg;
    `uvm_object_utils(block1_reggroup1_reg2)

    rand uvm_reg_field f1;
    rand uvm_reg_field f2;

    // Function : new
    function new(string name = "block1_reggroup1_reg2");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f2 = uvm_reg_field::type_id::create("f2");

        this.f1.configure(this, 16,  0, "RW", 0, 'd0, 1, 1, 0);
        this.f2.configure(this, 16,  16, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block1_reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block1_reg1
`define CLASS_block1_reg1
class block1_reg1 extends uvm_reg;
    `uvm_object_utils(block1_reg1)

    rand uvm_reg_field f1;
    rand uvm_reg_field f2;

    // Function : new
    function new(string name = "block1_reg1");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f2 = uvm_reg_field::type_id::create("f2");

        this.f1.configure(this, 16,  0, "RO", 0, 'd0, 1, 1, 0);
        this.f2.configure(this, 16,  16, "RO", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block1_reggroup1
-----------------------------------------------------------------------*/
`ifndef CLASS_block1_reggroup1
`define CLASS_block1_reggroup1
class block1_reggroup1 extends uvm_reg_file;
    `uvm_object_utils(block1_reggroup1)

    rand block1_reggroup1_reg1 reg1;

    rand block1_reggroup1_reg2 reg2;

    // Function : new
    function new(string name = "block1_reggroup1");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        reg1   =   block1_reggroup1_reg1::type_id::create("reg1");
        reg2   =   block1_reggroup1_reg2::type_id::create("reg2");

        //config
        reg1.configure(get_block(), this, "reg1");
        reg2.configure(get_block(), this, "reg2");

        //build
        reg1.build();
        reg2.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg( reg1, offset +  'h0, "RW");
        mp.add_reg( reg2, offset +  'h4, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        reg1.set_offset(mp, offset +  'h0);
        reg2.set_offset(mp, offset +  'h4);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class      : block1_block
-----------------------------------------------------------------------*/
`ifndef CLASS_block1_block
`define CLASS_block1_block
class block1_block extends uvm_reg_block;
    `uvm_object_utils(block1_block)

    rand block1_reg1 reg1;

    rand block1_reggroup1 reggroup1;
    rand block1_block1 block2;

    // Function : new
    function new(string name = "block1_block");
        super.new(name, UVM_NO_COVERAGE);
    endfunction

    // Function : build
    virtual function void build();
        //REG1
        reg1   =   block1_reg1::type_id::create("reg1");
        reg1.configure(this, null, "reg1");
        reg1.build();

        //REGGROUP1
        reggroup1   =   block1_reggroup1::type_id::create("reggroup1");
        reggroup1.configure(this, null, "reggroup1");
        reggroup1.build();

        //BLOCK2
        block2   =   block1_block1::type_id::create("block2");
        block2.configure(this, "block2");
        block2.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'h1B8, 4, UVM_LITTLE_ENDIAN, 1);
        default_map.add_reg( reg1, 'h8, "RW");
        reggroup1.map( default_map, 'h0);
        default_map.add_submap( block2.default_map, 'hC);

        lock_model();
    endfunction

endclass : block1_block
`endif

/*----------------------------------------------------------------------
Class       : block3_reggroup1_reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block3_reggroup1_reg1
`define CLASS_block3_reggroup1_reg1
class block3_reggroup1_reg1 extends uvm_reg;
    `uvm_object_utils(block3_reggroup1_reg1)

    rand uvm_reg_field f1;
    rand uvm_reg_field f2;

    // Function : new
    function new(string name = "block3_reggroup1_reg1");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f2 = uvm_reg_field::type_id::create("f2");

        this.f1.configure(this, 16,  0, "RO", 0, 'd0, 1, 1, 0);
        this.f2.configure(this, 16,  16, "RO", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block3_reggroup1_reg2
-----------------------------------------------------------------------*/

`ifndef CLASS_block3_reggroup1_reg2
`define CLASS_block3_reggroup1_reg2
class block3_reggroup1_reg2 extends uvm_reg;
    `uvm_object_utils(block3_reggroup1_reg2)

    rand uvm_reg_field f1;
    rand uvm_reg_field f2;

    // Function : new
    function new(string name = "block3_reggroup1_reg2");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f2 = uvm_reg_field::type_id::create("f2");

        this.f1.configure(this, 16,  0, "RO", 0, 'd0, 1, 1, 0);
        this.f2.configure(this, 16,  16, "RO", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block3_reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block3_reg1
`define CLASS_block3_reg1
class block3_reg1 extends uvm_reg;
    `uvm_object_utils(block3_reg1)

    rand uvm_reg_field f1;
    rand uvm_reg_field f2;

    // Function : new
    function new(string name = "block3_reg1");
        super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
        add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f2 = uvm_reg_field::type_id::create("f2");

        this.f1.configure(this, 16,  0, "RO", 0, 'd0, 1, 1, 0);
        this.f2.configure(this, 16,  16, "RO", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block3_reggroup1
-----------------------------------------------------------------------*/
`ifndef CLASS_block3_reggroup1
`define CLASS_block3_reggroup1
class block3_reggroup1 extends uvm_reg_file;
    `uvm_object_utils(block3_reggroup1)

    rand block3_reggroup1_reg1 reg1;

    rand block3_reggroup1_reg2 reg2;

    // Function : new
    function new(string name = "block3_reggroup1");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        reg1   =   block3_reggroup1_reg1::type_id::create("reg1");
        reg2   =   block3_reggroup1_reg2::type_id::create("reg2");

        //config
        reg1.configure(get_block(), this, "reg1");
        reg2.configure(get_block(), this, "reg2");

        //build
        reg1.build();
        reg2.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg( reg1, offset +  'h0, "RW");
        mp.add_reg( reg2, offset +  'h4, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        reg1.set_offset(mp, offset +  'h0);
        reg2.set_offset(mp, offset +  'h4);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class      : block3_block
-----------------------------------------------------------------------*/
`ifndef CLASS_block3_block
`define CLASS_block3_block
class block3_block extends uvm_reg_block;
    `uvm_object_utils(block3_block)

    rand block3_reg1 reg1;

    rand block3_reggroup1 reggroup1;

    // Function : new
    function new(string name = "block3_block");
        super.new(name, UVM_NO_COVERAGE);
    endfunction

    // Function : build
    virtual function void build();
        //REG1
        reg1   =   block3_reg1::type_id::create("reg1");
        reg1.configure(this, null, "reg1");
        reg1.build();

        //REGGROUP1
        reggroup1   =   block3_reggroup1::type_id::create("reggroup1");
        reggroup1.configure(this, null, "reggroup1");
        reggroup1.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'h1D0, 4, UVM_LITTLE_ENDIAN, 1);
        default_map.add_reg( reg1, 'h8, "RW");
        reggroup1.map( default_map, 'h0);

        lock_model();
    endfunction

endclass : block3_block
`endif

/*----------------------------------------------------------------------
Class      : chip1_block
-----------------------------------------------------------------------*/
`ifndef CLASS_chip1_block
`define CLASS_chip1_block
class chip1_block extends uvm_reg_block;
    `uvm_object_utils(chip1_block)

    rand block4_block block4[10];

    rand block1_block block1;

    rand block3_block block3;

    // Function : new
    function new(string name = "chip1_block");
        super.new(name, UVM_NO_COVERAGE);
    endfunction

    // Function : build
    virtual function void build();
        //BLOCK4
        foreach (block4[block4_i])
        begin
            block4[block4_i] = block4_block::type_id::create($sformatf("block4[%0x]", block4_i));
            block4[block4_i].configure(this, $sformatf("block4[%0x]", block4_i));

            block4[block4_i].build();
        end

        //BLOCK1
        block1   =   block1_block::type_id::create("block1");
        block1.configure(this, "block1");
        block1.build();

        //BLOCK3
        block3   =   block3_block::type_id::create("block3");
        block3.configure(this, "block3");
        block3.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
        foreach (block4[block4_i])
        begin
            default_map.add_submap(block4[block4_i].default_map, 'h0 + block4_i * 'h2C);
        end

        default_map.add_submap( block1.default_map, 'h1B8);
        default_map.add_submap( block3.default_map, 'h1D0);

        lock_model();
    endfunction

endclass : chip1_block
`endif
