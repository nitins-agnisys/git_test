//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Admin
// generated from    : C:\Users\Admin\Documents\GitHub\git_test\Allegro_test\case1\Book1.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AXI
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

module chip1_ids(
    block4_idsreg1_f1_in,
    block4_idsreg1_f1_in_enb,
    block4_idsreg1_f1_r,
    block4_idsreg1_f2_in,
    block4_idsreg1_f2_in_enb,
    block4_idsreg1_f2_r,
    block4_idsreggroup1_wr_req_in,
    block4_idsreggroup1_rd_ack_in,
    block4_idsreggroup1_rd_data_in,
    block4_idsreggroup1_wr_valid_out,
    block4_idsreggroup1_rd_valid_out,
    
    block4_idsraddress_out,
    block4_idsaddress_out,
    block4_idswr_data_out,
    block1_idsreg1_f1_in,
    block1_idsreg1_f1_in_enb,
    block1_idsreg1_f1_r,
    block1_idsreg1_f2_in,
    block1_idsreg1_f2_in_enb,
    block1_idsreg1_f2_r,
    block1_idsreggroup1_reg1_enb,
    block1_idsreggroup1_reg1_f1_in,
    block1_idsreggroup1_reg1_f1_in_enb,
    block1_idsreggroup1_reg1_f1_r,
    block1_idsreggroup1_reg1_f2_in,
    block1_idsreggroup1_reg1_f2_in_enb,
    block1_idsreggroup1_reg1_f2_r,
    block1_idsreggroup1_reg2_enb,
    block1_idsreggroup1_reg2_f1_in,
    block1_idsreggroup1_reg2_f1_in_enb,
    block1_idsreggroup1_reg2_f1_r,
    block1_idsreggroup1_reg2_f2_in,
    block1_idsreggroup1_reg2_f2_in_enb,
    block1_idsreggroup1_reg2_f2_r,
    block1_idsblock2_reg1_f1_in,
    block1_idsblock2_reg1_f1_in_enb,
    block1_idsblock2_reg1_f1_r,
    block1_idsblock2_reg1_f2_in,
    block1_idsblock2_reg1_f2_in_enb,
    block1_idsblock2_reg1_f2_r,
    block1_idsblock2_block2_reggroup1_reg1_enb,
    block1_idsblock2_block2_reggroup1_reg1_f1_in,
    block1_idsblock2_block2_reggroup1_reg1_f1_in_enb,
    block1_idsblock2_block2_reggroup1_reg1_f1_r,
    block1_idsblock2_block2_reggroup1_reg1_f2_in,
    block1_idsblock2_block2_reggroup1_reg1_f2_in_enb,
    block1_idsblock2_block2_reggroup1_reg1_f2_r,
    block1_idsblock2_block2_reggroup1_reg2_enb,
    block1_idsblock2_block2_reggroup1_reg2_f1_in,
    block1_idsblock2_block2_reggroup1_reg2_f1_in_enb,
    block1_idsblock2_block2_reggroup1_reg2_f1_r,
    block1_idsblock2_block2_reggroup1_reg2_f2_in,
    block1_idsblock2_block2_reggroup1_reg2_f2_in_enb,
    block1_idsblock2_block2_reggroup1_reg2_f2_r,
    
    block3_idsreg1_f1_in,
    block3_idsreg1_f1_in_enb,
    block3_idsreg1_f1_r,
    block3_idsreg1_f2_in,
    block3_idsreg1_f2_in_enb,
    block3_idsreg1_f2_r,
    block3_idsreggroup1_reg1_f1_in,
    block3_idsreggroup1_reg1_f1_in_enb,
    block3_idsreggroup1_reg1_f1_r,
    block3_idsreggroup1_reg1_f2_in,
    block3_idsreggroup1_reg1_f2_in_enb,
    block3_idsreggroup1_reg1_f2_r,
    block3_idsreggroup1_reg2_f1_in,
    block3_idsreggroup1_reg2_f1_in_enb,
    block3_idsreggroup1_reg2_f1_r,
    block3_idsreggroup1_reg2_f2_in,
    block3_idsreggroup1_reg2_f2_in_enb,
    block3_idsreggroup1_reg2_f2_r,
    
    
    //AXI signals
    
    aclk,    // Bus clock
    aresetn,    // Reset
    awaddr,    // Write address
    awvalid,    // Write address valid : This signal indicates that write address is valid
    awready,    // Write address ready : This signal indicates that the slave is ready to accept an address
    awprot,    // Write Protection Type
    wdata,    // Write data
    wvalid,    // Write valid         : This signal indicates that valid write data and strobes are available
    wready,    // Write ready         : This signal indicates that the slave can accept the write data
    wstrb,    // Write Strobes
    bresp,    // Write Response
    bready,    // Response Ready
    bvalid,    // Response valid
    araddr,    // Read  address
    arvalid,    // Read address valid  : This signal indicates that the read address is valid and will remain stable until ARREADY is high
    arready,    // Read address ready  : This signal indicates that the slave is ready to accept an address
    arprot,    // Read Protection Type
    rdata,    // Read data
    rvalid,    // Read valid          : This signal indicates that the required read data is available and the read transfer can complete
    rready,    // Read ready          : This signal indicates that the master can accept the read data
    rresp    // Read Response
    
    );
    
    
    
    parameter block4_count = 10;
    
    parameter block4_ids_offset = 'h0;
    
    parameter block1_ids_offset = 'h1B8;
    
    parameter block3_ids_offset = 'h1D0;
    parameter addr_width  = 9;
    parameter bus_width   = 32;
    
    //AXI signals
    input aclk;
    input aresetn;
    input [addr_width-1 : 0] awaddr;
    input awvalid;
    output  wand awready;
    input [2 : 0] awprot;
    input [bus_width-1 : 0] wdata;
    input wvalid;
    output  wand wready;
    input [bus_width/8-1 : 0] wstrb;
    output  wor [1 : 0] bresp;
    input bready;
    output  wor bvalid;
    input [addr_width-1 : 0] araddr;
    input arvalid;
    output  wand arready;
    input [2 : 0] arprot;
    output  wor [bus_width-1 : 0] rdata;
    output  wor rvalid;
    input rready;
    output  wor [1 : 0] rresp;
    wire [1:0]slave_bresp;
    
    wire [1:0]slave_rresp;
    
    
    output  wor  [ block4_count * addr_width-1:0] block4_idsraddress_out;
    
    output wor  [ block4_count * addr_width-1:0] block4_idsaddress_out;
    output wor  [ block4_count *  bus_width-1:0] block4_idswr_data_out;
    
    wire [ block4_count * addr_width-1:0] block4_ids_raddress_out;
    
    wire [ block4_count * addr_width-1:0] block4_ids_address_out;
    wire [ block4_count * bus_width-1:0] block4_ids_wr_data_out;
    
    wire [block4_count * bus_width-1:0] block4_ids_rdata;
    wire  [block4_count - 1: 0] block4_ids_rvalid;
    wire  [block4_count - 1: 0] block4_ids_awready;
    wire  [block4_count - 1: 0] block4_ids_wready;
    wire  [ 2 * block4_count - 1: 0] block4_ids_bresp;
    wire  [block4_count - 1: 0] block4_ids_bvalid;
    wire  [block4_count - 1: 0] block4_ids_arready;
    wire  [ 2 * block4_count - 1: 0] block4_ids_rresp;
    
    wire [bus_width-1:0] block1_ids_rdata;
    wire block1_ids_rvalid;
    wire block1_ids_awready;
    wire block1_ids_wready;
    wire  [1:0] block1_ids_bresp;
    wire block1_ids_bvalid;
    wire block1_ids_arready;
    wire  [1:0] block1_ids_rresp;
    
    wire [bus_width-1:0] block3_ids_rdata;
    wire block3_ids_rvalid;
    wire block3_ids_awready;
    wire block3_ids_wready;
    wire  [1:0] block3_ids_bresp;
    wire block3_ids_bvalid;
    wire block3_ids_arready;
    wire  [1:0] block3_ids_rresp;
    
    wire invalid_address_wr;
    wire invalid_address_rd;
    
    wire wr_error;
    wire rd_error;
    
    reg awvalid_ff;
    reg wvalid_ff;
    
    reg [1:0]rresp_ff;
    reg [1:0]bresp_ff;
    
    
    wire block4_ids_select_wr;
    wire block4_ids_select_rd;
    
    wire  [ block4_count - 1 : 0 ] block4_ids_wr_data_busy;
    wire  [ block4_count - 1 : 0 ] block4_ids_wr_addr_busy;
    wire  [ block4_count - 1 : 0 ] block4_ids_rd_busy;
    
    wire block1_ids_select_wr;
    wire block1_ids_select_rd;
    
    wire block1_ids_wr_data_busy;
    wire block1_ids_wr_addr_busy;
    wire block1_ids_rd_busy;
    
    wire block3_ids_select_wr;
    wire block3_ids_select_rd;
    
    wire block3_ids_wr_data_busy;
    wire block3_ids_wr_addr_busy;
    wire block3_ids_rd_busy;
    
    //block4_ids
    input  [block4_count * 16-1 : 0] block4_idsreg1_f1_in;
    input  [block4_count-1 : 0] block4_idsreg1_f1_in_enb;
    output [block4_count * 16-1 : 0] block4_idsreg1_f1_r;
    input  [block4_count * 16-1 : 0] block4_idsreg1_f2_in;
    input  [block4_count-1 : 0] block4_idsreg1_f2_in_enb;
    output [block4_count * 16-1 : 0] block4_idsreg1_f2_r;
    
    input  [ block4_count-1 : 0] block4_idsreggroup1_rd_ack_in;
    input   [block4_count * bus_width-1 : 0] block4_idsreggroup1_rd_data_in;
    output [ block4_count-1 : 0] block4_idsreggroup1_rd_valid_out;
    input  [ block4_count-1 : 0] block4_idsreggroup1_wr_req_in;
    output [ block4_count-1 : 0] block4_idsreggroup1_wr_valid_out;
    
    
    
    assign block4_ids_select_wr =( (awaddr >= block4_ids_offset ) && (awaddr <= block4_ids_offset + 'h1B7)) ? 1'b1 : 1'b0;
    
    assign block4_ids_select_rd =( (araddr >= block4_ids_offset ) && (araddr <= block4_ids_offset + 'h1B7)) ? 1'b1 : 1'b0;
    
    
    
    generate
        genvar  block4_i;
        for (block4_i =  0 ; block4_i < block4_count ; block4_i = block4_i + 1  )
        begin : block4_gen
            block4_ids #(.addr_width(addr_width),.block_offset( block4_ids_offset + block4_i * ( 'h1B8 / block4_count ))) block4_idsinst(
            .reg1_f1_in(block4_idsreg1_f1_in[16 *  (block4_i + 1 ) - 1 : block4_i * 16]),
            .reg1_f1_in_enb(block4_idsreg1_f1_in_enb[block4_i]),
            .reg1_f1_r(block4_idsreg1_f1_r[16 *  (block4_i + 1 ) - 1 : block4_i * 16]),
            .reg1_f2_in(block4_idsreg1_f2_in[16 *  (block4_i + 1 ) - 1 : block4_i * 16]),
            .reg1_f2_in_enb(block4_idsreg1_f2_in_enb[block4_i]),
            .reg1_f2_r(block4_idsreg1_f2_r[16 *  (block4_i + 1 ) - 1 : block4_i * 16]),
            .reggroup1_wr_req_in(block4_idsreggroup1_wr_req_in[block4_i]),
            .reggroup1_rd_ack_in(block4_idsreggroup1_rd_ack_in[block4_i]),
            .reggroup1_rd_data_in(block4_idsreggroup1_rd_data_in[bus_width *  (block4_i + 1 ) - 1 : bus_width * block4_i ]),
            .reggroup1_wr_valid_out(block4_idsreggroup1_wr_valid_out[block4_i]),
            .reggroup1_rd_valid_out(block4_idsreggroup1_rd_valid_out[block4_i]),
            
            .aclk(aclk),
            .aresetn(aresetn),
            .awaddr(awaddr),
            .awvalid(awvalid & ~block4_ids_wr_addr_busy[block4_i]   & ~(&bresp_ff & ~(bready & bvalid))),
            .awready(block4_ids_awready[block4_i]),
            .awprot(awprot),
            .wdata(wdata),
            .wvalid(wvalid & ~block4_ids_wr_data_busy[block4_i]   & ~(&bresp_ff & ~(bready & bvalid))),
            .wready(block4_ids_wready[block4_i]),
            .wstrb(wstrb),
            .bresp(block4_ids_bresp[2 * (block4_i + 1 ) - 1 :2 * block4_i]),
            .bready(bready),
            .bvalid(block4_ids_bvalid[block4_i]),
            .araddr(araddr),
            .arvalid(arvalid &  ~rd_error  & ~block4_ids_rd_busy[block4_i]  & ~(&rresp_ff & ~rready)),
            .arready(block4_ids_arready[block4_i]),
            .arprot(arprot),
            .rdata(block4_ids_rdata[bus_width * (block4_i + 1 ) - 1 :bus_width * block4_i]),
            .rvalid(block4_ids_rvalid[block4_i]),
            .rready(rready),
            .rresp(block4_ids_rresp[2 * (block4_i + 1 ) - 1 :2 * block4_i]),
            .raddress_out(block4_idsraddress_out[addr_width * (block4_i + 1 ) - 1 :addr_width * block4_i]),
            .address_out(block4_idsaddress_out[addr_width * (block4_i + 1 ) - 1 :addr_width * block4_i]),
            .wr_data_out(block4_idswr_data_out[bus_width * (block4_i + 1 ) - 1 :bus_width * block4_i]));
        end
    endgenerate
    
    //block1_ids
    input  [15 : 0] block1_idsreg1_f1_in;
    input   block1_idsreg1_f1_in_enb;
    output [15 : 0] block1_idsreg1_f1_r;
    input  [15 : 0] block1_idsreg1_f2_in;
    input   block1_idsreg1_f2_in_enb;
    output [15 : 0] block1_idsreg1_f2_r;
    
    
    output   block1_idsreggroup1_reg1_enb;
    input  [15 : 0] block1_idsreggroup1_reg1_f1_in;
    input   block1_idsreggroup1_reg1_f1_in_enb;
    output [15 : 0] block1_idsreggroup1_reg1_f1_r;
    input  [15 : 0] block1_idsreggroup1_reg1_f2_in;
    input   block1_idsreggroup1_reg1_f2_in_enb;
    output [15 : 0] block1_idsreggroup1_reg1_f2_r;
    
    output   block1_idsreggroup1_reg2_enb;
    input  [15 : 0] block1_idsreggroup1_reg2_f1_in;
    input   block1_idsreggroup1_reg2_f1_in_enb;
    output [15 : 0] block1_idsreggroup1_reg2_f1_r;
    input  [15 : 0] block1_idsreggroup1_reg2_f2_in;
    input   block1_idsreggroup1_reg2_f2_in_enb;
    output [15 : 0] block1_idsreggroup1_reg2_f2_r;
    
    
    input  [15 : 0] block1_idsblock2_reg1_f1_in;
    input   block1_idsblock2_reg1_f1_in_enb;
    output [15 : 0] block1_idsblock2_reg1_f1_r;
    input  [15 : 0] block1_idsblock2_reg1_f2_in;
    input   block1_idsblock2_reg1_f2_in_enb;
    output [15 : 0] block1_idsblock2_reg1_f2_r;
    
    
    output   block1_idsblock2_block2_reggroup1_reg1_enb;
    input  [15 : 0] block1_idsblock2_block2_reggroup1_reg1_f1_in;
    input   block1_idsblock2_block2_reggroup1_reg1_f1_in_enb;
    output [15 : 0] block1_idsblock2_block2_reggroup1_reg1_f1_r;
    input  [15 : 0] block1_idsblock2_block2_reggroup1_reg1_f2_in;
    input   block1_idsblock2_block2_reggroup1_reg1_f2_in_enb;
    output [15 : 0] block1_idsblock2_block2_reggroup1_reg1_f2_r;
    
    output   block1_idsblock2_block2_reggroup1_reg2_enb;
    input  [15 : 0] block1_idsblock2_block2_reggroup1_reg2_f1_in;
    input   block1_idsblock2_block2_reggroup1_reg2_f1_in_enb;
    output [15 : 0] block1_idsblock2_block2_reggroup1_reg2_f1_r;
    input  [15 : 0] block1_idsblock2_block2_reggroup1_reg2_f2_in;
    input   block1_idsblock2_block2_reggroup1_reg2_f2_in_enb;
    output [15 : 0] block1_idsblock2_block2_reggroup1_reg2_f2_r;
    
    
    
    
    assign block1_ids_select_wr =( (awaddr >= block1_ids_offset ) && (awaddr <= block1_ids_offset + 'h17)) ? 1'b1 : 1'b0;
    
    assign block1_ids_select_rd =( (araddr >= block1_ids_offset ) && (araddr <= block1_ids_offset + 'h17)) ? 1'b1 : 1'b0;
    
    
    block1_ids #(.addr_width(addr_width),.block_offset( block1_ids_offset)) block1_idsinst(
    .reg1_f1_in(block1_idsreg1_f1_in),
    .reg1_f1_in_enb(block1_idsreg1_f1_in_enb),
    .reg1_f1_r(block1_idsreg1_f1_r),
    .reg1_f2_in(block1_idsreg1_f2_in),
    .reg1_f2_in_enb(block1_idsreg1_f2_in_enb),
    .reg1_f2_r(block1_idsreg1_f2_r),
    .reggroup1_reg1_enb(block1_idsreggroup1_reg1_enb),
    .reggroup1_reg1_f1_in(block1_idsreggroup1_reg1_f1_in),
    .reggroup1_reg1_f1_in_enb(block1_idsreggroup1_reg1_f1_in_enb),
    .reggroup1_reg1_f1_r(block1_idsreggroup1_reg1_f1_r),
    .reggroup1_reg1_f2_in(block1_idsreggroup1_reg1_f2_in),
    .reggroup1_reg1_f2_in_enb(block1_idsreggroup1_reg1_f2_in_enb),
    .reggroup1_reg1_f2_r(block1_idsreggroup1_reg1_f2_r),
    .reggroup1_reg2_enb(block1_idsreggroup1_reg2_enb),
    .reggroup1_reg2_f1_in(block1_idsreggroup1_reg2_f1_in),
    .reggroup1_reg2_f1_in_enb(block1_idsreggroup1_reg2_f1_in_enb),
    .reggroup1_reg2_f1_r(block1_idsreggroup1_reg2_f1_r),
    .reggroup1_reg2_f2_in(block1_idsreggroup1_reg2_f2_in),
    .reggroup1_reg2_f2_in_enb(block1_idsreggroup1_reg2_f2_in_enb),
    .reggroup1_reg2_f2_r(block1_idsreggroup1_reg2_f2_r),
    .block2_reg1_f1_in(block1_idsblock2_reg1_f1_in),
    .block2_reg1_f1_in_enb(block1_idsblock2_reg1_f1_in_enb),
    .block2_reg1_f1_r(block1_idsblock2_reg1_f1_r),
    .block2_reg1_f2_in(block1_idsblock2_reg1_f2_in),
    .block2_reg1_f2_in_enb(block1_idsblock2_reg1_f2_in_enb),
    .block2_reg1_f2_r(block1_idsblock2_reg1_f2_r),
    .block2_block2_reggroup1_reg1_enb(block1_idsblock2_block2_reggroup1_reg1_enb),
    .block2_block2_reggroup1_reg1_f1_in(block1_idsblock2_block2_reggroup1_reg1_f1_in),
    .block2_block2_reggroup1_reg1_f1_in_enb(block1_idsblock2_block2_reggroup1_reg1_f1_in_enb),
    .block2_block2_reggroup1_reg1_f1_r(block1_idsblock2_block2_reggroup1_reg1_f1_r),
    .block2_block2_reggroup1_reg1_f2_in(block1_idsblock2_block2_reggroup1_reg1_f2_in),
    .block2_block2_reggroup1_reg1_f2_in_enb(block1_idsblock2_block2_reggroup1_reg1_f2_in_enb),
    .block2_block2_reggroup1_reg1_f2_r(block1_idsblock2_block2_reggroup1_reg1_f2_r),
    .block2_block2_reggroup1_reg2_enb(block1_idsblock2_block2_reggroup1_reg2_enb),
    .block2_block2_reggroup1_reg2_f1_in(block1_idsblock2_block2_reggroup1_reg2_f1_in),
    .block2_block2_reggroup1_reg2_f1_in_enb(block1_idsblock2_block2_reggroup1_reg2_f1_in_enb),
    .block2_block2_reggroup1_reg2_f1_r(block1_idsblock2_block2_reggroup1_reg2_f1_r),
    .block2_block2_reggroup1_reg2_f2_in(block1_idsblock2_block2_reggroup1_reg2_f2_in),
    .block2_block2_reggroup1_reg2_f2_in_enb(block1_idsblock2_block2_reggroup1_reg2_f2_in_enb),
    .block2_block2_reggroup1_reg2_f2_r(block1_idsblock2_block2_reggroup1_reg2_f2_r),
    
    .aclk(aclk),
    .aresetn(aresetn),
    .awaddr(awaddr),
    .awvalid(awvalid & ~block1_ids_wr_addr_busy  & ~(&bresp_ff & ~(bready & bvalid))),
    .awready(block1_ids_awready),
    .awprot(awprot),
    .wdata(wdata),
    .wvalid(wvalid & ~block1_ids_wr_data_busy  & ~(&bresp_ff & ~(bready & bvalid))),
    .wready(block1_ids_wready),
    .wstrb(wstrb),
    .bresp(block1_ids_bresp),
    .bready(bready),
    .bvalid(block1_ids_bvalid),
    .araddr(araddr),
    .arvalid(arvalid &  ~rd_error  & ~(& block4_ids_rd_busy )  & ~block3_ids_rd_busy  & ~(&rresp_ff & ~rready)),
    .arready(block1_ids_arready),
    .arprot(arprot),
    .rdata(block1_ids_rdata),
    .rvalid(block1_ids_rvalid),
    .rready(rready),
    .rresp(block1_ids_rresp));
    
    //block3_ids
    input  [15 : 0] block3_idsreg1_f1_in;
    input   block3_idsreg1_f1_in_enb;
    output [15 : 0] block3_idsreg1_f1_r;
    input  [15 : 0] block3_idsreg1_f2_in;
    input   block3_idsreg1_f2_in_enb;
    output [15 : 0] block3_idsreg1_f2_r;
    
    
    input  [15 : 0] block3_idsreggroup1_reg1_f1_in;
    input   block3_idsreggroup1_reg1_f1_in_enb;
    output [15 : 0] block3_idsreggroup1_reg1_f1_r;
    input  [15 : 0] block3_idsreggroup1_reg1_f2_in;
    input   block3_idsreggroup1_reg1_f2_in_enb;
    output [15 : 0] block3_idsreggroup1_reg1_f2_r;
    
    input  [15 : 0] block3_idsreggroup1_reg2_f1_in;
    input   block3_idsreggroup1_reg2_f1_in_enb;
    output [15 : 0] block3_idsreggroup1_reg2_f1_r;
    input  [15 : 0] block3_idsreggroup1_reg2_f2_in;
    input   block3_idsreggroup1_reg2_f2_in_enb;
    output [15 : 0] block3_idsreggroup1_reg2_f2_r;
    
    
    
    
    assign block3_ids_select_wr =( (awaddr >= block3_ids_offset ) && (awaddr <= block3_ids_offset + 'hB)) ? 1'b1 : 1'b0;
    
    assign block3_ids_select_rd =( (araddr >= block3_ids_offset ) && (araddr <= block3_ids_offset + 'hB)) ? 1'b1 : 1'b0;
    
    
    block3_ids #(.addr_width(addr_width),.block_offset( block3_ids_offset)) block3_idsinst(
    .reg1_f1_in(block3_idsreg1_f1_in),
    .reg1_f1_in_enb(block3_idsreg1_f1_in_enb),
    .reg1_f1_r(block3_idsreg1_f1_r),
    .reg1_f2_in(block3_idsreg1_f2_in),
    .reg1_f2_in_enb(block3_idsreg1_f2_in_enb),
    .reg1_f2_r(block3_idsreg1_f2_r),
    .reggroup1_reg1_f1_in(block3_idsreggroup1_reg1_f1_in),
    .reggroup1_reg1_f1_in_enb(block3_idsreggroup1_reg1_f1_in_enb),
    .reggroup1_reg1_f1_r(block3_idsreggroup1_reg1_f1_r),
    .reggroup1_reg1_f2_in(block3_idsreggroup1_reg1_f2_in),
    .reggroup1_reg1_f2_in_enb(block3_idsreggroup1_reg1_f2_in_enb),
    .reggroup1_reg1_f2_r(block3_idsreggroup1_reg1_f2_r),
    .reggroup1_reg2_f1_in(block3_idsreggroup1_reg2_f1_in),
    .reggroup1_reg2_f1_in_enb(block3_idsreggroup1_reg2_f1_in_enb),
    .reggroup1_reg2_f1_r(block3_idsreggroup1_reg2_f1_r),
    .reggroup1_reg2_f2_in(block3_idsreggroup1_reg2_f2_in),
    .reggroup1_reg2_f2_in_enb(block3_idsreggroup1_reg2_f2_in_enb),
    .reggroup1_reg2_f2_r(block3_idsreggroup1_reg2_f2_r),
    
    .aclk(aclk),
    .aresetn(aresetn),
    .awaddr(awaddr),
    .awvalid(awvalid & ~block3_ids_wr_addr_busy  & ~(&bresp_ff & ~(bready & bvalid))),
    .awready(block3_ids_awready),
    .awprot(awprot),
    .wdata(wdata),
    .wvalid(wvalid & ~block3_ids_wr_data_busy  & ~(&bresp_ff & ~(bready & bvalid))),
    .wready(block3_ids_wready),
    .wstrb(wstrb),
    .bresp(block3_ids_bresp),
    .bready(bready),
    .bvalid(block3_ids_bvalid),
    .araddr(araddr),
    .arvalid(arvalid &  ~rd_error  & ~(& block4_ids_rd_busy )  & ~block1_ids_rd_busy  & ~(&rresp_ff & ~rready)),
    .arready(block3_ids_arready),
    .arprot(arprot),
    .rdata(block3_ids_rdata),
    .rvalid(block3_ids_rvalid),
    .rready(rready),
    .rresp(block3_ids_rresp));
    
    
    assign invalid_address_wr = ~(block4_ids_select_wr | block1_ids_select_wr | block3_ids_select_wr) ;
    assign invalid_address_rd = ~(block4_ids_select_rd | block1_ids_select_rd | block3_ids_select_rd) ;
    
    generate
        genvar block4_busy_i;
        for (block4_busy_i = 0 ; block4_busy_i < block4_count ; block4_busy_i = block4_busy_i + 1 )
        begin : block4_busy_gen
        if(block4_busy_i == 0)
            begin
                assign block4_ids_wr_data_busy[block4_busy_i] = (block1_ids_awready == 1'b0 || block3_ids_awready == 1'b0 || (& block4_ids_awready[ block4_count - 1 : 1]) == 1'b0 || block4_ids_wready[block4_busy_i] == 1'b0) ? 1'b1 : 1'b0;
                assign block4_ids_wr_addr_busy[block4_busy_i] = (block1_ids_awready == 1'b0 || block3_ids_awready == 1'b0 || (& block4_ids_awready[ block4_count - 1 : 1]) == 1'b0) ? 1'b1 : 1'b0;
                assign block4_ids_rd_busy[block4_busy_i] = (block1_ids_arready == 1'b0 || block3_ids_arready == 1'b0 || (& block4_ids_arready[ block4_count - 1 : 1]) == 1'b0) ? 1'b1 : 1'b0;
            end
        else if(block4_busy_i == (block4_count - 1 ))
            begin
                assign block4_ids_wr_data_busy[block4_busy_i] = (block1_ids_awready == 1'b0 || block3_ids_awready == 1'b0 || (& block4_ids_awready[ block4_busy_i - 1 : 0]) == 1'b0 || block4_ids_wready[block4_busy_i] == 1'b0) ? 1'b1 : 1'b0;
                assign block4_ids_wr_addr_busy[block4_busy_i] = (block1_ids_awready == 1'b0 || block3_ids_awready == 1'b0 || (& block4_ids_awready[ block4_busy_i - 1 : 0]) == 1'b0) ? 1'b1 : 1'b0;
                assign block4_ids_rd_busy[block4_busy_i] = (block1_ids_arready == 1'b0 || block3_ids_arready == 1'b0 || (& block4_ids_arready[ block4_count - 1 : 1]) == 1'b0) ? 1'b1 : 1'b0;
            end
        else
            begin
                assign block4_ids_wr_data_busy[block4_busy_i] = (block1_ids_awready == 1'b0 || block3_ids_awready == 1'b0 || (& block4_ids_awready[ block4_busy_i - 1 : 0]) == 1'b0 || (& block4_ids_awready[ block4_count - 1 : block4_busy_i + 1 ]) == 1'b0 || block4_ids_wready[block4_busy_i] == 1'b0) ? 1'b1 : 1'b0;
                assign block4_ids_wr_addr_busy[block4_busy_i] = (block1_ids_awready == 1'b0 || block3_ids_awready == 1'b0 || (& block4_ids_awready[ block4_busy_i - 1 : 0]) == 1'b0 || (& block4_ids_awready[ block4_count - 1 : block4_busy_i + 1 ]) == 1'b0) ? 1'b1 : 1'b0;
                assign block4_ids_rd_busy[block4_busy_i] = (block1_ids_arready == 1'b0 || block3_ids_arready == 1'b0 || (& block4_ids_arready[ block4_busy_i - 1 : 0]) == 1'b0 || (& block4_ids_awready[ block4_count - 1 : block4_busy_i + 1 ]) == 1'b0) ? 1'b1 : 1'b0;
            end
        end
    endgenerate
    
    assign block1_ids_wr_data_busy = ((& block4_ids_awready) == 1'b0 || block3_ids_awready == 1'b0 || block1_ids_wready == 1'b0) ? 1'b1 : 1'b0;
    assign block1_ids_wr_addr_busy = ((& block4_ids_awready) == 1'b0 || block3_ids_awready == 1'b0) ? 1'b1 : 1'b0;
    assign block1_ids_rd_busy      = (block1_ids_arready == 1'b0) ? 1'b1 : 1'b0;
    
    assign block3_ids_wr_data_busy = ((& block4_ids_awready) == 1'b0 || block1_ids_awready == 1'b0 || block3_ids_wready == 1'b0) ? 1'b1 : 1'b0;
    assign block3_ids_wr_addr_busy = ((& block4_ids_awready) == 1'b0 || block1_ids_awready == 1'b0) ? 1'b1 : 1'b0;
    assign block3_ids_rd_busy      = (block3_ids_arready == 1'b0) ? 1'b1 : 1'b0;
    
    
    
    
    
    
    assign wr_error = (invalid_address_wr && awvalid == 1'b1 && awready == 1'b1) ;
    assign rd_error = (invalid_address_rd && arvalid == 1'b1 && arready == 1'b1) ;
    
    
    always @(posedge aclk)
        begin
        if (!aresetn)
            begin
                bresp_ff    <= 2'b00 ;
                rresp_ff    <= 2'b00 ;
                awvalid_ff  <= 1'b0  ;
                wvalid_ff   <= 1'b0  ;
            end
        else
            begin
                awvalid_ff  <= (awvalid_ff & ~(awvalid & awready)) ?  ~(bvalid & bready) :  (awvalid & awready) ;
                wvalid_ff   <= (wvalid_ff & ~(wvalid & wready)) ?   ~(bvalid & bready) :  (wvalid & wready) ;
                rresp_ff    <= (rresp_ff == 2'b11 && rd_error  == 1'b0) ? {2{~rready}} : {2{rd_error}};
                
            if(awvalid_ff && &bresp_ff)
                begin
                    bresp_ff  <= (wr_error  == 1'b0  && wvalid_ff == 1'b1) ? {2{~bready}} : bresp_ff;
                end
            else
                begin
                    bresp_ff  <= (bresp_ff == 2'b11 && wr_error  == 1'b0) ? {2{~bready}} : {2{wr_error & ((awvalid & awready) | awvalid_ff)}};
                end
            end
    end // always clk
    
    
    generate
        genvar block4_default_map_itr;
        for (block4_default_map_itr = 0 ; block4_default_map_itr < block4_count ; block4_default_map_itr = block4_default_map_itr + 1 )
        begin : block4_default_map_rdata_gen
            assign rdata = block4_ids_rdata[ bus_width * (block4_default_map_itr + 1) - 1 : bus_width * block4_default_map_itr];
        end
    endgenerate
    
    assign rdata = block1_ids_rdata | block3_ids_rdata;
    assign rvalid =  &rresp_ff |  (  |  block4_ids_rvalid )  |  (  block1_ids_rvalid )  |  (  block3_ids_rvalid ) ;
    assign awready =   &bresp_ff ?  (wvalid_ff & bready) : ( (  &  block4_ids_awready )  &  (  block1_ids_awready )  &  (  block3_ids_awready ) );
    assign wready =   (&bresp_ff &  wvalid_ff) ? bready : ( (  &  block4_ids_wready )  &  (  block1_ids_wready )  &  (  block3_ids_wready ) );
    generate
        genvar block4_default_map_itr_bresp;
        for (block4_default_map_itr_bresp = 0 ; block4_default_map_itr_bresp < block4_count ; block4_default_map_itr_bresp = block4_default_map_itr_bresp + 1 )
        begin : block4_default_map_bresp_gen
            assign bresp = block4_ids_bresp[ 2 * (block4_default_map_itr_bresp + 1) - 1 : 2 * block4_default_map_itr_bresp];
        end
    endgenerate
    
    assign bresp = (bresp_ff &  {2{wvalid_ff & awvalid_ff}})  | block1_ids_bresp | block3_ids_bresp;
    assign bvalid =  (&bresp_ff & (wvalid_ff & awvalid_ff)) |  (  |  block4_ids_bvalid )  |  (  block1_ids_bvalid )  |  (  block3_ids_bvalid ) ;
    assign arready =   (  &  block4_ids_arready )  &  (  block1_ids_arready )  &  (  block3_ids_arready ) ;
    generate
        genvar block4_default_map_itr_rresp;
        for (block4_default_map_itr_rresp = 0 ; block4_default_map_itr_rresp < block4_count ; block4_default_map_itr_rresp = block4_default_map_itr_rresp + 1 )
        begin : block4_default_map_rresp_gen
            assign rresp = block4_ids_rresp[ 2 * (block4_default_map_itr_rresp + 1) - 1 : 2 * block4_default_map_itr_rresp];
        end
    endgenerate
    
    assign rresp = rresp_ff  | block1_ids_rresp | block3_ids_rresp;
endmodule

//------------------------------------------------
//  BLOCK : BLOCK4 MODULE
//

module block4_ids(
    
    // REGISTER : REG1 PORT SIGNAL
    reg1_f1_in,
    reg1_f1_in_enb,
    reg1_f1_r,
    
    reg1_f2_in,
    reg1_f2_in_enb,
    reg1_f2_r,
    
    
    // SECTION(EXTERNAL) : REGGROUP1 PORT SIGNAL
    reggroup1_rd_ack_in,
    reggroup1_rd_data_in,
    reggroup1_rd_valid_out,
    reggroup1_wr_req_in,
    reggroup1_wr_valid_out,
    
    
    
    raddress_out,
    address_out,
    wr_data_out,
    
    //AXI signals
    aclk,   // Bus clock
    aresetn,   // Reset
    awaddr,   // Write address
    awvalid,   // Write address valid : This signal indicates that write address is valid
    awready,   // Write address ready : This signal indicates that the slave is ready to accept an address
    awprot,   // Write Protection Type
    wdata,   // Write data
    wvalid,   // Write valid         : This signal indicates that valid write data and strobes are available
    wready,   // Write ready         : This signal indicates that the slave can accept the write data
    wstrb,   // Write Strobes
    bresp,   // Write Response
    bready,   // Response Ready
    bvalid,   // Response valid
    araddr,   // Read  address
    arvalid,   // Read address valid  : This signal indicates that the read address is valid and will remain stable until ARREADY is high
    arready,   // Read address ready  : This signal indicates that the slave is ready to accept an address
    arprot,   // Read Protection Type
    rdata,   // Read data
    rvalid,   // Read valid          : This signal indicates that the required read data is available and the read transfer can complete
    rready,   // Read ready          : This signal indicates that the master can accept the read data
    rresp   // Read Response
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 9;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REGGROUP1
    parameter reggroup1_count         = 10;
    parameter reggroup1_address_width = addr_width - 6;
    
    
    parameter block4_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : REG1 SIGNALS
    
    
    wire    reg1_decode;         // Write DECODE
    wire    reg1_rdecode;        // Read  DECODE
    wire    reg1_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reg1_rd_data;          // READ DATA
    wire    [64-1 : 0] reg1_offset;  // OFFSET
    wire    reg1_write_error;          // ERROR SIGNAL
    wor     reg1_write_error_wor;
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reg1_f1_in_enb ;      // FIELD : F1
    input   reg1_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reg1_f1_q ;      // FIELD : F1
    reg [15 : 0] reg1_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reg1_f1_r ;      // FIELD : F1
    output  [15 : 0] reg1_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reg1_f1_in ;      // FIELD : F1
    input   [15 : 0] reg1_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : REGGROUP1 SIGNALS
    input   reggroup1_rd_ack_in;
    input  [bus_width-1 : 0] reggroup1_rd_data_in;
    output  reggroup1_rd_valid_out;
    input   reggroup1_wr_req_in;
    output  reggroup1_wr_valid_out;
    wire    reggroup1_decode;
    wire    reggroup1_rdecode;
    wire    [64-1 : 0] reggroup1_offset;
    wire     reggroup1_rd_valid;
    wire     reggroup1_wr_valid;
    wor     reggroup1_wr_req_wor;
    wor     reggroup1_rd_ack_wor;
    wor     reggroup1_decode_wor;
    
    wire    [bus_width-1 : 0] reggroup1_rd_data;
    wire    reggroup1_write_error;
    wor     reggroup1_write_error_wor;
    
    //-----------------------------------------------------
    
    
    output [addr_width-1:0] raddress_out;
    
    output [addr_width-1:0] address_out;
    output [bus_width-1:0] wr_data_out;
    wire  [bus_width-1:0] int_rd_data;
    wire  [bus_width-1:0] ext_rd_data;
    wire external_rd_valid;
    reg  rd_wait_state;
    wire external_rd_ack;
    wire external_wr_req;
    wire external_access;
    
    //AXI signals
    input aclk;
    input aresetn;
    input [addr_width-1 : 0] awaddr;
    input awvalid;
    output awready;
    input [2 : 0] awprot;
    wire  [2 : 0] awprot_i;
    input [bus_width-1 : 0] wdata;
    input wvalid;
    output wready;
    input [bus_width/8-1 : 0] wstrb;
    output [1 : 0] bresp;
    input bready;
    output bvalid;
    input [addr_width-1 : 0] araddr;
    input arvalid;
    output arready;
    input [2 : 0] arprot;
    wire  [2 : 0] arprot_i;
    output [bus_width-1 : 0] rdata;
    output rvalid;
    input rready;
    output [1 : 0] rresp;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire [addr_width-1 : 0] raddress;
    wire  wr_error;
    wire  rd_error;
    wire  wr_decode_error;
    wire  rd_decode_error;
    wire  wr_slave_select;
    wire  rd_slave_select;
    wire  [addr_width-1:0] slvwaddr;
    wire  [addr_width-1:0] slvraddr;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    axi_widget #(.addr_width(addr_width), .bus_width(bus_width)) axi(
            .aclk(aclk),
            .aresetn(aresetn),
            .awaddr(awaddr),
            .awvalid(awvalid),
            .awready(awready),
            .awprot(awprot),
            .awprot_i(awprot_i),
            .wdata(wdata),
            .wvalid(wvalid),
            .wready(wready),
            .wstrb(wstrb),
            .bresp(bresp),
            .bready(bready),
            .bvalid(bvalid),
            .araddr(araddr),
            .arvalid(arvalid),
            .arready(arready),
            .arprot(arprot),
            .arprot_i(arprot_i),
            .rdata(rdata),
            .rvalid(rvalid),
            .rready(rready),
            .rresp(rresp),
            .clk(clk),
            .reset_l(reset_l),
            .request(request),
            .wr_stb(wr_stb),
            .wr_decode_error(wr_decode_error),
            .rd_decode_error(rd_decode_error),
            .wr_slave_select(wr_slave_select),
            .rd_slave_select(rd_slave_select),
            .slvwaddr(slvwaddr),
            .slvraddr(slvraddr),
            .rd_stb(rd_stb),
            .rd_wait(rd_wait),
            .wr_error(wr_error),
            .rd_error(rd_error),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .raddress(raddress),
            .rd_data_vld(rd_data_vld),
            .byte_enb(byte_enb));
    //end widget
    
    assign raddress_out = raddress;
    assign address_out = address;
    assign wr_data_out = wr_data;
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG1
    // ADDRESS       :  block_offset+'h28                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-only HW : Read-Write )
    //    31:16 : f2  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign reg1_rd_valid = reg1_rdecode && rd_stb;
    assign reg1_offset = block_offset+'h28;
    assign reg1_decode  = (address[block4_address_width-1 : 0]    == reg1_offset[block4_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reg1_rdecode = (raddress[block4_address_width-1 : 0]   == reg1_offset[block4_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg1_f1_q  <= 16'd0;
            end
        else
            begin
            if (reg1_f1_in_enb)   // F1 : HW Write
                begin
                    reg1_f1_q <= reg1_f1_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg1_f2_q  <= 16'd0;
            end
        else
            begin
            if (reg1_f2_in_enb)   // F2 : HW Write
                begin
                    reg1_f2_q <= reg1_f2_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg1_f1_r  =  reg1_f1_q ;    // Field : F1
    assign reg1_f2_r  =  reg1_f2_q ;    // Field : F2
    
    
    assign reg1_rd_data = reg1_rd_valid ? {reg1_f2_q , reg1_f1_q} : 32'b00000000000000000000000000000000;
    assign reg1_write_error = reg1_decode && wr_stb;
    assign reg1_write_error_wor = reg1_write_error;
    
    
    assign reggroup1_offset       = (block_offset/'h40) +'h0;
    assign reggroup1_decode       = ((address[addr_width - 1 : 0] >= block_offset +  'h0) && (address[addr_width - 1 : 0] <= block_offset +  'h27)) ? 1'b1 : 1'b0;
    assign reggroup1_rdecode       = ((raddress[addr_width - 1 : 0] >=block_offset +  'h0) && (raddress[addr_width - 1 : 0] <=block_offset +  'h27)) ? 1'b1 : 1'b0;
    assign reggroup1_wr_valid     = reggroup1_decode &&  wr_stb;
    assign reggroup1_rd_valid     = reggroup1_rdecode && rd_stb && rd_wait_state;
    assign reggroup1_wr_valid_out = reggroup1_wr_valid;
    assign reggroup1_rd_valid_out = reggroup1_rd_valid;
    assign reggroup1_decode_wor   = reggroup1_rdecode;
    
    assign reggroup1_wr_req_wor   = reggroup1_wr_req_in;
    assign reggroup1_rd_ack_wor   = reggroup1_rd_ack_in;
    
    assign reggroup1_rd_data      = reggroup1_rd_ack_in ? reggroup1_rd_data_in : 32'b00000000000000000000000000000000;
    assign reggroup1_write_error  = reggroup1_decode && wr_stb;
    assign reggroup1_write_error_wor  = reggroup1_write_error;
    
    
    
    
    
    assign rd_data = int_rd_data | ext_rd_data ;
    
    assign int_rd_data = (~external_access)? ( reg1_rd_data) : {bus_width{1'b0}};
    
    assign ext_rd_data = (external_rd_ack == 1'b1)? ( reggroup1_rd_data ): {bus_width{1'b0}} ;
    
    
    
    
    assign wr_error = reg1_write_error_wor |
    reggroup1_write_error_wor;
    
    assign rd_error = 0;
    
    assign wr_decode_error = 0;
    
    assign rd_decode_error = 0;
    
    assign external_rd_valid = reggroup1_rd_valid;
    // END external_rd_valid
    
    assign external_rd_ack = reggroup1_rd_ack_wor;
    // END external_rd_ack
    
    assign external_wr_req = reggroup1_wr_req_wor;
    // END external_wr_req
    
    assign external_access = (reggroup1_decode_wor) & rd_stb;
    // END external_access
    
    always @(posedge clk)
        begin
        if ( !reset_l )
            begin
                rd_wait_state <= 1'b1;
            end
        else
            begin
                case(rd_wait_state)
                    1'b1:
                    begin
                    if (external_rd_valid == 1'b1 && external_rd_ack == 1'b0 )
                        begin
                            rd_wait_state <= 1'b0;
                        end
                    end
                    1'b0:
                    begin
                    if (external_rd_ack == 1'b1)
                        begin
                            rd_wait_state <= 1'b1;
                        end
                    end
                endcase
            end
    end // always END
    
    
    assign request     = external_wr_req;
    assign rd_data_vld = external_rd_ack |(~external_access & rd_stb & rd_wait_state);
    assign rd_wait     = external_rd_valid ? external_rd_ack : ( rd_data_vld | rd_wait_state);
    
    assign wr_slave_select = ((slvwaddr[addr_width - 1 : 0]  >= block_offset) && (slvwaddr[addr_width - 1 : 0]  <= block_offset + 'h2B)) ? 1'b1 : 1'b0;
    assign rd_slave_select = ((slvraddr[addr_width - 1 : 0]  >= block_offset) && (slvraddr[addr_width - 1 : 0]  <= block_offset + 'h2B)) ? 1'b1 : 1'b0;
    
endmodule

//------------------------------------------------
//  BLOCK : BLOCK1 MODULE
//

module block1_ids(
    
    // REGISTER : REG1 PORT SIGNAL
    reg1_f1_in,
    reg1_f1_in_enb,
    reg1_f1_r,
    
    reg1_f2_in,
    reg1_f2_in_enb,
    reg1_f2_r,
    
    
    // REGISTER : REG1 PORT SIGNAL
    reggroup1_reg1_enb,
    reggroup1_reg1_f1_in,
    reggroup1_reg1_f1_in_enb,
    reggroup1_reg1_f1_r,
    
    reggroup1_reg1_f2_in,
    reggroup1_reg1_f2_in_enb,
    reggroup1_reg1_f2_r,
    
    
    // REGISTER : REG2 PORT SIGNAL
    reggroup1_reg2_enb,
    reggroup1_reg2_f1_in,
    reggroup1_reg2_f1_in_enb,
    reggroup1_reg2_f1_r,
    
    reggroup1_reg2_f2_in,
    reggroup1_reg2_f2_in_enb,
    reggroup1_reg2_f2_r,
    
    
    // REGISTER : REG1 PORT SIGNAL
    block2_reg1_f1_in,
    block2_reg1_f1_in_enb,
    block2_reg1_f1_r,
    
    block2_reg1_f2_in,
    block2_reg1_f2_in_enb,
    block2_reg1_f2_r,
    
    
    // REGISTER : REG1 PORT SIGNAL
    block2_block2_reggroup1_reg1_enb,
    block2_block2_reggroup1_reg1_f1_in,
    block2_block2_reggroup1_reg1_f1_in_enb,
    block2_block2_reggroup1_reg1_f1_r,
    
    block2_block2_reggroup1_reg1_f2_in,
    block2_block2_reggroup1_reg1_f2_in_enb,
    block2_block2_reggroup1_reg1_f2_r,
    
    
    // REGISTER : REG2 PORT SIGNAL
    block2_block2_reggroup1_reg2_enb,
    block2_block2_reggroup1_reg2_f1_in,
    block2_block2_reggroup1_reg2_f1_in_enb,
    block2_block2_reggroup1_reg2_f1_r,
    
    block2_block2_reggroup1_reg2_f2_in,
    block2_block2_reggroup1_reg2_f2_in_enb,
    block2_block2_reggroup1_reg2_f2_r,
    
    
    
    //AXI signals
    aclk,   // Bus clock
    aresetn,   // Reset
    awaddr,   // Write address
    awvalid,   // Write address valid : This signal indicates that write address is valid
    awready,   // Write address ready : This signal indicates that the slave is ready to accept an address
    awprot,   // Write Protection Type
    wdata,   // Write data
    wvalid,   // Write valid         : This signal indicates that valid write data and strobes are available
    wready,   // Write ready         : This signal indicates that the slave can accept the write data
    wstrb,   // Write Strobes
    bresp,   // Write Response
    bready,   // Response Ready
    bvalid,   // Response valid
    araddr,   // Read  address
    arvalid,   // Read address valid  : This signal indicates that the read address is valid and will remain stable until ARREADY is high
    arready,   // Read address ready  : This signal indicates that the slave is ready to accept an address
    arprot,   // Read Protection Type
    rdata,   // Read data
    rvalid,   // Read valid          : This signal indicates that the required read data is available and the read transfer can complete
    rready,   // Read ready          : This signal indicates that the master can accept the read data
    rresp   // Read Response
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 5;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REGGROUP1
    parameter reggroup1_count         = 1;
    parameter reggroup1_address_width = addr_width;
    
    // SECTION : REGGROUP1
    parameter block2_block2_reggroup1_count         = 1;
    parameter block2_block2_reggroup1_address_width = addr_width;
    
    // SECTION : BLOCK2
    parameter block2_count         = 1;
    parameter block2_address_width = addr_width;
    
    
    parameter block1_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : REG1 SIGNALS
    
    
    wire    reg1_decode;         // Write DECODE
    wire    reg1_rdecode;        // Read  DECODE
    wire    reg1_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reg1_rd_data;          // READ DATA
    wire    [64-1 : 0] reg1_offset;  // OFFSET
    wire    reg1_write_error;          // ERROR SIGNAL
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reg1_f1_in_enb ;      // FIELD : F1
    input   reg1_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reg1_f1_q ;      // FIELD : F1
    reg [15 : 0] reg1_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reg1_f1_r ;      // FIELD : F1
    output  [15 : 0] reg1_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reg1_f1_in ;      // FIELD : F1
    input   [15 : 0] reg1_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG1 SIGNALS
    
    
    wire    reggroup1_reg1_decode;         // Write DECODE
    wire    reggroup1_reg1_rdecode;        // Read  DECODE
    wire    reggroup1_reg1_wr_valid;       // WRITE VALID
    wire    reggroup1_reg1_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reggroup1_reg1_rd_data;          // READ DATA
    wire    [64-1 : 0] reggroup1_reg1_offset;  // OFFSET
    output  reggroup1_reg1_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reggroup1_reg1_f1_in_enb ;      // FIELD : F1
    input   reggroup1_reg1_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reggroup1_reg1_f1_q ;      // FIELD : F1
    reg [15 : 0] reggroup1_reg1_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reggroup1_reg1_f1_r ;      // FIELD : F1
    output  [15 : 0] reggroup1_reg1_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reggroup1_reg1_f1_in ;      // FIELD : F1
    input   [15 : 0] reggroup1_reg1_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG2 SIGNALS
    
    
    wire    reggroup1_reg2_decode;         // Write DECODE
    wire    reggroup1_reg2_rdecode;        // Read  DECODE
    wire    reggroup1_reg2_wr_valid;       // WRITE VALID
    wire    reggroup1_reg2_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reggroup1_reg2_rd_data;          // READ DATA
    wire    [64-1 : 0] reggroup1_reg2_offset;  // OFFSET
    output  reggroup1_reg2_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reggroup1_reg2_f1_in_enb ;      // FIELD : F1
    input   reggroup1_reg2_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reggroup1_reg2_f1_q ;      // FIELD : F1
    reg [15 : 0] reggroup1_reg2_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reggroup1_reg2_f1_r ;      // FIELD : F1
    output  [15 : 0] reggroup1_reg2_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reggroup1_reg2_f1_in ;      // FIELD : F1
    input   [15 : 0] reggroup1_reg2_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG1 SIGNALS
    
    
    wire    block2_reg1_decode;         // Write DECODE
    wire    block2_reg1_rdecode;        // Read  DECODE
    wire    block2_reg1_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] block2_reg1_rd_data;          // READ DATA
    wire    [64-1 : 0] block2_reg1_offset;  // OFFSET
    wire    block2_reg1_write_error;          // ERROR SIGNAL
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   block2_reg1_f1_in_enb ;      // FIELD : F1
    input   block2_reg1_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] block2_reg1_f1_q ;      // FIELD : F1
    reg [15 : 0] block2_reg1_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] block2_reg1_f1_r ;      // FIELD : F1
    output  [15 : 0] block2_reg1_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] block2_reg1_f1_in ;      // FIELD : F1
    input   [15 : 0] block2_reg1_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG1 SIGNALS
    
    
    wire    block2_block2_reggroup1_reg1_decode;         // Write DECODE
    wire    block2_block2_reggroup1_reg1_rdecode;        // Read  DECODE
    wire    block2_block2_reggroup1_reg1_wr_valid;       // WRITE VALID
    wire    block2_block2_reggroup1_reg1_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] block2_block2_reggroup1_reg1_rd_data;          // READ DATA
    wire    [64-1 : 0] block2_block2_reggroup1_reg1_offset;  // OFFSET
    output  block2_block2_reggroup1_reg1_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   block2_block2_reggroup1_reg1_f1_in_enb ;      // FIELD : F1
    input   block2_block2_reggroup1_reg1_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] block2_block2_reggroup1_reg1_f1_q ;      // FIELD : F1
    reg [15 : 0] block2_block2_reggroup1_reg1_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] block2_block2_reggroup1_reg1_f1_r ;      // FIELD : F1
    output  [15 : 0] block2_block2_reggroup1_reg1_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] block2_block2_reggroup1_reg1_f1_in ;      // FIELD : F1
    input   [15 : 0] block2_block2_reggroup1_reg1_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG2 SIGNALS
    
    
    wire    block2_block2_reggroup1_reg2_decode;         // Write DECODE
    wire    block2_block2_reggroup1_reg2_rdecode;        // Read  DECODE
    wire    block2_block2_reggroup1_reg2_wr_valid;       // WRITE VALID
    wire    block2_block2_reggroup1_reg2_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] block2_block2_reggroup1_reg2_rd_data;          // READ DATA
    wire    [64-1 : 0] block2_block2_reggroup1_reg2_offset;  // OFFSET
    output  block2_block2_reggroup1_reg2_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   block2_block2_reggroup1_reg2_f1_in_enb ;      // FIELD : F1
    input   block2_block2_reggroup1_reg2_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] block2_block2_reggroup1_reg2_f1_q ;      // FIELD : F1
    reg [15 : 0] block2_block2_reggroup1_reg2_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] block2_block2_reggroup1_reg2_f1_r ;      // FIELD : F1
    output  [15 : 0] block2_block2_reggroup1_reg2_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] block2_block2_reggroup1_reg2_f1_in ;      // FIELD : F1
    input   [15 : 0] block2_block2_reggroup1_reg2_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    
    //AXI signals
    input aclk;
    input aresetn;
    input [addr_width-1 : 0] awaddr;
    input awvalid;
    output awready;
    input [2 : 0] awprot;
    wire  [2 : 0] awprot_i;
    input [bus_width-1 : 0] wdata;
    input wvalid;
    output wready;
    input [bus_width/8-1 : 0] wstrb;
    output [1 : 0] bresp;
    input bready;
    output bvalid;
    input [addr_width-1 : 0] araddr;
    input arvalid;
    output arready;
    input [2 : 0] arprot;
    wire  [2 : 0] arprot_i;
    output [bus_width-1 : 0] rdata;
    output rvalid;
    input rready;
    output [1 : 0] rresp;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire [addr_width-1 : 0] raddress;
    wire  wr_error;
    wire  rd_error;
    wire  wr_decode_error;
    wire  rd_decode_error;
    wire  wr_slave_select;
    wire  rd_slave_select;
    wire  [addr_width-1:0] slvwaddr;
    wire  [addr_width-1:0] slvraddr;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    axi_widget #(.addr_width(addr_width), .bus_width(bus_width)) axi(
            .aclk(aclk),
            .aresetn(aresetn),
            .awaddr(awaddr),
            .awvalid(awvalid),
            .awready(awready),
            .awprot(awprot),
            .awprot_i(awprot_i),
            .wdata(wdata),
            .wvalid(wvalid),
            .wready(wready),
            .wstrb(wstrb),
            .bresp(bresp),
            .bready(bready),
            .bvalid(bvalid),
            .araddr(araddr),
            .arvalid(arvalid),
            .arready(arready),
            .arprot(arprot),
            .arprot_i(arprot_i),
            .rdata(rdata),
            .rvalid(rvalid),
            .rready(rready),
            .rresp(rresp),
            .clk(clk),
            .reset_l(reset_l),
            .request(request),
            .wr_stb(wr_stb),
            .wr_decode_error(wr_decode_error),
            .rd_decode_error(rd_decode_error),
            .wr_slave_select(wr_slave_select),
            .rd_slave_select(rd_slave_select),
            .slvwaddr(slvwaddr),
            .slvraddr(slvraddr),
            .rd_stb(rd_stb),
            .rd_wait(rd_wait),
            .wr_error(wr_error),
            .rd_error(rd_error),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .raddress(raddress),
            .rd_data_vld(rd_data_vld),
            .byte_enb(byte_enb));
    //end widget
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG1
    // ADDRESS       :  block_offset+'h8                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-only HW : Read-Write )
    //    31:16 : f2  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign reg1_rd_valid = reg1_rdecode && rd_stb;
    assign reg1_offset = block_offset+'h8;
    assign reg1_decode  = (address[block1_address_width-1 : 0]    == reg1_offset[block1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reg1_rdecode = (raddress[block1_address_width-1 : 0]   == reg1_offset[block1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg1_f1_q  <= 16'd0;
            end
        else
            begin
            if (reg1_f1_in_enb)   // F1 : HW Write
                begin
                    reg1_f1_q <= reg1_f1_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg1_f2_q  <= 16'd0;
            end
        else
            begin
            if (reg1_f2_in_enb)   // F2 : HW Write
                begin
                    reg1_f2_q <= reg1_f2_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg1_f1_r  =  reg1_f1_q ;    // Field : F1
    assign reg1_f2_r  =  reg1_f2_q ;    // Field : F2
    
    
    assign reg1_rd_data = reg1_rd_valid ? {reg1_f2_q , reg1_f1_q} : 32'b00000000000000000000000000000000;
    assign reg1_write_error = reg1_decode && wr_stb;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG1
    // ADDRESS       :  block_offset+'h0 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-Write HW : Read-Write )
    //    31:16 : f2  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reggroup1_reg1_wr_valid = reggroup1_reg1_decode && wr_stb;
    assign reggroup1_reg1_rd_valid = reggroup1_reg1_rdecode && rd_stb;
    assign reggroup1_reg1_enb      = reggroup1_reg1_wr_valid;
    assign reggroup1_reg1_offset = block_offset+'h0 + 'h0;
    assign reggroup1_reg1_decode  = (address[reggroup1_address_width-1 : 0]    == reggroup1_reg1_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reggroup1_reg1_rdecode = (raddress[reggroup1_address_width-1 : 0]   == reggroup1_reg1_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg1_f1_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg1_f1_in_enb)   // F1 : HW Write
                begin
                    reggroup1_reg1_f1_q <= reggroup1_reg1_f1_in;
                end
            else
                begin
                    
                if (reggroup1_reg1_wr_valid)   // F1 : SW Write
                    begin
                        reggroup1_reg1_f1_q <=  ( wr_data[15 : 0] & reg_enb[15 : 0] ) | (reggroup1_reg1_f1_q & (~reg_enb[15 : 0]));
                    end
                else
                    begin
                        reggroup1_reg1_f1_q <= reggroup1_reg2_f2_q;
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg1_f2_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg1_f2_in_enb)   // F2 : HW Write
                begin
                    reggroup1_reg1_f2_q <= reggroup1_reg1_f2_in;
                end
            else
                begin
                    
                if (reggroup1_reg1_wr_valid)   // F2 : SW Write
                    begin
                        reggroup1_reg1_f2_q <=  ( wr_data[31 : 16] & reg_enb[31 : 16] ) | (reggroup1_reg1_f2_q & (~reg_enb[31 : 16]));
                    end
                else
                    begin
                        reggroup1_reg1_f2_q <= reggroup1_reg2_f1_q;
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reggroup1_reg1_f1_r =  reggroup1_reg1_f1_q;    // Field : F1
    assign reggroup1_reg1_f2_r =  reggroup1_reg1_f2_q;    // Field : F2
    
    
    assign reggroup1_reg1_rd_data = reggroup1_reg1_rd_valid ? {reggroup1_reg1_f2_q , reggroup1_reg1_f1_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG2
    // ADDRESS       :  block_offset+'h0 + 'h4                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-Write HW : Read-Write )
    //    31:16 : f2  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reggroup1_reg2_wr_valid = reggroup1_reg2_decode && wr_stb;
    assign reggroup1_reg2_rd_valid = reggroup1_reg2_rdecode && rd_stb;
    assign reggroup1_reg2_enb      = reggroup1_reg2_wr_valid;
    assign reggroup1_reg2_offset = block_offset+'h0 + 'h4;
    assign reggroup1_reg2_decode  = (address[reggroup1_address_width-1 : 0]    == reggroup1_reg2_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reggroup1_reg2_rdecode = (raddress[reggroup1_address_width-1 : 0]   == reggroup1_reg2_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f1_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f1_in_enb)   // F1 : HW Write
                begin
                    reggroup1_reg2_f1_q <= reggroup1_reg2_f1_in;
                end
            else
                begin
                    
                if (reggroup1_reg2_wr_valid)   // F1 : SW Write
                    begin
                        reggroup1_reg2_f1_q <=  ( wr_data[15 : 0] & reg_enb[15 : 0] ) | (reggroup1_reg2_f1_q & (~reg_enb[15 : 0]));
                    end
                else
                    begin
                        reggroup1_reg2_f1_q <= (reggroup1_reg1_f1_q) && (reggroup1_reg1_f2_q);
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f2_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f2_in_enb)   // F2 : HW Write
                begin
                    reggroup1_reg2_f2_q <= reggroup1_reg2_f2_in;
                end
            else
                begin
                    
                if (reggroup1_reg2_wr_valid)   // F2 : SW Write
                    begin
                        reggroup1_reg2_f2_q <=  ( wr_data[31 : 16] & reg_enb[31 : 16] ) | (reggroup1_reg2_f2_q & (~reg_enb[31 : 16]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reggroup1_reg2_f1_r =  reggroup1_reg2_f1_q;    // Field : F1
    assign reggroup1_reg2_f2_r =  reggroup1_reg2_f2_q;    // Field : F2
    
    
    assign reggroup1_reg2_rd_data = reggroup1_reg2_rd_valid ? {reggroup1_reg2_f2_q , reggroup1_reg2_f1_q} : 32'b00000000000000000000000000000000;
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG1
    // ADDRESS       :  block_offset+'hC + 'h8                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-only HW : Read-Write )
    //    31:16 : f2  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign block2_reg1_rd_valid = block2_reg1_rdecode && rd_stb;
    assign block2_reg1_offset = block_offset+'hC + 'h8;
    assign block2_reg1_decode  = (address[block2_address_width-1 : 0]    == block2_reg1_offset[block2_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign block2_reg1_rdecode = (raddress[block2_address_width-1 : 0]   == block2_reg1_offset[block2_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                block2_reg1_f1_q <= 16'd0;
            end
        else
            begin
            if (block2_reg1_f1_in_enb)   // F1 : HW Write
                begin
                    block2_reg1_f1_q <= block2_reg1_f1_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                block2_reg1_f2_q <= 16'd0;
            end
        else
            begin
            if (block2_reg1_f2_in_enb)   // F2 : HW Write
                begin
                    block2_reg1_f2_q <= block2_reg1_f2_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign block2_reg1_f1_r =  block2_reg1_f1_q;    // Field : F1
    assign block2_reg1_f2_r =  block2_reg1_f2_q;    // Field : F2
    
    
    assign block2_reg1_rd_data = block2_reg1_rd_valid ? {block2_reg1_f2_q , block2_reg1_f1_q} : 32'b00000000000000000000000000000000;
    assign block2_reg1_write_error = block2_reg1_decode && wr_stb;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG1
    // ADDRESS       :  block_offset+'hC + 'h0 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-Write HW : Read-Write )
    //    31:16 : f2  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign block2_block2_reggroup1_reg1_wr_valid = block2_block2_reggroup1_reg1_decode && wr_stb;
    assign block2_block2_reggroup1_reg1_rd_valid = block2_block2_reggroup1_reg1_rdecode && rd_stb;
    assign block2_block2_reggroup1_reg1_enb      = block2_block2_reggroup1_reg1_wr_valid;
    assign block2_block2_reggroup1_reg1_offset = block_offset+'hC + 'h0 + 'h0;
    assign block2_block2_reggroup1_reg1_decode  = (address[block2_block2_reggroup1_address_width-1 : 0]    == block2_block2_reggroup1_reg1_offset[block2_block2_reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign block2_block2_reggroup1_reg1_rdecode = (raddress[block2_block2_reggroup1_address_width-1 : 0]   == block2_block2_reggroup1_reg1_offset[block2_block2_reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                block2_block2_reggroup1_reg1_f1_q <= 16'd0;
            end
        else
            begin
            if (block2_block2_reggroup1_reg1_f1_in_enb)   // F1 : HW Write
                begin
                    block2_block2_reggroup1_reg1_f1_q <= block2_block2_reggroup1_reg1_f1_in;
                end
            else
                begin
                    
                if (block2_block2_reggroup1_reg1_wr_valid)   // F1 : SW Write
                    begin
                        block2_block2_reggroup1_reg1_f1_q <=  ( wr_data[15 : 0] & reg_enb[15 : 0] ) | (block2_block2_reggroup1_reg1_f1_q & (~reg_enb[15 : 0]));
                    end
                else
                    begin
                        block2_block2_reggroup1_reg1_f1_q <= block2_block2_reggroup1_reg2_f2_q;
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                block2_block2_reggroup1_reg1_f2_q <= 16'd0;
            end
        else
            begin
            if (block2_block2_reggroup1_reg1_f2_in_enb)   // F2 : HW Write
                begin
                    block2_block2_reggroup1_reg1_f2_q <= block2_block2_reggroup1_reg1_f2_in;
                end
            else
                begin
                    
                if (block2_block2_reggroup1_reg1_wr_valid)   // F2 : SW Write
                    begin
                        block2_block2_reggroup1_reg1_f2_q <=  ( wr_data[31 : 16] & reg_enb[31 : 16] ) | (block2_block2_reggroup1_reg1_f2_q & (~reg_enb[31 : 16]));
                    end
                else
                    begin
                        block2_block2_reggroup1_reg1_f2_q <= block2_block2_reggroup1_reg2_f1_q;
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign block2_block2_reggroup1_reg1_f1_r =  block2_block2_reggroup1_reg1_f1_q;    // Field : F1
    assign block2_block2_reggroup1_reg1_f2_r =  block2_block2_reggroup1_reg1_f2_q;    // Field : F2
    
    
    assign block2_block2_reggroup1_reg1_rd_data = block2_block2_reggroup1_reg1_rd_valid ? {block2_block2_reggroup1_reg1_f2_q , block2_block2_reggroup1_reg1_f1_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG2
    // ADDRESS       :  block_offset+'hC + 'h0 + 'h4                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-Write HW : Read-Write )
    //    31:16 : f2  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign block2_block2_reggroup1_reg2_wr_valid = block2_block2_reggroup1_reg2_decode && wr_stb;
    assign block2_block2_reggroup1_reg2_rd_valid = block2_block2_reggroup1_reg2_rdecode && rd_stb;
    assign block2_block2_reggroup1_reg2_enb      = block2_block2_reggroup1_reg2_wr_valid;
    assign block2_block2_reggroup1_reg2_offset = block_offset+'hC + 'h0 + 'h4;
    assign block2_block2_reggroup1_reg2_decode  = (address[block2_block2_reggroup1_address_width-1 : 0]    == block2_block2_reggroup1_reg2_offset[block2_block2_reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign block2_block2_reggroup1_reg2_rdecode = (raddress[block2_block2_reggroup1_address_width-1 : 0]   == block2_block2_reggroup1_reg2_offset[block2_block2_reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                block2_block2_reggroup1_reg2_f1_q <= 16'd0;
            end
        else
            begin
            if (block2_block2_reggroup1_reg2_f1_in_enb)   // F1 : HW Write
                begin
                    block2_block2_reggroup1_reg2_f1_q <= block2_block2_reggroup1_reg2_f1_in;
                end
            else
                begin
                    
                if (block2_block2_reggroup1_reg2_wr_valid)   // F1 : SW Write
                    begin
                        block2_block2_reggroup1_reg2_f1_q <=  ( wr_data[15 : 0] & reg_enb[15 : 0] ) | (block2_block2_reggroup1_reg2_f1_q & (~reg_enb[15 : 0]));
                    end
                else
                    begin
                        block2_block2_reggroup1_reg2_f1_q <= (block2_block2_reggroup1_reg1_f1_q) && (block2_block2_reggroup1_reg1_f2_q);
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                block2_block2_reggroup1_reg2_f2_q <= 16'd0;
            end
        else
            begin
            if (block2_block2_reggroup1_reg2_f2_in_enb)   // F2 : HW Write
                begin
                    block2_block2_reggroup1_reg2_f2_q <= block2_block2_reggroup1_reg2_f2_in;
                end
            else
                begin
                    
                if (block2_block2_reggroup1_reg2_wr_valid)   // F2 : SW Write
                    begin
                        block2_block2_reggroup1_reg2_f2_q <=  ( wr_data[31 : 16] & reg_enb[31 : 16] ) | (block2_block2_reggroup1_reg2_f2_q & (~reg_enb[31 : 16]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign block2_block2_reggroup1_reg2_f1_r =  block2_block2_reggroup1_reg2_f1_q;    // Field : F1
    assign block2_block2_reggroup1_reg2_f2_r =  block2_block2_reggroup1_reg2_f2_q;    // Field : F2
    
    
    assign block2_block2_reggroup1_reg2_rd_data = block2_block2_reggroup1_reg2_rd_valid ? {block2_block2_reggroup1_reg2_f2_q , block2_block2_reggroup1_reg2_f1_q} : 32'b00000000000000000000000000000000;
    
    
    
    
    
    
    assign rd_data = reggroup1_reg1_rd_data |
    reggroup1_reg2_rd_data |
    reg1_rd_data |
    block2_block2_reggroup1_reg1_rd_data |
    block2_block2_reggroup1_reg2_rd_data |
    block2_reg1_rd_data ;
    
    
    
    assign wr_error = reg1_write_error |
    block2_reg1_write_error;
    
    assign rd_error = 0;
    
    assign wr_decode_error = 0;
    
    assign rd_decode_error = 0;
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    assign wr_slave_select = ((slvwaddr[addr_width - 1 : 0]  >= block_offset) && (slvwaddr[addr_width - 1 : 0]  <= block_offset + 'h17)) ? 1'b1 : 1'b0;
    assign rd_slave_select = ((slvraddr[addr_width - 1 : 0]  >= block_offset) && (slvraddr[addr_width - 1 : 0]  <= block_offset + 'h17)) ? 1'b1 : 1'b0;
    
endmodule

//------------------------------------------------
//  BLOCK : BLOCK3 MODULE
//

module block3_ids(
    
    // REGISTER : REG1 PORT SIGNAL
    reg1_f1_in,
    reg1_f1_in_enb,
    reg1_f1_r,
    
    reg1_f2_in,
    reg1_f2_in_enb,
    reg1_f2_r,
    
    
    // REGISTER : REG1 PORT SIGNAL
    reggroup1_reg1_f1_in,
    reggroup1_reg1_f1_in_enb,
    reggroup1_reg1_f1_r,
    
    reggroup1_reg1_f2_in,
    reggroup1_reg1_f2_in_enb,
    reggroup1_reg1_f2_r,
    
    
    // REGISTER : REG2 PORT SIGNAL
    reggroup1_reg2_f1_in,
    reggroup1_reg2_f1_in_enb,
    reggroup1_reg2_f1_r,
    
    reggroup1_reg2_f2_in,
    reggroup1_reg2_f2_in_enb,
    reggroup1_reg2_f2_r,
    
    
    
    //AXI signals
    aclk,   // Bus clock
    aresetn,   // Reset
    awaddr,   // Write address
    awvalid,   // Write address valid : This signal indicates that write address is valid
    awready,   // Write address ready : This signal indicates that the slave is ready to accept an address
    awprot,   // Write Protection Type
    wdata,   // Write data
    wvalid,   // Write valid         : This signal indicates that valid write data and strobes are available
    wready,   // Write ready         : This signal indicates that the slave can accept the write data
    wstrb,   // Write Strobes
    bresp,   // Write Response
    bready,   // Response Ready
    bvalid,   // Response valid
    araddr,   // Read  address
    arvalid,   // Read address valid  : This signal indicates that the read address is valid and will remain stable until ARREADY is high
    arready,   // Read address ready  : This signal indicates that the slave is ready to accept an address
    arprot,   // Read Protection Type
    rdata,   // Read data
    rvalid,   // Read valid          : This signal indicates that the required read data is available and the read transfer can complete
    rready,   // Read ready          : This signal indicates that the master can accept the read data
    rresp   // Read Response
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 4;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REGGROUP1
    parameter reggroup1_count         = 1;
    parameter reggroup1_address_width = addr_width;
    
    
    parameter block3_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : REG1 SIGNALS
    
    
    wire    reg1_decode;         // Write DECODE
    wire    reg1_rdecode;        // Read  DECODE
    wire    reg1_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reg1_rd_data;          // READ DATA
    wire    [64-1 : 0] reg1_offset;  // OFFSET
    wire    reg1_write_error;          // ERROR SIGNAL
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reg1_f1_in_enb ;      // FIELD : F1
    input   reg1_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reg1_f1_q ;      // FIELD : F1
    reg [15 : 0] reg1_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reg1_f1_r ;      // FIELD : F1
    output  [15 : 0] reg1_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reg1_f1_in ;      // FIELD : F1
    input   [15 : 0] reg1_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG1 SIGNALS
    
    
    wire    reggroup1_reg1_decode;         // Write DECODE
    wire    reggroup1_reg1_rdecode;        // Read  DECODE
    wire    reggroup1_reg1_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reggroup1_reg1_rd_data;          // READ DATA
    wire    [64-1 : 0] reggroup1_reg1_offset;  // OFFSET
    wire    reggroup1_reg1_write_error;          // ERROR SIGNAL
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reggroup1_reg1_f1_in_enb ;      // FIELD : F1
    input   reggroup1_reg1_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reggroup1_reg1_f1_q ;      // FIELD : F1
    reg [15 : 0] reggroup1_reg1_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reggroup1_reg1_f1_r ;      // FIELD : F1
    output  [15 : 0] reggroup1_reg1_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reggroup1_reg1_f1_in ;      // FIELD : F1
    input   [15 : 0] reggroup1_reg1_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG2 SIGNALS
    
    
    wire    reggroup1_reg2_decode;         // Write DECODE
    wire    reggroup1_reg2_rdecode;        // Read  DECODE
    wire    reggroup1_reg2_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reggroup1_reg2_rd_data;          // READ DATA
    wire    [64-1 : 0] reggroup1_reg2_offset;  // OFFSET
    wire    reggroup1_reg2_write_error;          // ERROR SIGNAL
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   reggroup1_reg2_f1_in_enb ;      // FIELD : F1
    input   reggroup1_reg2_f2_in_enb ;      // FIELD : F2
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [15 : 0] reggroup1_reg2_f1_q ;      // FIELD : F1
    reg [15 : 0] reggroup1_reg2_f2_q ;      // FIELD : F2
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [15 : 0] reggroup1_reg2_f1_r ;      // FIELD : F1
    output  [15 : 0] reggroup1_reg2_f2_r ;      // FIELD : F2
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [15 : 0] reggroup1_reg2_f1_in ;      // FIELD : F1
    input   [15 : 0] reggroup1_reg2_f2_in ;      // FIELD : F2
    
    //-----------------------------------------------------
    
    
    
    //AXI signals
    input aclk;
    input aresetn;
    input [addr_width-1 : 0] awaddr;
    input awvalid;
    output awready;
    input [2 : 0] awprot;
    wire  [2 : 0] awprot_i;
    input [bus_width-1 : 0] wdata;
    input wvalid;
    output wready;
    input [bus_width/8-1 : 0] wstrb;
    output [1 : 0] bresp;
    input bready;
    output bvalid;
    input [addr_width-1 : 0] araddr;
    input arvalid;
    output arready;
    input [2 : 0] arprot;
    wire  [2 : 0] arprot_i;
    output [bus_width-1 : 0] rdata;
    output rvalid;
    input rready;
    output [1 : 0] rresp;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire [addr_width-1 : 0] raddress;
    wire  wr_error;
    wire  rd_error;
    wire  wr_decode_error;
    wire  rd_decode_error;
    wire  wr_slave_select;
    wire  rd_slave_select;
    wire  [addr_width-1:0] slvwaddr;
    wire  [addr_width-1:0] slvraddr;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    axi_widget #(.addr_width(addr_width), .bus_width(bus_width)) axi(
            .aclk(aclk),
            .aresetn(aresetn),
            .awaddr(awaddr),
            .awvalid(awvalid),
            .awready(awready),
            .awprot(awprot),
            .awprot_i(awprot_i),
            .wdata(wdata),
            .wvalid(wvalid),
            .wready(wready),
            .wstrb(wstrb),
            .bresp(bresp),
            .bready(bready),
            .bvalid(bvalid),
            .araddr(araddr),
            .arvalid(arvalid),
            .arready(arready),
            .arprot(arprot),
            .arprot_i(arprot_i),
            .rdata(rdata),
            .rvalid(rvalid),
            .rready(rready),
            .rresp(rresp),
            .clk(clk),
            .reset_l(reset_l),
            .request(request),
            .wr_stb(wr_stb),
            .wr_decode_error(wr_decode_error),
            .rd_decode_error(rd_decode_error),
            .wr_slave_select(wr_slave_select),
            .rd_slave_select(rd_slave_select),
            .slvwaddr(slvwaddr),
            .slvraddr(slvraddr),
            .rd_stb(rd_stb),
            .rd_wait(rd_wait),
            .wr_error(wr_error),
            .rd_error(rd_error),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .raddress(raddress),
            .rd_data_vld(rd_data_vld),
            .byte_enb(byte_enb));
    //end widget
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG1
    // ADDRESS       :  block_offset+'h8                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-only HW : Read-Write )
    //    31:16 : f2  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign reg1_rd_valid = reg1_rdecode && rd_stb;
    assign reg1_offset = block_offset+'h8;
    assign reg1_decode  = (address[block3_address_width-1 : 0]    == reg1_offset[block3_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reg1_rdecode = (raddress[block3_address_width-1 : 0]   == reg1_offset[block3_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg1_f1_q  <= 16'd0;
            end
        else
            begin
            if (reg1_f1_in_enb)   // F1 : HW Write
                begin
                    reg1_f1_q <= reg1_f1_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg1_f2_q  <= 16'd0;
            end
        else
            begin
            if (reg1_f2_in_enb)   // F2 : HW Write
                begin
                    reg1_f2_q <= reg1_f2_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg1_f1_r  =  reg1_f1_q ;    // Field : F1
    assign reg1_f2_r  =  reg1_f2_q ;    // Field : F2
    
    
    assign reg1_rd_data = reg1_rd_valid ? {reg1_f2_q , reg1_f1_q} : 32'b00000000000000000000000000000000;
    assign reg1_write_error = reg1_decode && wr_stb;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG1
    // ADDRESS       :  block_offset+'h0 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-only HW : Read-Write )
    //    31:16 : f2  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign reggroup1_reg1_rd_valid = reggroup1_reg1_rdecode && rd_stb;
    assign reggroup1_reg1_offset = block_offset+'h0 + 'h0;
    assign reggroup1_reg1_decode  = (address[reggroup1_address_width-1 : 0]    == reggroup1_reg1_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reggroup1_reg1_rdecode = (raddress[reggroup1_address_width-1 : 0]   == reggroup1_reg1_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg1_f1_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg1_f1_in_enb)   // F1 : HW Write
                begin
                    reggroup1_reg1_f1_q <= reggroup1_reg1_f1_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg1_f2_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg1_f2_in_enb)   // F2 : HW Write
                begin
                    reggroup1_reg1_f2_q <= reggroup1_reg1_f2_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reggroup1_reg1_f1_r =  reggroup1_reg1_f1_q;    // Field : F1
    assign reggroup1_reg1_f2_r =  reggroup1_reg1_f2_q;    // Field : F2
    
    
    assign reggroup1_reg1_rd_data = reggroup1_reg1_rd_valid ? {reggroup1_reg1_f2_q , reggroup1_reg1_f1_q} : 32'b00000000000000000000000000000000;
    assign reggroup1_reg1_write_error = reggroup1_reg1_decode && wr_stb;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG2
    // ADDRESS       :  block_offset+'h0 + 'h4                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     15:0 : f1  ( SW : Read-only HW : Read-Write )
    //    31:16 : f2  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign reggroup1_reg2_rd_valid = reggroup1_reg2_rdecode && rd_stb;
    assign reggroup1_reg2_offset = block_offset+'h0 + 'h4;
    assign reggroup1_reg2_decode  = (address[reggroup1_address_width-1 : 0]    == reggroup1_reg2_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    assign reggroup1_reg2_rdecode = (raddress[reggroup1_address_width-1 : 0]   == reggroup1_reg2_offset[reggroup1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f1_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f1_in_enb)   // F1 : HW Write
                begin
                    reggroup1_reg2_f1_q <= reggroup1_reg2_f1_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  16
    // SW ACCESS  :  READ-ONLY                           OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reggroup1_reg2_f2_q <= 16'd0;
            end
        else
            begin
            if (reggroup1_reg2_f2_in_enb)   // F2 : HW Write
                begin
                    reggroup1_reg2_f2_q <= reggroup1_reg2_f2_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reggroup1_reg2_f1_r =  reggroup1_reg2_f1_q;    // Field : F1
    assign reggroup1_reg2_f2_r =  reggroup1_reg2_f2_q;    // Field : F2
    
    
    assign reggroup1_reg2_rd_data = reggroup1_reg2_rd_valid ? {reggroup1_reg2_f2_q , reggroup1_reg2_f1_q} : 32'b00000000000000000000000000000000;
    assign reggroup1_reg2_write_error = reggroup1_reg2_decode && wr_stb;
    
    
    
    
    
    assign rd_data = reggroup1_reg1_rd_data |
    reggroup1_reg2_rd_data |
    reg1_rd_data ;
    
    
    
    assign wr_error = reggroup1_reg1_write_error |
    reggroup1_reg2_write_error |
    reg1_write_error;
    
    assign rd_error = 0;
    
    assign wr_decode_error = 0;
    
    assign rd_decode_error = 0;
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    assign wr_slave_select = ((slvwaddr[addr_width - 1 : 0]  >= block_offset) && (slvwaddr[addr_width - 1 : 0]  <= block_offset + 'hB)) ? 1'b1 : 1'b0;
    assign rd_slave_select = ((slvraddr[addr_width - 1 : 0]  >= block_offset) && (slvraddr[addr_width - 1 : 0]  <= block_offset + 'hB)) ? 1'b1 : 1'b0;
    
endmodule
