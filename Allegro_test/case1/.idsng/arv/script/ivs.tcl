#!/usr/bin/tclsh

###################################################################################
#  Agnisys Inc.                                                                   #
#  ***** Copyright 2012 All Rights Reserved. *****                                #
#  IVerifySpec Sim-In script                                                      #
#  Version : 3.9.0.0                                                              #
#                                                                                 #
###################################################################################
#Updates:                                                                         #
#  VK  12Jul2012   modify xml                                                     #
#  ST  19Dec2011   added options : filter, max_hier_level                         #
#  KS  15Oct2012   modify xml :grade:00 is displayed as 0                         #
#  KS  15Oct2012   modify plan xml for IVS                                        #
#  KS  22april2013 added hierarchichal plan xml                                   #
#  KS  22May2013   added .vsof database parsing                                   #
#  KS  17Jul2013   reading of .ucd database from .vsof                            #
#  KS  20Aug2013   enhancement in functional coverage parsing for Cadence         #
#  KS  28Oct2013   added summary config to plan xml --bugfix                      #
#####################################SCRIPT START #################################

#SCRIPT VERSION 
set version "3.9.0.0"

proc printHelp {args} {
     upvar scriptname scriptname
     puts "\nUsage: $scriptname \(\-in \<database\> | -dir <report_dir>\ | -cov_rpt <report_file>) \[-out \<output_dir\>\] 
                               \[-filter <hierarchy_filter>\] \[-code_cov\] \[-href\] \[-rpt \<rpt_dir\>]\ \[-html \<html_dir>\]
                               \[-sourceid <sourceid>\] \[-runid <runid>\] \[-hdl_path <hdl_path>\] \[-regression <regression_name>\]
                               \[-metric \"name value type, . . .\" \[-help\] \[-version\]\[-plan <plan_type>\]
                               \[-uploadResult | -uploadPlan \(-ivs_url <ivs_url> -u <username> -p <password> -project <projectname> -file <file_path> 
                                 -comment <\"comment\">\) \] "
puts {For Generating xml files :-
-in <database>         : Specify the database* (file or directory) to read verification results from. Multiple files/directories can be 
                         specified inside double quotes, and separated by space.
-dir <report_dir>      : (For Synopsys only) Take Reports from the <report_dir> directory generated by URG command.
-cov_rpt <report_file> : Takes Report file as an input.(For Specman Report only)
-out <output_dir>      : Directory where output xml files are generated. These files are read-in by IVS.
                         By default, output xml files are created in the current directory.
-filter <hierarchy_filter>
                       : Filter the metrics containing the hierarchy filter value.
-code_cov              : Include code coverage VPIs in the IVS Plan.
-href                  : Include hyperlinks of the Detail Reports of the metric.
-rpt <rpt_dir>         : Saves text reports generated by the simulation tool.
-html <html_dir>       : Specifies the directory where the simulation HTML report files
                         are generated.
-hdl_path              : Specify the hdl path of the project.
-regression            : Specify the name of Regression.
-plan                  : Specify the type of the plan xml.By default,a flat IVS plan xml is created.other plan types can be "type" or "hierarchy"
-metric "name value type, . . .":
                         Include the metrices in the ivs input xml.

For Uploading files into the Webserver :-

-uploadResult          : Upload results to the IVS server.
-uploadPlan            : Upload plan to the IVS server.
-asyncResult           : upload async result.
-ivs_url <ivs_url>     : Specify the webserver url of the machine where IVS is running, along with the port number.
                         For e.g. -ivs http://122.160.66.145:9090/IVS/
-u <username>          : Specify the IVS login name.
-p <password>          : Specify the IVS password.
-project <proj_name>   : Specify the IVS project name for which the results are to be submitted.
-sourceid              : Specify the sourceid of the Regression. sourceid identifies unique build of the design and verification files.
-runid                 : Specify the runid for the Regression run. runid identifies unique run of the regression.
-file <file_path>      : Specify the path of the xml file.
-comment "comments"    : Specify comments for changes occurred in xml file.
-append                : For appending results with same sourceid.By default sourceid is overridden.
-merge                 : For merging *.ucd from the *.vsof file (For Cadence only)
-run_dir               : For specifying a single coverage database *.ucd while input is *.vsof file (For Cadence only)
-imc                   : For using imc tool (cadence)
  "-ivs_url <ivs_url> -project <projectname> -file <file_path>"
               These options are mandatory if "-uploadResult" option is given in commandline.

* For Mentor, specify a single merged '*.ucdb' database file.
  For Synopsys, specify '*.vdb' and/or '*.cm' database directory.
  For Cadence, specify the database directory where the '*.ucd' file is present in case of coverage database and
  for test specify the '*.vsof' database file.
  For Aldec, specify a single merged '*.acdb' database file.

}
}

##########################################################
# CREATING DIRECTORIES FOR REPORT GENERATION
global env
set TEMP_DIR ""
if {[catch { set TEMP_DIR [file join "$env(TEMP)" "ivs_[clock format [clock seconds] -format {%Y_%m_%d_%I_%M_%p}]"] } err ]} {
   set  TEMP_DIR [file join [pwd] "ivs_[clock format [clock seconds] -format {%Y_%m_%d_%I_%M_%p}]"]
}
set keep_rptdir false
set keep_htmldir false

set tmp_RPTDIR [file join $TEMP_DIR "txtrpt"]
set tmp_HTMLPATH [file join $TEMP_DIR "htmlrpt"]

set logfilename [file join [pwd] "log.txt"]
set userinput $argv
if {[file exists $logfilename]} {
    file delete -force $logfilename
}

#SETUP  SCRIPT FOR VERBOSE MODE
if {!([lsearch $userinput "-verbose"] == "-1")} {
    set oldtime [clock clicks -milliseconds]
    set log [open "$logfilename" w ] 
    close $log
    #IF VERBOSE=1, WRITE THE MESSAGES IN SHELL AND 'log.txt' FILE
    proc logfile {append} {
        upvar #0 oldtime oldtime
        set logfilename [file join [pwd] "log.txt"]
        set log [open "$logfilename" a]
        set systime [clock seconds]
        set time [clock clicks -milliseconds]
        set interval [expr ($time - $oldtime)]
        puts $log "$time\::$interval\::  $append"
        close $log
        puts "$time\::$interval\::  $append"
        set oldtime $time
        return 0
    }
} else {
    #ELSE DO NOTHING
    proc logfile {append} {
        return 4 
    }
}

#PARSE AND VALIDATE USER SPECIFIED OPTIONS
##########################################################
#VARIABLE DECLARATION
set DB ""
set OUTDIR ""
set RPT_FILE ""
set HTMLERROR 1
set HREFPREFIX ""
set MODE ""
set COV_LIST ""
set IMPORT 0
set SVG 0
set FILTER ""
set metric 0
set HREF 0
set metric_list {}
set scriptname [file tail $argv0]
set xmlfile ""

set max_hier ""
set keep_hier 0
set dblist ""
set inputdir ""
set outdir ""
set rpt_file ""
set htmldir ""
set hrefprefix ""
set rptdir ""
set imp_val ""
set imp_code_cov 0
set sourceid ""
set runid ""
set hdl_path ""
set regression ""
set nodb 0
set verbose false
set submit_results 0
set upload_result 0
set upload_plan 0
set url ""
set username ""
set password ""
set upload 0
set ivs_async 0
set project_name ""
set comment ""
set override yes
set plan_name ""
set file_path ""
set upload_type ""
set Report_file ""
set merge_ucd 0
set run_dir 0
set db_single ""
set imc 0
#ASSIGNING INPUT ARGUMENTS TO THE VARIABLES
for {set i 0} {$i < [llength $argv]} {incr i} {
    set option [lindex $argv $i]
    if {[string match "-in*" $option]} {
        incr i
        set dblist [lindex $argv $i]
    } elseif {[string equal "-dir" $option]} {
        incr i
        set nodb 1
        set inputdir [file normalize [lindex $argv $i]]
    } elseif {[string equal "-cov_rpt" $option]} {
        incr i
        set nodb 1
        set rpt_file [file normalize [lindex $argv $i]]
    #} elseif {[string equal "-test_rpt" $option]} {
     #   incr i
      #  set nodb 1
       # set Report_file "test_report"
        #set rpt_file [file normalize [lindex $argv $i]]
    
    } elseif {[string equal "-sourceid" $option]} {
        incr i
        set sourceid [lindex $argv $i]
    } elseif {[string equal "-comment" $option]} {
        incr i
        set comment [lindex $argv $i]
    } elseif {[string equal "-run_dir" $option ]} {
        incr i
        set run_dir 1
        set db_single [lindex $argv $i]
    } elseif {[string equal "-runid" $option]} {
        incr i
        set runid [lindex $argv $i]
    } elseif {[string equal "-hdl_path" $option]} {
         incr i 
         set hdl_path [lindex $argv $i]
    } elseif {[string equal "-regression" $option]} {
        incr i
        set regression [lindex $argv $i]
    } elseif {[string equal "-out" $option]} {
        incr i
        set outdir [file normalize [lindex $argv $i]]
    } elseif {[string equal "-filter" $option]} {
        incr i
        set FILTER [lindex $argv $i]
    } elseif {[string equal "-html" $option]} {
        incr i
        set htmldir [file normalize [lindex $argv $i]]
        set tmp_HTMLPATH $htmldir
        set keep_htmldir true
    } elseif {[string equal "-prefix" $option]} {
        incr i
        set hrefprefix [lindex $argv $i]  
    } elseif {[string equal "-href" $option]} {
        set HREF 1  
    } elseif {[string equal "-rpt" $option]} {
        incr i
        set rptdir [file normalize [lindex $argv $i]]
        set tmp_RPTDIR $rptdir
        set keep_rptdir true
    } elseif {[string equal "-plan" $option ]} {
        if { [string match "-*" [lindex $argv [expr ($i + 1)]]] || [string match "" [lindex $argv [expr ($i + 1)]]]} {
           set imp_val "name"
        } elseif {[string equal "type" [lindex $argv [expr ($i + 1)]]]} {
           set imp_val "type"
           incr i
        } elseif {[string equal "hierarchy" [lindex $argv [expr ($i + 1)]]]} {
           set imp_val "hierarchy"
           incr i
        } else {
           incr i
           puts "-plan \"[lindex $argv $i]\" not a Valid option.Acceptable fields are \"type\" or \"hierarchy\"."
           exit 0
        }
    } elseif {[string equal "-max_hier_level" $option ]} {
        incr i
        set max_hier [lindex $argv $i]
        if {![regexp {^[0-9]+$} $max_hier]} {
           puts "For $option \"$max_hier\" is not a valid option. Only real number value supported."
           exit 0
        }
    } elseif {[string match "-code*" $option ]} {
        set imp_code_cov 1
    } elseif {[string match "-merge" $option ]} {
        set merge_ucd 1
    } elseif {[string equal "-keep_hier" $option]} {
        set keep_hier true        
    } elseif {[string equal "-verbose" $option]} {
        set verbose true        
    } elseif {[string match "-h*" $option ]} {
        printHelp
        exit 0
    } elseif {[string match "-v*" $option ]} {
        puts "$scriptname version: $version"
        exit 0
    } elseif {[string equal "-svg" $option]} {
        if {[info exists env(IDS_SIM_DIR)]} {
           set svg_inputfile [file normalize "$env(IDS_SIM_DIR)"]  
           logfile "SVG input from 'COV_LIST' list"
        } else {
           puts "Please check whether 'IDS_SIM_DIR' environment variable exists."
           exit 2
        }
        set SVG 1
    } elseif {[string equal "-metric" $option]} {
        incr i
        set metric_list [lindex $argv $i]
        set metric 1
    # FOR UPLOADING THE RESULTS
    } elseif {[string equal "-uploadResult" $option]} {
        set upload_type "result"
        set upload_result 1
    } elseif {[string equal "-uploadPlan" $option]} {
        set upload_plan 1
        set upload_type "plan"
    } elseif {[string equal "-asyncResult" $option]} {
       set ivs_async 1
       set upload_result 1
       set upload_type "result"
    } elseif {[string equal "-ivs_url" $option]} {
        incr i
        set url [lindex $argv $i]
    } elseif {[string equal "-u" $option]} {
        incr i
        set username [lindex $argv $i]
    } elseif {[string equal "-p" $option]} {
        incr i
        set password [lindex $argv $i]
    } elseif {[string equal "-project" $option]} {
        incr i
        set project_name [lindex $argv $i]
    } elseif {[string equal "-append" $option]} {
        set override "" 
    } elseif {[string equal "-plan_name" $option]} {
        incr i
        set plan_name [lindex $argv $i]
    } elseif {[string equal "-file" $option]} {
        incr i
        set file_path [lindex $argv $i]
    } elseif {[string equal "-upload" $option]} {
        set upload 1 

    } elseif {[string equal "-imc" $option]} {
	    set imc 1
	}  elseif {[string match "-*" $option ]} {
        puts "WARN: Unsupported option '$option' specified." 
    } 
}
# CHECKING DATA GIVEN AS INPUT OR NOT
if {([string equal $dblist ""] && [string equal $inputdir ""] && [string equal $rpt_file ""] && [string equal "0" $upload_result] && [string equal "0" $upload_plan] )} {
    puts "ERROR: No input given. You must specify the input.\n"
    printHelp
    exit 2
}


# for upload result
proc upload_result_proc {upload url file_path project xmlfile sourceid upload_type comment override ivs_async} {
        if {[regexp {(\w)\s+} $comment] } {
           regsub -all {\s+} $comment {agni} comment
        }
if {($ivs_async == 0)} {
if {($upload == 1)} {
  if {(![string equal ""  $project]) && (![string equal ""  $url])} { 
     if {![string equal "" $file_path]} {
       set nrm_file [file normalize $file_path]
       if {[file exists $nrm_file]} {  
  if {[catch {exec curl --form userImage=@$file_path "$url/uploadFile?project=$project&sourceid=$sourceid&uploadtype=$upload_type&comment=$comment&override=$override"} err ]} {
               if {[string match "*success*" $err]} {

                  puts "INFO: $file_path successfully uploaded\n"
               } else {
                  puts "INFO: $file_path not uploaded."
               }
            }
         }
     } elseif {[file exists $xmlfile]} {
  if {[catch {exec curl --form userImage=@$xmlfile "$url/uploadFile?project=$project&sourceid=$sourceid&uploadtype=$upload_type&comment=$comment&override=$override"} err ]} {
          if {[string match "*success*" $err]} {
               puts "INFO: $xmlfile successfully uploaded\n"
           }  else {
             puts "INFO: $xmlfile not uploaded."
           }
        }
     } else {
        if {[string equal $file_path ""]} {
           puts "Argument -file missing. With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
        } else {
           puts "Upload Failed. Wrong args specified for upload"
        }
        exit
     }
     
  } else {
     if {([string equal $project ""] && [string equal $url ""]) || [string equal $file_path ""]} {
       puts "With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
     } elseif {[string equal $project ""]} {
       puts "Argument -project missing. With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
     } elseif {[string equal $url ""]} {
       puts "Argument -ivs_url missing. With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
     } 
   }
 }
 
} else {
  if {($upload == 1)} {
  if {(![string equal ""  $project]) && (![string equal ""  $url])} { 
     if {![string equal "" $file_path]} {
       set nrm_file [file normalize $file_path]
        if {[file exists $nrm_file]} {  
           set file_data [open "$file_path" r+]
           set data_string ""
           while {![eof $file_data]} {
              set data [gets $file_data]
              append data_string $data 
            }
              if {[catch {exec curl --form-string data=$data_string "$url/asyncResults?project=$project"} err ]} {
                  if {[string match "*success*" $err]} {

                      puts "INFO: $file_path successfully uploaded\n"
                  } else {
             #         puts $err
                      puts "INFO: $file_path not uploaded."
                  }
               }
        }
      } elseif {[file exists $xmlfile]} {
          set xml_data  [open "$xmlfile" r+]
           set data_string ""
          while {![eof $xml_data]} {
             set data [gets $xml_data]
             append data_string $data 
          }
                    if {[catch {exec curl --form-string data=<$data_string "$url/asyncResults?project=$project&resultName=$xmlfile"} err ]} {
                  if {[string match "*success*" $err]} {

                      puts "INFO: $file_path successfully uploaded\n"
                  } else {
                      #puts $err
                      puts "INFO: $file_path not uploaded."
                  }
               }
     
      } else {
        if {[string equal $file_path ""]} {
           puts "Argument -file missing. With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
        } else {
           puts "Upload Failed. Wrong args specified for upload"
        }
        exit
     }
     
  } else {
     if {([string equal $project ""] && [string equal $url ""]) || [string equal $file_path ""]} {
       puts "With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
     } elseif {[string equal $project ""]} {
       puts "Argument -project missing. With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
     } elseif {[string equal $url ""]} {
       puts "Argument -ivs_url missing. With '-uploadResult' options  \"-ivs_url <ivs_url> -project <projectname> -file <dil_name>\" options are mandatory"
     } 
   }
 }

 }

 
}


#CHECK FOR MULTIPLE INPUTS GIVEN
#########
#####
##

if {[string equal $outdir ""]} { 
    set outdir [pwd]
}

if {[string equal submit_results "1"]} {
    if {[string equal $username ""] || [string equal $password ""] || [string equal $project_name ""] \
              || [string equal $plan_name ""] || [string equal $url ""]} {
    puts {With '-submitResult' options  "-ivs <ivs_url> -u <username> -p <password> -project <projectname> -plan_name <planname>" options are mandatory.}
    }
}

#if {[string equal $upload_result "1"]} {
#    if {[string equal $project_name ""] || [string equal $url ""]} {
#debug
#puts "enter here"
#        puts {With '-uploadResult' options  "-ivs_url <ivs_url> -project <projectname>" options are mandatory.}
#        exit
#    }
#}

#---------------------------------
# FOR UPLOAD ONLY
if {[string equal $dblist ""] && [string equal $inputdir ""] && [string equal $rpt_file ""]} {
  if { [string equal "1" $upload_result]} {
      upload_result_proc $upload_result $url $file_path $project_name $xmlfile $sourceid $upload_type $comment $override $ivs_async 
      exit
   } elseif {[string equal "1" $upload_plan]} {
      upload_result_proc $upload_plan $url $file_path $project_name $xmlfile $sourceid $upload_type $comment $override $ivs_async
      exit
   } elseif {[string equal "1" $ivs_async]} {
      upload_result_proc $upload_result $url $file_path $project_name $xmlfile $sourceid $upload_type $comment $override $ivs_async
      exit
   }
} elseif {[string equal $file_path ""] && [string equal $upload_result "1"]} {
    if {[string equal $project_name ""] || [string equal $url ""]} {
      puts {With '-uploadResult' options  "-ivs_url <ivs_url> -project <projectname>" options are mandatory.}
      exit
    }
} elseif {[string equal $file_path ""] && [string equal $upload_plan "1"]} {
    if {[string equal $project_name ""] || [string equal $url ""]} {
      puts {With '-uploadPlan' options  "-ivs_url <ivs_url> -project <projectname>" options are mandatory.}
      exit
    }
}

#---------------------------------
## FOR UPLOAD PLAN
#if {[string equal $dblist ""] && [string equal $inputdir ""] && [string equal $rpt_file ""] && [string equal "1" $upload_plan]} {
#      upload_result_proc $upload_plan $url $file_path $project_name $xmlfile $sourceid
#      puts "END OF SCRIPT"
#      exit
#} elseif {[string equal $file_path ""] && [string equal $upload_plan "1"]} {
#    if {[string equal $project_name ""] || [string equal $url ""]} {
#      puts {With '-uploadPlan' options  "-ivs_url <ivs_url> -project <projectname>" options are mandatory.}
#      exit
#    }
#}

## IDENTIFY AND VALIDATE SPECIFIED DATABASE OPTIONS 
###########################################################

set DB ""
set DB1 ""
set DB2 ""
set DB3 ""
set DB4 ""
set Report ""

#DIRECTORY CONTAINING REPORTS
if {[file isdirectory $inputdir] && ($nodb == 1)} {
   regsub (/$) $inputdir "" inputdir
   set tmpF [file normalize $inputdir]
   if {[file exists $tmpF] && [file isdirectory $tmpF]} {
      set RPT $tmpF
      set MODE "synopsys"
   } else {
       puts "ERROR: Cannot find reports directory '$tmpF'. Please make sure the directory exists."
       exit 2
   }
#REPORT FILE
} elseif {[file isfile $rpt_file] && ($nodb == 1) } {
   set tmpF [file normalize $rpt_file]
   if {[file exists $tmpF]} {
      set RPT $tmpF
      set MODE "cadence"
   } else {
       puts "ERROR: Cannot find report file '$tmpF'. Please make sure the file exists."
       exit 2
   }
#} elseif {[file isfile $rpt_file] && [string equal $Report_file "test_report"] && ($nodb == 1)} {
 #  if {[string equal ".vsof" [file extension $rpt_file]]} {
#      set tmpF [file normalize $rpt_file]
#      if {[file exists $tmpF] && [file isfile $tmpF]} {
#         set RPT $tmpF
#         set MODE "cadence"
         #puts "cadence"
#       } else {
 #       puts "ERROR: Cannot find report file '$tmpF'. Please make sure the file exists."
  #      exit 2
   #    }
    #} else {
    # puts "ERROR: Invalid Test Report file '$dbfile'. Please make sure the file exists and is readable."
    # exit 2 
    #} 
  
#COVERAGE DATABASES
} else {
    foreach dbfile [split $dblist] { 
    regsub (/$) $dbfile "" dbfile
    if {[string equal "" [string trim $dbfile]]} {
       continue
    }
    #FOR MENTOR (.ucdb)
    if {[string equal ".ucdb" [file extension $dbfile]]} {
       set tmpF [file normalize $dbfile]
       if {[file exists $tmpF] && [file isfile $tmpF]} {
           set MODE "mentor"
           set DB $tmpF
       } else {
           puts "ERROR: Cannot find database file '$tmpF'. Please make sure the file exists and is readable."
           exit 2
       }  
    } elseif {[string equal ".ucis" [file extension $dbfile]]} {
       set tmpF [file normalize $dbfile]
       if {[file exists $tmpF] && [file isfile $tmpF]} {
           set MODE "mentor"
           set DB $tmpF
       } else {
           puts "ERROR: Cannot find database file '$tmpF'. Please make sure the file exists and is readable."
           exit 2
       }

    #FOR SYNOPSYS (*.vdb or .cm) 
    #Note: If .vdb directory is given to the script , it will only create the CoverGroup, Assertions and Directive data.
    #      And, if .cm directory is given to the script , it will create the Code Coverage data.
    } elseif {[string equal ".vdb" [file extension $dbfile]]} {
       set tmpF [file normalize $dbfile]
       if {[file exists $tmpF] && [file isdirectory $tmpF]} {
          set DB1 $tmpF 
          set MODE "synopsys"
       } else {
           puts "ERROR: Cannot find database file '$tmpF'. Please make sure the file exists and is readable."
           exit 2
       }
  
    } elseif {[string equal ".cm" [file extension $dbfile]]} {
       set tmpF [file normalize $dbfile]
       if {[file exists $tmpF] && [file isdirectory $tmpF]} {
          set DB2 $tmpF 
          set MODE "synopsys"
       } else {
           puts "ERROR: Cannot find database file '$tmpF'. Please make sure the file exists and is readable."
           exit 2
       }
    #FOR CADENCE (test_name) inside which *.ucd file is present.
    } elseif {[file isdirectory $dbfile]} {
       set dbfile [file normalize $dbfile]
       set tmpF [glob -directory $dbfile *.ucd]
       if {[file exists $tmpF]} {
           set DB $dbfile 
           set MODE "cadence"
       } else {
           puts "ERROR: Cannot find database file '$dbfile'. Please make sure the file exists and is readable."
           exit 2
       }
    
    } elseif {[string equal ".vsof" [file extension $dbfile]]} {
       set tmpF [file normalize $dbfile]
       if {[file exists $tmpF] && [file isfile $tmpF]} {
           set MODE "cadence"
           set Report "test_report"
           set DB4 $tmpF
       } else {
           puts "ERROR: Cannot find database file '$tmpF'. Please make sure the file exists and is readable."
           exit 2
       }
    #FOR ALDEC (test_name) functional coverage database '*.acdb'.
    } elseif {[string equal ".acdb" [file extension $dbfile]]} {
       set tmpF [file normalize $dbfile]
       if {[file exists $tmpF] && [file isfile $tmpF]} {
           set MODE "aldec"
           set DB3 $tmpF
       } else {
           puts "ERROR: Cannot find database file '$tmpF'. Please make sure the file exists and is readable."
           exit 2
       }
    } else {
           puts "WARN: Invalid coverage file '$dbfile'. Please make sure the file exists and is readable."
    }
    
 }
}

if {[string equal "" $MODE ]} {
   puts "ERROR: No valid coverage data found."
   exit 2
}
################################################

##CHECK TOOL AVAILABILITY 
set VCOVER ""
set URG ""
set ICCR ""
set IMC ""
set VSIMSA ""
set ICCRMODE "-64bit"
set IMCMODE "-64bit"
set IMC_BATCH "-exec"
if {$nodb == 0} {
   if {[string equal "mentor" $MODE]} {
       #Also check if appropriate commands are available to be executed.
       set VCOVER "vcover"
       if {[catch  {exec $VCOVER -help >& .null} msg]} {
           puts "ERROR: Executing command '$VCOVER' failed : $msg" 
           exit 3
       } else {
           logfile " - vcover found"
       }
   } elseif {[string equal "synopsys" $MODE]} {
       set URG "urg"
       #Also check if appropriate commands are available to be executed.
       if {[catch  {exec  $URG -help >& .null} msg]} {
           puts "ERROR: Executing command '$URG' failed : $msg" 
           exit 3
       } else {
           logfile " - urg found"
       }
   } elseif {[string equal "cadence" $MODE] && [string equal "" $DB4] && ($imc == 0)} {
       set ICCR "iccr"
       #Also check if appropriate commands are available to be executed.
       if {[catch  {exec  $ICCR $ICCRMODE -help >& .null} msg]} {
           puts "ERROR: Executing command '$ICCR' failed : $msg" 
           exit 3
       } else {
           logfile " - iccr found"
       }
   } elseif {[string equal "cadence" $MODE] && [string equal "" $DB4] && ($imc == 1)} {
       set IMC "imc"
       #Also check if appropriate commands are available to be executed.
       if {[catch  {exec  $IMC $IMCMODE -help >& .null} msg]} {
           puts "ERROR: Executing command '$IMC' failed : $msg" 
           exit 3
       } else {
           logfile " - imc found"
       }
	   
	   
   } elseif {[string equal "aldec" $MODE]} {
       set VSIMSA "vsimsa"
       #Also check if appropriate commands are available to be executed.
       if {[catch  {exec $VSIMSA >& .null} msg]} {
           puts "ERROR: Executing command '$VSIMSA' failed : $msg" 
           exit 3
       } else {
           logfile " - vsimsa found"
       }
   }
}
############################################################

#CREATE TEMP REPORTS DIRECTORIES 
if {[file exists $tmp_RPTDIR]} {
    puts "INFO: Report directory already exists. Storing reports in 'ivs_RPTDIR' directory"
    set tmp_RPTDIR [file join [pwd] "ivs_RPTDIR"]
   # file delete -force $tmp_RPTDIR
}
if {([file exists $tmp_HTMLPATH] && ($HREF == 1))} {
    puts "INFO: HTML Report directory already exists. Storing reports in 'ivs_HTMLDIR' directory"
    set tmp_HTMLPATH [file join [pwd] "ivs_HTMLDIR"]
    file delete -force $tmp_HTMLPATH
}
##########################################################

#Create directories
file mkdir $tmp_RPTDIR
if {($HREF == 1)} {
   file mkdir $tmp_HTMLPATH
}

#Path for XML Storage
set OUTDIR "$outdir"
if {[file isdirectory "$outdir"]} {
    logfile "\"XML file is in :-$OUTDIR\""
} elseif {[file isfile "$outdir"]} {
    puts "ERROR: Cannot create output directory '$outdir' File with same name already exists."
    exit 2
} else {
    #Directory doesnot exists. 
    puts "ERROR: '$outdir' DIRECTORY DOESNOT EXISTS."
}

set HREFPREFIX $hrefprefix
if {$HREFPREFIX != ""} {
    puts "INFO: Using '$HREFPREFIX' as html prefix for refering to html reports." 
}
##########################################################

#GENERATE OUTPUT REPORTS FOR GIVEN DATABASE
if {$nodb ==0} {
   if  {[string equal $MODE "mentor"]} {
       #for Covergroup,coverpoint,cross
       if {[catch  {exec $VCOVER report -cvg  -verbose $DB} msg]} {
           if {$verbose} {
               logfile "Found no data for Covergroup,coverpoint,cross of various instances"
           }
       } else {
           set log [open [file join $tmp_RPTDIR "coverage_rpt.txt"] w+ ]
           puts $log [exec $VCOVER report -cvg  -verbose $DB]
           logfile  "\n1. \"coverage_rpt.txt\" file created in \"$tmp_RPTDIR\" directory"
           close $log
       }
       # for Assertion
       if {[catch  {exec $VCOVER report -assert -verbose $DB} msg]} {
           logfile "Found no data for Assertion coverage"
       } else {
           set log [open [file join $tmp_RPTDIR "assertion_rpt.txt"] w+ ]
           puts $log [exec $VCOVER report -assert -verbose $DB]
           logfile "2. \"assertion_rpt.txt\" file created in \"$tmp_RPTDIR\" directory"
           close $log
       }
       # for directive
       if {[catch  {exec $VCOVER report -dir -verbose $DB} msg]} {
           logfile "Found no data for directive coverage"
       } else {
           set log [open [file join $tmp_RPTDIR "directive_rpt.txt"] w+ ]
           puts $log [exec $VCOVER report -dir -verbose $DB]
           logfile "3. \"directive_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
           close $log
       }
       # for code coverage 
       if {[catch  {exec $VCOVER report -codeAll -byinstance $DB} msg]} {
           logfile "Found no data for code coverage "
       } else {
           set log [open [file join $tmp_RPTDIR "code_coverage_rpt.txt"] w+ ]
           puts $log [exec $VCOVER report -codeAll -byinstance $DB]
           logfile "4. \"code_coverage_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
           close $log
       }
       #for tests
       if {[catch  {exec $VCOVER attribute $DB} msg]} {
           logfile "Found no data for tests coverage "
       } else {
           set log [open [file join $tmp_RPTDIR "tests_rpt.txt"] w+ ]
           puts $log [exec $VCOVER attribute $DB]
           logfile "5. \"tests_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
           close $log
       }

   } elseif {[string equal $MODE "synopsys"]} {
       set exitDB1 0
       set exitDB2 0
       #for covergroup and assertions
       if {! [string equal "" $DB1]} {
            
           logfile "\n\nCreating urgReport from:"
           logfile "\t$URG -dir $DB1 -format text"
           if {[catch  {exec $URG -dir $DB1 -format text} msg]} {
               if {[regexp -nocase ".*error.*" $msg]} {
                   puts "Error on generating reports for covergroup and assertions:  $msg"
                   set exitDB1 1
               } else {
                   # copy assertion reports
                   if {[file exists [file join urgReport "asserts.txt"]]} {
                      file copy -force [file join urgReport "asserts.txt"] [file join $tmp_RPTDIR "assertion_rpt.txt"]
                      logfile "\n1. \"assertion_rpt.txt\" file created in \"$tmp_RPTDIR\" directory"
                   }
                   # copy covergroup reports
                   if {[file exists [file join urgReport "grpinfo.txt"]]} {
                      file copy -force [file join urgReport "grpinfo.txt"] [file join $tmp_RPTDIR "coverage_rpt.txt"]
                      logfile  "2. \"coverage_rpt.txt\" file created in \"$tmp_RPTDIR\" directory"
                   }
               }
           }
       }
       # for code coverage
       if {! [string equal "" $DB2]} {
           logfile "\n\nCreating urgReport from:"
           logfile "\t$URG -dir $DB2 -format text"
           if {[catch  {exec $URG -dir $DB2 -format text} msg]} {
               if {[regexp -nocase ".*error.*" $msg]} {
                   puts "Error on generating reports for code coverage:  $msg"
                   set exitDB2 1
               } else {
                   # copy assertion reports
                   if {[file exists [file join urgReport "hierarchy.txt"]]} { 
                      file copy -force [file join urgReport "hierarchy.txt"] [file join $tmp_RPTDIR "code_coverage_rpt.txt"]
                      logfile "1. \"code_coverage_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
                   }
               }
           }
       }
       if {![string equal "" $DB1]} {
           if {[string equal "" $DB2]} {
               if {$exitDB1} {
                   exit 2
               }
           }
       } elseif {![string equal "" $DB2]} {
           if {[string equal "" $DB1]} {
               if {$exitDB2} {
                   exit 2
               }
           }
       }

   } elseif {[string equal $MODE "cadence"] && [string equal $Report ""] && ($imc == 0)} {
       if {! [string equal "" $DB]} {
           set cmdf [file join $tmp_RPTDIR "cmdfile.txt"]
           set cmdfile [open $cmdf w]
           set report_sum [file join $tmp_RPTDIR "report_summary.txt"]
           set report_detail [file join $tmp_RPTDIR "report_detail.txt"]
           puts $cmdfile "load_test $DB"
           puts $cmdfile "report_summary -instance *... >$report_sum"
           puts $cmdfile "report_detail -instance *... -all >$report_detail"
           close $cmdfile
           logfile "\n\nCreating text reports from:"
           logfile "\t $ICCR $ICCRMODE $cmdf"
           if {[catch  {exec $ICCR $ICCRMODE $cmdf} msg]} {
               if {[regexp -nocase {.*iccr:.*\*E.*} $msg]} {
                   puts "Error on generating reports for using iccr:  $msg"
                   exit 1
               } else {
                   logfile " \"report_summary.txt\" file created in \"$tmp_RPTDIR\" directory"
                   logfile  " \"report_detail.txt\" file created in \"$tmp_RPTDIR\" directory"
               }
           }
       }
    } elseif {[string equal $MODE "cadence"] && [string equal $Report ""] && ($imc == 1 )} {
       if {! [string equal "" $DB]} {
           set cmdf [file join $tmp_RPTDIR "cmdfile.txt"]
           set cmdfile [open $cmdf w]
           set report_sum [file join $tmp_RPTDIR "report_summary.txt"]
           set report_detail [file join $tmp_RPTDIR "report_detail.txt"]
           puts $cmdfile "load $DB"
           puts $cmdfile "report -summary -inst -metrics all -text -all -out $report_sum"
           puts $cmdfile "report -detail -text -metrics all -inst  -all -out $report_detail"
           close $cmdfile
           logfile "\n\nCreating text reports from:"
           logfile "\t $IMC $IMCMODE $IMC_BATCH $cmdf"
           if {[catch  {exec $IMC $IMCMODE $IMC_BATCH $cmdf} msg]} {
               if {[regexp -nocase {.*imc:.*\*E.*} $msg]} {
                   puts "Error on generating reports for using imc:  $msg"
                   exit 1
               } else {
                   logfile " \"report_summary.txt\" file created in \"$tmp_RPTDIR\" directory"
                   logfile  " \"report_detail.txt\" file created in \"$tmp_RPTDIR\" directory"
               }
           }
       }
     } elseif {[string equal $MODE "cadence"] && [string equal $Report "test_report"]} {
       if {![string equal "" $DB4]} {
           set log [open [file join $tmp_RPTDIR "tests_rpt.txt"] w+ ]
           file copy -force $DB4 [file join $tmp_RPTDIR "tests_rpt.txt"]
           logfile " \"tests_rpt.txt.txt\" file created \"$tmp_RPTDIR\" directory"

         
        }
   } elseif {[string equal $MODE "aldec"]} {
       if {! [string equal "" $DB3]} {
           set cmdf [file join $tmp_RPTDIR "cov_run.do"]
           set ccmdf [file join $tmp_RPTDIR "cc_run.do"]
           set cmdfile [open $cmdf w]
           set cov_report_sum [file join $tmp_RPTDIR "cov_summary.txt"]
             puts $cmdfile "fcover report -db $DB3 -file $cov_report_sum"
           close $cmdfile
           set cmdfile [open $ccmdf w]
           set cc_report_sum [file join $tmp_RPTDIR "cc_summary.txt"]
             puts $cmdfile "coverage report -acdb $DB3 -txt $cc_report_sum"
           close $cmdfile
           logfile "\n\nCreating text reports from:"
           logfile "\t $VSIMSA -do $cmdf"
           if {[catch  {exec $VSIMSA -do $cmdf} msg1]} { }
           logfile "\n\nCreating text reports from:"
           logfile "\t $VSIMSA -do $ccmdf"
           if {[catch  {exec $VSIMSA -do $ccmdf} msg2]} { }
           if {[regexp -nocase ".*Error:.*" $msg2] && [regexp -nocase ".*Error:.*" $msg1]} {
               puts "Error on generating reports for using 'vsimsa': \nF_COV: $msg1 \nC_COV: $msg2"
               exit 1
           }
           if {[regexp -nocase ".*Error:.*" $msg1]} {
               puts "Functional coverage reports not generated"
               logfile "Functional coverage reports not generated:  $msg1"
               logfile " \"cc_summary.txt\" file created in \"$tmp_RPTDIR\" directory"
           } elseif {[regexp -nocase ".*Error:.*" $msg2]} {
               puts "Code coverage reports not generated"
               logfile "Code coverage reports not generated:  $msg2"
               logfile " \"cov_summary.txt\" file created in \"$tmp_RPTDIR\" directory"
           } 
       }    
   }
} elseif {$nodb} {
   if {[string equal "synopsys" $MODE]} {
#        if {[file exists [file join $RPT "hierarchy.txt"]]} {
#            file copy -force [file join $RPT "hierarchy.txt"] [file join $tmp_RPTDIR "code_coverage_rpt.txt"]
#            logfile " \"code_coverage_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
#        }
        if {[file exists [file join $RPT "asserts.txt"]]} {
            file copy -force [file join $RPT "asserts.txt"] [file join $tmp_RPTDIR "assertion_rpt.txt"]
            logfile " \"assertion_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
        }
        if {[file exists [file join $RPT "grpinfo.txt"]]} {
            file copy -force [file join $RPT "grpinfo.txt"] [file join $tmp_RPTDIR "coverage_rpt.txt"]
            logfile " \"coverage_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
        }
   } elseif {[string equal "cadence" $MODE]} {
       # if {[file exists $RPT] && [string equal $Report_file "test_report"]} {
        #   file copy -force $RPT [file join $tmp_RPTDIR "tests_rpt.txt"]
         #  logfile " \"tests_rpt.txt.txt\" file created \"$tmp_RPTDIR\" directory"
         #}
        if {[file exists $RPT] } {
            file copy -force $RPT [file join $tmp_RPTDIR "coverage_rpt.txt"]
            logfile " \"coverage_rpt.txt\" file created \"$tmp_RPTDIR\" directory"
        }
   }
}
############################################################


#MAKING HTML REPORTS
if {$HREF == 1} {
   if {$nodb == 0} {
      if  {[string equal $MODE "mentor"]} {
          if  {[catch  {exec $VCOVER report -html -verbose -noframes -htmldir $tmp_HTMLPATH $DB} msg]} {
              puts "WARN: Failed to generate HTML reports."
              set HTMLERROR "1"
          } else {
              set HTMLERROR "0"
              logfile "\n\nExecuting db to html ...."
              exec $VCOVER report -html -verbose -noframes -htmldir $tmp_HTMLPATH $DB  
          }
      } elseif {[string equal $MODE "synopsys"]} {
          if {(![string equal "" $DB1]) && !($exitDB1)} {
              if  {[catch  {exec $URG -dir $DB1 -report $tmp_HTMLPATH} msg]} {
                  if {[regexp -nocase ".*error.*" $msg]} {
                      puts "WARN: Failed to generate HTML reports."
                      set HTMLERROR "1"
                  } else {
                      set HTMLERROR "0"
                      logfile "\n\nExecuted db to html ...."
                      #file delete -force "urgReport"
                  }
              }
          }
    
          if {(![string equal "" $DB2]) && !($exitDB2)} {
              if  {[catch  {exec $URG -dir $DB2 -report $tmp_HTMLPATH} msg]} {
                  if {[regexp -nocase ".*error.*" $msg]} {
                       puts "WARN: Failed to generate HTML reports."
                       set HTMLERROR "1"
                   } else {
                       set HTMLERROR "0"
                       logfile "\n\nExecuted db to html ...."
                       #file delete -force "urgReport"
                   }
               }
           }
       } elseif {[string equal $MODE "cadence"] && [string equal "" $DB4]} {
           set cmdf [file join $tmp_HTMLPATH "cmdfile.txt"]
           set cmdfile [open $cmdf w]
           set report_html [file join $tmp_HTMLPATH "report_html"]
           puts $cmdfile "load_test $DB"
           puts $cmdfile "report_html -instance *...  -output $report_html -all"
           close $cmdfile
           if {![catch  {exec $ICCR $MODE $cmdf} msg]} {
               if {[regexp -nocase {.*iccr:.*\*E.*} $msg]} {
                   puts "Error on generating html reports for using iccr:  $msg"
                   set HTMLERROR "1" 
               } else {
                   set HTMLERROR "0" 
                   logfile "\n\nExecuted db to html ...."
                   logfile  " \"report_html\" directory created in \"$tmp_HTMLPATH\" directory"
               }
           } else {
               if {[regexp -nocase {.*iccr:.*\*E.*} $msg]} {
                   puts "Error on generating html reports for using iccr:  $msg"
                   set HTMLERROR "1"
               } else {
                   set HTMLERROR "0"
                   logfile "\n\nExecuted db to html ...."
                   logfile  " \"report_html\" directory created in \"$tmp_HTMLPATH\" directory"
               }
           } 
       } elseif {[string equal $MODE "aldec"]} {
           if {! [string equal "" $DB3]} {
               set HTMLERROR 0
               set cmdf [file join $tmp_HTMLPATH "runfc_htm.do"]
               set ccmdf [file join $tmp_HTMLPATH "runcc_htm.do"]
               set cmdfile [open $cmdf w]
               set fcov_report_sum [file join $tmp_HTMLPATH "fcov_html_reports.html"]
               puts $cmdfile "fcover report -db $DB3 -file $fcov_report_sum -html"
               close $cmdfile
               set cmdfile [open $ccmdf w]
               set ccov_report_sum [file join $tmp_HTMLPATH "ccov_html_reports.html"]
               puts $cmdfile "coverage report -acdb $DB3 -html $ccov_report_sum" 
               close $cmdfile
               if {[catch  {exec $VSIMSA -do $cmdf} msg1]} {  }
               if {[catch  {exec $VSIMSA -do $ccmdf} msg2]} {  }
               if {[regexp -nocase ".*Error:.*" $msg1] && [regexp -nocase ".*Error:.*" $msg2]} {
                   puts "Error on generating reports for using vsimsa: \nF_COV: $msg1 \nC_COV: $msg2"
                   set HTMLERROR 1
               }
               if {[regexp -nocase ".*Error:.*" $msg1]} {
                   puts "Functional Coverage html reports not generated"
                   logfile "Functional Coverage html reports not generated: $msg1"
                   set HTMLERROR 0
                   logfile " \"ccov_html_reports.html\" file created in \"$tmp_HTMLPATH\" directory"
               } elseif {[regexp -nocase ".*Error:.*" $msg2]} {
                   puts "Code Coverage html reports not generated"
                   logfile "Code Coverage html reports not generated: $msg2"
                   set HTMLERROR 0
                   logfile " \"fcov_html_reports.html\" file created in \"$tmp_HTMLPATH\" directory"
               }
           }
       }
   } elseif {$nodb} {
       if {[string equal $MODE "synopsys"]} {
           if {[catch  {glob -type f [file join $RPT *{.htm}*]} msg]} {
               logfile "!! Found no htmlfile"
               set HTMLERROR "1"
           } else {
               set assert_htmlist [glob -type f [file join $RPT *{.htm}*]]
               foreach file $assert_htmlist {
                  file copy -force $file $tmp_HTMLPATH
               }
               file copy -force [file join $RPT "\.sortable.js"] $tmp_HTMLPATH
                file copy -force [file join $RPT "\.urg.css"] $tmp_HTMLPATH
               set HTMLERROR "0"
               logfile "\n\nExecuted db to html ...."
               logfile  " \"report_html\" directory created in \"$tmp_HTMLPATH\" directory"
           }
       }
   }
} else {
  set HTMLERROR 1
}   
# Start parsing data from the reports ( Stores data in form of lists from the logfiles) 
#######################################################################################################

#Initializing the variables:-
set TEST_LIST ""
set ASSERTION_LIST ""
set COVERAGE_LIST ""
set DIRECTIVE_LIST ""
set CODE_COVERAGE_LIST ""
set Test ""
set Assertion ""
set CoverGroup ""
set CoverPoint ""
set Cross ""
set CoverGroup_Instance ""
set CoverPoint_Instance ""
set Cross_Instance ""
set Directive ""
set Branch ""
set Statement ""
set Toggle ""
set Condition ""
set fsm ""
set fsm_transition ""
#set FSM_State ""
#set FSM_Transition ""
set Fec_Condition ""

#Files from where data is to be extracted for Cadence and Aldec
if {[string equal $MODE "aldec"]} {
    set fc_rpt_start 0
    set cc_rpt_start 0
    if {[file exists [file join $tmp_RPTDIR "cov_summary.txt"]]} {
        set log [open [file join $tmp_RPTDIR "cov_summary.txt"] r ]
        logfile "\n########## PARSE ALL DATA ##########"
        while {![eof $log]} {
           set parsed_line [gets $log]
           #Functional Coverage
           if [regexp "^ *FUNCTIONAL *COVERAGE: *$" $parsed_line] {
              set fc_rpt_start 1
              continue
           }
           if {$fc_rpt_start == 1} {
              #Parsing Covergroup
              if {[regexp "^.* TYPE .*$" $parsed_line]} {
                 set read_line 1
                 set type "CoverGroup"
              } elseif {[regexp "^.* COVERPOINT .*$" $parsed_line]} {
                 set type "CoverPoint"
                 set read_line 1
              } elseif {[regexp "^.* CROSS .*$" $parsed_line]} {
                 set type "Cross"
               set read_line 1
              } else {
                 set read_line 0
              }
              if {$read_line == 1} {
                 set cov_line [join [split "$parsed_line"] ]
                 set vpi_name [lindex $cov_line 2]
                 if {[regexp {^[a-z]+..*::\\[0-9]+.*$} $vpi_name]} {
                    set remove_ele_index [expr [string length $vpi_name] - 2]
                    set vpi_name [string replace $vpi_name $remove_ele_index $remove_ele_index ]
                    set cov_line [lreplace  $cov_line 3 3]
                 }
                 set vpi_value [lindex $cov_line 4]
                 set vpi_value [string trimright $vpi_value "%"]
                 set cov_list $vpi_name
                 lappend cov_list $vpi_value
                 lappend cov_list $type
                 lappend COVERAGE_LIST $cov_list
                 logfile "\"$type\" variable append with $vpi_name"
              }
           }
        }
     } 
     if {[file exists [file join $tmp_RPTDIR "cc_summary.txt"]]} {
        set log [open [file join $tmp_RPTDIR "cc_summary.txt"] r ]
        logfile "\n########## PARSE ALL DATA ##########"
        set inst_start 0
        set statement_val 0
        set branch_val 0
        while {![eof $log]} {
           set parsed_line [gets $log]
           if {[regexp "^#\\s*HIERARCHY\\s*$" $parsed_line]} {
               set cc_rpt_start 1
               continue
           } elseif {[regexp "^#\\s*UNITS\\s*$" $parsed_line]} {
               set cc_rpt_start 0
           }
           if {$cc_rpt_start == 1} {
               if {[regexp "^#\\s*Instance.*$" $parsed_line]} {
                  set inst_start 1
               }
           } else {
               set inst_start 0
           }
           if {$inst_start == 1} {
               #Parsing Coverage Data
               if {[regexp "^\\s*\/\\s*:.*$" $parsed_line]} {
                   set inst_start 0
                   continue
               } elseif {[regexp "^\\s*/\[a-z\]+.*:.*$" $parsed_line]} {
                   set vpi_line [join [split $parsed_line ]]
                   set vpi_name_cc [lindex $vpi_line 0]
               } elseif {[regexp "^\\s*#\\s*Hits/Statements=Percent.*$" $parsed_line]} {
                   set statement_val 1
               } elseif {[regexp "^\\s*#\\s*Hits/Branches=Percent.*$" $parsed_line]} {
                   set branch_val 1
               }
               #Collecting Value 
               if {$statement_val == 1} {
                   if {![regexp "^\\s*#.*$" $parsed_line]} {
                       set statement_val 0
                       set statement_line [join [split $parsed_line ]]
                       regsub {[0-9]+/[0-9]+=} [lindex $statement_line end] "" st_value
                       set st_value [string trim $st_value "%"]
                       set Statement $vpi_name_cc
                       lappend Statement "$st_value"
                       lappend Statement "Statement"
                       lappend Statement_list $Statement
                       lappend CODE_COVERAGE_LIST $Statement
                       logfile "\"$Statement\" variable append with $vpi_name_cc"
                   }
               } elseif {$branch_val == 1} {
                   if {![regexp "^\\s*#.*$" $parsed_line]} {
                       set branch_val 0
                       set branch_line [join [split $parsed_line ]]
                       regsub {[0-9]+/[0-9]+=} [lindex $branch_line end] "" br_value
                       set br_value [string trim $br_value "%"]
                       set Branch $vpi_name_cc
                       lappend Branch "$br_value"
                       lappend Branch "Branch"
                       lappend Branch_list $Branch
                       lappend CODE_COVERAGE_LIST $Branch
                       logfile "\"Branch\" variable append with $vpi_name_cc"
                   }
              }
           }
        }
     }
}



#Changing Grade to Percent value(e.g 0.73 changes to 73%)
proc grad_2_prcnt {grade} {
   set percent ""
   if {[string equal "1.00" $grade]} {
      set percent 100
   } else {
      regsub {0\.} $grade "" grade
      set percent [string replace $grade 0 1 "[string range $grade 0 1]\."]
      if {[regexp {^[0-9]+\. *$} $percent]} {
         regsub {\.} $percent "" percent
      }
   }

if { $percent == 00} {
    set percent 0
  } 
if {[regexp {^[0-9]+\.0$} $percent]} {
        regsub {\.0} $percent "" percent
      } 
   return $percent
}

if  {[string equal $MODE "cadence"] && ($nodb == 0) && [string equal $Report ""]} {
    set rpt_start 0
    if {[file exists [file join $tmp_RPTDIR "report_summary.txt"]]} {
        set log [open [file join $tmp_RPTDIR "report_summary.txt"] r ]
        logfile "\n########## PARSE ALL DATA ##########"
        while {![eof $log]} {
           set parsed_line [gets $log]
           if [regexp "^.*Coverage Summary Report.*$" $parsed_line] {
              set rpt_start 1
              continue
           }
           if {$rpt_start == 1} {
              if {[regexp "^.*=.*$" $parsed_line] || [regexp "^ *$" $parsed_line]} {
                 continue
              }
              #VPI NAME
              if {[regexp {^\s*\:[\w]+\s*$} $parsed_line]} {
                  set parsed_line [join $parsed_line]
                  regsub {\:[\w]+$} $last_vpiname $parsed_line vpiname
              } elseif {[regexp {^\s*[\w]+[\w:]*\s*$} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set vpiname $parsed_line
                 set last_vpiname $vpiname
              } elseif {[regexp {^\s*\.[\w]+\s*$} $parsed_line]} {
                  set parsed_line [join $parsed_line]
                  regsub {\.[\w]+$} $last_vpiname $parsed_line vpiname
              } elseif {[regexp {^\s*[\w]+[\w.]*\s*$} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set vpiname $parsed_line
                 set last_vpiname $vpiname
              } elseif {[regexp {^\s*[\w]+\s*$} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set vpiname $parsed_line
                 set last_vpiname $vpiname
              #Statement=(BC) in report
              } elseif {[regexp {.*BC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname 
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Statement"
                 lappend Statement $tmp_vpiname 
                 lappend CODE_COVERAGE_LIST $tmp_vpiname 
                 logfile "\"Statement\" variable append with $tmp_vpiname"
              #Branch=(BRC) in report
              } elseif {[regexp {.*BRC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname 
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Branch"
                 lappend Branch $tmp_vpiname 
                 lappend CODE_COVERAGE_LIST $tmp_vpiname 
                 logfile "\"Branch\" variable append with $tmp_vpiname"
              #Expression=(EC) in report
              } elseif {[regexp {.*EC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname 
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Expression"
                 lappend Expression $tmp_vpiname 
                 lappend CODE_COVERAGE_LIST $tmp_vpiname 
                 logfile "\"Expression\" variable append with $tmp_vpiname"
              #Toggle=(TFC) in report
              } elseif {[regexp {.*TFC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname 
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Toggle"
                 lappend Toggle $tmp_vpiname 
                 lappend CODE_COVERAGE_LIST $tmp_vpiname 
                 logfile "\"Toggle\" variable append with $tmp_vpiname"
              #FSM State=(SC) in report
              } elseif {[regexp {.*SC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname 
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "fsm"
				 #lappend tmp_vpiname "FSM_State"
                 lappend fsm $tmp_vpiname
                 #lappend FSM_State $tmp_vpiname				 
                 lappend CODE_COVERAGE_LIST $tmp_vpiname 
				 logfile "\"fsm\" variable append with $tmp_vpiname"
                 #logfile "\"FSM_State\" variable append with $tmp_vpiname"
              #FSM Transition=(TRC) in report
              } elseif {[regexp {.*TRC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname 
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "FSM_trans"
                 lappend FSM_trans $tmp_vpiname 
                 lappend CODE_COVERAGE_LIST $tmp_vpiname 
                 logfile "\"FSM_trans\" variable append with $tmp_vpiname"
              #Assertion=(FC) in report
              #} elseif {[regexp {.*FC:\s+[0-9]+%.*} $parsed_line]} {
               #  set parsed_line [join $parsed_line]
                # set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 #regsub {%$} $value "" value
                 #set tmp_vpiname $vpiname 
                 #if {$value != 100} {
                  #  set value "fail"
                 #} else {
                 #   set value "pass"
                # }
               #  lappend tmp_vpiname "$value"
               #  lappend tmp_vpiname "Assertion"
               #  lappend Assertion $tmp_vpiname 
               #  lappend ASSERTION_LIST $tmp_vpiname 
              #   logfile "\"Assertion\" variable append with $tmp_vpiname"
              #CoverGroup=(DC) in report
             # } elseif {[regexp {.*DC:\s+[0-9]+%.*} $parsed_line]} {
                # set parsed_line [join $parsed_line]
                 #set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 #regsub {%$} $value "" value
                 #set tmp_vpiname $vpiname 
                # lappend tmp_vpiname "$value"
                 #lappend tmp_vpiname "CoverGroup"
                 #lappend CoverGroup $tmp_vpiname 
                # lappend COVERAGE_LIST $tmp_vpiname 
               #  logfile "\"CoverGroup\" variable append with $tmp_vpiname"
              }
           }
        }
        close $log
    }

####for functional coverage###
  proc line2list {got ret} {
   upvar $ret my_lst
   set extract [split $got]
        set my_lst {}
        foreach element $extract {
            if {$element!=""} {
              lappend my_lst $element
           }
         }

  }
 
set assert_found 0
set coverage_found 0
set count 0

  if {[file exists [file join $tmp_RPTDIR "report_detail.txt"]] && ($imc == 1)} {
        set log2 [open [file join $tmp_RPTDIR "report_detail.txt"] r ]
        logfile "\n########## PARSE ALL DATA ##########"
        while {![eof $log2]} {
        set line [gets $log2]       
        #### searching for "contol-oriented" hading
       if {[regexp ".*Control-oriented.*" $line]==1} {
           set coverage_found 0
           lappend match_list $line
           incr count
           set assert_found 1
           set type_assert "Assertion"
        }

        #### searching for "data-oriented" hading
       if {[regexp ".*Data-oriented.*" $line] ==1 || [regexp ".*CoverGroup Detail Report.*" $line] ==1 } {
         set assert_found 0
         lappend match_list $line
         incr count
         set coverage_found 1
       }
        
       ####  for diffrent instance name under same "control-oriented" hading
       if {$assert_found==2 & [regexp "Instance name" $line]==1} {
          set assert_found 1
        }


      #### extracting instance name
      if {$assert_found==1 & [regexp "Instance name" $line]==1} {
              set path_extract [split $line]
              set path_assert [lindex $path_extract end]
              set assert_found 2
       }

       ####  extracting indexes
       if {$assert_found==2 & [regexp "cnt            coverage point  line origin description" $line]==1} {
                set lst {}
                line2list $line lst
                set value_index_assert [lsearch $lst "cnt"]
                set name_index_assert [lsearch $lst "coverage"]
                set assert_found 3
       }
       
       set lst {}
       line2list $line lst
       if {$assert_found==4 & [llength $lst]==0} {set assert_found 1}

       if {$assert_found==4} {
               set lst {}
                line2list $line lst
                set name_assert [lindex $lst $name_index_assert]
                set value_assert [lindex $lst $value_index_assert]
                if { $value_assert==0} {
                  set assert_status "Fail"
                } else {
                  set assert_status "Pass"
                }
                set assert_list "$path_assert.$name_assert $assert_status $type_assert"
                lappend Assertion $assert_list
                lappend ASSERTION_LIST $assert_list
        }    

       if {$assert_found==3 & [string match "--------------*" $line]==1} {
          set assert_found 4
        }

      #######  assertion code ends
      #######  coverage code starts
      ####  for diffrent instance name under same "Date-oriented" hading
#set name_covergroup_cover ""
      if {$coverage_found!=0 & [regexp "Instance name:" $line]==1} { set coverage_found 1 }

      ####  extracting instance name

      if {$coverage_found==1 & [regexp "Instance name" $line]==1} {
          set path_extract [split $line]
          set path_cover [lindex $path_extract end]
          set coverage_found 2
        }

   if {$coverage_found==2 & ([regexp "Number of covered bins:" $line]==1 || [regexp "Number of covered cover bins:" $line] ==1 )} {set coverage_found 3  }
       
   if {$coverage_found==3 & [regexp "Coverage           Count      Name                                Line Origin" $line]==1 || [regexp "Name                           Average, Covered Grade         Line  Source Code" $line] ==1}  {set coverage_found 4}

    ####  for diffrent covergroup within same instance hading
    set lst {}
    line2list $line lst
    if {$coverage_found>5 & [regexp {\|+.*} $lst] ==0} {set coverage_found 5}
     set count_coverpoint_coverage 1
     ####  for avoiding bins
     if {$coverage_found==6} {
        set sub_string [string range $line 0 9]
        if {$sub_string=="          "} {
           set count_coverpoint_coverage 1
         } else {
           set count_coverpoint_coverage 0
         }
      }

      ####  extracting coverpoint and cross
     if {$coverage_found==6 & $count_coverpoint_coverage==0} {
	  if {[regexp {\s*\|\s*\|+.*} $line]} { continue 
	  } else {
         set lst {}
         line2list $line lst
     #    set name_coverpoint_cover [lindex $lst 0]
	     set name_coverpoint_cover [lindex [ split [lindex $lst 0] "-" ] end]
 #        set value_coverpoint_cover [expr round([lindex $lst 0] * 100)]
        # set value_coverpoint_cover [expr round([lindex $lst 0] * 100)]
		  regsub {%$} [lindex $lst 1] "" value_coverpoint_cover
         if {[regexp ": cross" $line]==1} {
             set cover_list "$path_cover.$name_covergroup_cover.$name_coverpoint_cover $value_coverpoint_cover Cross"
             lappend Cross $cover_list
         } else {
             set cover_list "$path_cover.$name_covergroup_cover.$name_coverpoint_cover $value_coverpoint_cover Coverpoint"
			 
             lappend CoverPoint $cover_list
         }
         
         lappend COVERAGE_LIST $cover_list
      }
}
     ####  extracting covergroup
    set lst {}
    line2list $line lst
    if {$coverage_found==5 & [llength $lst]!=0} {
       set lst {}
       line2list $line lst
       set name_covergroup_cover [lindex $lst 3]
	   set name_covergroup_cover [lindex $lst 0]
       regsub {%\,$} [lindex $lst 1] "" value_covergroup_cover
	
       set cover_list "$path_cover.$name_covergroup_cover $value_covergroup_cover covergroup"
       lappend CoverGroup $cover_list
       lappend COVERAGE_LIST $cover_list
       set count_coverpoint_coverage 0
       set coverage_found 6

    }
     if {$coverage_found==4 & [string match "---------*" $line]==1}  {
        set coverage_found 5
      }

     }
    close $log2
 


 } elseif {[file exists [file join $tmp_RPTDIR "report_detail.txt"]]} {
        set log2 [open [file join $tmp_RPTDIR "report_detail.txt"] r ]
        logfile "\n########## PARSE ALL DATA ##########"
        while {![eof $log2]} {
        set line [gets $log2]

       
        #### searching for "contol-oriented" hading
       if {[regexp ".*Control-oriented.*" $line]==1} {
           set coverage_found 0
           lappend match_list $line
           incr count
           set assert_found 1
           set type_assert "Assertion"
        }

        #### searching for "data-oriented" hading
       if {[regexp ".*Data-oriented.*" $line]==1} {
         set assert_found 0
         lappend match_list $line
         incr count
         set coverage_found 1
       }
        
       ####  for diffrent instance name under same "control-oriented" hading
       if {$assert_found==2 & [regexp "Instance name" $line]==1} {
          set assert_found 1
        }


      #### extracting instance name
      if {$assert_found==1 & [regexp "Instance name" $line]==1} {
              set path_extract [split $line]
              set path_assert [lindex $path_extract end]
              set assert_found 2
       }

       ####  extracting indexes
       if {$assert_found==2 & [regexp "cnt            coverage point  line origin description" $line]==1} {
                set lst {}
                line2list $line lst
                set value_index_assert [lsearch $lst "cnt"]
                set name_index_assert [lsearch $lst "coverage"]
                set assert_found 3
       }
       
       set lst {}
       line2list $line lst
       if {$assert_found==4 & [llength $lst]==0} {set assert_found 1}

       if {$assert_found==4} {
               set lst {}
                line2list $line lst
                set name_assert [lindex $lst $name_index_assert]
                set value_assert [lindex $lst $value_index_assert]
                if { $value_assert==0} {
                  set assert_status "Fail"
                } else {
                  set assert_status "Pass"
                }
                set assert_list "$path_assert.$name_assert $assert_status $type_assert"
                lappend Assertion $assert_list
                lappend ASSERTION_LIST $assert_list
        }    

       if {$assert_found==3 & [string match "--------------*" $line]==1} {
          set assert_found 4
        }

      #######  assertion code ends
      #######  coverage code starts
      ####  for diffrent instance name under same "Date-oriented" hading

      if {$coverage_found!=0 & [regexp "Instance name:" $line]==1} { set coverage_found 1}

      ####  extracting instance name

      if {$coverage_found==1 & [regexp "Instance name" $line]==1} {
          set path_extract [split $line]
          set path_cover [lindex $path_extract end]
          set coverage_found 2
        }

   if {$coverage_found==2 & [regexp "Number of covered bins:" $line]==1} {set coverage_found 3}

   if {$coverage_found==3 & [regexp "Coverage           Count      Name                                Line Origin" $line]==1}  {set coverage_found 4}

    ####  for diffrent covergroup within same instance hading
    set lst {}
    line2list $line lst
    if {$coverage_found>5 & [llength $lst]==0} {set coverage_found 5}
     set count_coverpoint_coverage 1
     ####  for avoiding bins
     if {$coverage_found==6} {
        set sub_string [string range $line 0 9]
        if {$sub_string=="          "} {
           set count_coverpoint_coverage 1
         } else {
           set count_coverpoint_coverage 0
         }
      }
      ####  extracting coverpoint and cross
     if {$coverage_found==6 & $count_coverpoint_coverage==0} {
         set lst {}
         line2list $line lst
         set name_coverpoint_cover [lindex $lst 3]
         set value_coverpoint_cover [expr round([lindex $lst 0] * 100)]
         if {[regexp ": cross" $line]==1} {
             set cover_list "$path_cover.$name_coverpoint_cover $value_coverpoint_cover Cross"
             lappend Cross $cover_list
         } else {
             set cover_list "$path_cover.$name_coverpoint_cover $value_coverpoint_cover Coverpoint"
             lappend CoverPoint $cover_list
         }
         
         lappend COVERAGE_LIST $cover_list
      }

     ####  extracting covergroup
     set lst {}
     line2list $line lst
     if {$coverage_found==5 & [llength $lst]!=0} {
        set lst {}
        line2list $line lst
        set name_covergroup_cover [lindex $lst 3]
        set value_covergroup_cover [expr round([lindex $lst 0] * 100)]
        set cover_list "$path_cover.$name_covergroup_cover $value_covergroup_cover covergroup"
        lappend CoverGroup $cover_list
        lappend COVERAGE_LIST $cover_list
        set count_coverpoint_coverage 0
        set coverage_found 6

     }
     if {$coverage_found==4 & [string match "---------*" $line]==1}  {
        set coverage_found 5
      }

     }
    close $log2
  }

  
  
 #Parsing of Specman Coverage File
} elseif {[string equal $MODE "cadence"] && ($nodb == 1) } {
    set rpt_start 0
    set cvr_grp_set 0
    set cross_setup 0
    set covpt_setup 0
    
    if {[file exists [file join $tmp_RPTDIR "coverage_rpt.txt"]]} {
        set log [open [file join $tmp_RPTDIR "coverage_rpt.txt"] r ]
        logfile "\n########## PARSE SPECMAN DATA ##########"
        while {![eof $log]} {
           set parsed_line [gets $log]
           if [regexp "^.*Specman Coverage report.*$" $parsed_line] {
              set rpt_start 1
              continue
           }
           if {$rpt_start == 1} {
              if {[regexp {^ *Cover group:.*$} $parsed_line]} {
                 set cvr_grp_set 1
                 regsub {^ *Cover group: *} $parsed_line "" covgrp_name
                 regsub {^ *} $covgrp_name "" covgrp_name
                 regsub { *$} $covgrp_name "" covgrp_name
                 # 'a_ b', 'a _b', 'a b' are changed to 'a.b'.
                 if {[regexp ".*(_*|_+|.*) +(_*|_+).*" $covgrp_name]} {
                    regsub -all {_* +_+} $covgrp_name "." covgrp_name
                    regsub -all {_+ +_*} $covgrp_name "." covgrp_name
                    regsub -all {(\.|:)* +} $covgrp_name "\." covgrp_name
                    regsub -all {_+} $covgrp_name "_" covgrp_name
                 }
              } elseif {[regexp {^ *==+ *$} $parsed_line] && ($cvr_grp_set == 1)} {
                 if {[regexp {\(.*==.*\)} $covgrp_name]} {
                    regsub {\(} $covgrp_name "." covgrp_name
                    regsub {==} $covgrp_name "-" covgrp_name
                    regsub {\)} $covgrp_name "." covgrp_name
                 }
                 if {[regexp {\.$} $covgrp_name]} {
                    regsub {\.$} $covgrp_name "" covgrp_name 
                 }
                 set cvr_grp_set 0
                 set tmp_covgrp_name $covgrp_name
              } elseif {$cvr_grp_set == 1} {
                 regsub {^ *} $parsed_line "" parsed_line
                 regsub { *$} $parsed_line "" parsed_line
                 append covgrp_name $parsed_line
                 # 'a_ b', 'a _b', 'a b' are changed to 'a.b'.
                 if {[regexp ".*(_*|_+|.*) +(_*|_+).*" $covgrp_name]} {
                    regsub -all {_* +_+} $covgrp_name "." covgrp_name
                    regsub -all {_+ +_*} $covgrp_name "." covgrp_name
                    regsub -all {(\.|:)* +} $covgrp_name "\." covgrp_name
                    regsub -all {_+} $covgrp_name "_" covgrp_name
                 }
              } elseif {[regexp {^ *Grade: .*} $parsed_line]} {
                 set covgrp_value [join [split $parsed_line]]
                 set covgrp_value [lindex $covgrp_value 1]
                 set covgrp_value [grad_2_prcnt $covgrp_value]
                 lappend covgrp_name $covgrp_value
                 lappend covgrp_name "CoverGroup"
                 lappend CoverGroup $covgrp_name
                 lappend COVERAGE_LIST $covgrp_name
              } elseif {[regexp {^ *\*\*(\*)* .* \*\*(\*)* *$} $parsed_line]} {
                 regsub -all {(\*\*)} $parsed_line "" parsed_line
                 regsub {^ +} $parsed_line "" parsed_line
                 regsub { +$} $parsed_line "" parsed_line
                 regsub -all {_+ +_*} $parsed_line "_" parsed_line 
                 if {[regexp {^( *)(.* *\( *)*cross( *|_+)} $parsed_line]} {
                    regsub { *\( *cross .*,.* *\) *} $parsed_line "" cross_name
                    set cross_name "$tmp_covgrp_name.$cross_name"
                    set cross_setup 1
                 } else {
                    set covpt_name "$tmp_covgrp_name.$parsed_line"
                    set covpt_setup 1
                 }
              } elseif {[regexp {^.*Grade: .*$} $parsed_line] && (($cross_setup == 1) || ($covpt_setup == 1))} {
                    set grade_idx [string first "Grade:" $parsed_line 0]
                    set last_idx [expr $grade_idx + 10]
                    set cov_val [string range $parsed_line $grade_idx $last_idx]
                    set cov_val [split $cov_val]
                    set cov_val [lindex $cov_val 1]
                    set cov_val [grad_2_prcnt $cov_val]
                    if {$cross_setup == 1} {
                       lappend cross_name $cov_val
                       lappend cross_name "Cross"
                       lappend Cross $cross_name
                       lappend COVERAGE_LIST $cross_name
                       set cross_setup 0
                    } elseif {$covpt_setup == 1} {
                       lappend covpt_name $cov_val
                       lappend covpt_name "CoverPoint"
                       lappend CoverPoint $covpt_name
                       lappend COVERAGE_LIST $covpt_name
                       set covpt_setup 0
                    }
              }
           }
        }
    }
} elseif {[string equal $MODE "cadence"] && ($nodb == 0) && [string equal $Report "test_report"]} {
  set log_test [open [file join $tmp_RPTDIR "tests_rpt.txt"] r ]
  logfile "\n\n########## VSOF TESTS DATA ##########"
  set tmp_testname ""
  set metric_testname ""
  set testname_list ""
  set rpt_start_test 0
  set extend 0
  set run_exist 0
  set metric_exist 0
  set DB6 ""
  set DB7 ""
  while {![eof $log_test]} {
     set parsed_line_test [gets $log_test]
     if {[regexp {.*original_session_dir:\s+\"(.*)\"} $parsed_line_test]} {
     regexp {.*original_session_dir:\s+\"(.*)\"} $parsed_line_test all first1
     set local_log $first1
     }
     if {[regexp {.*run\s+[0-9]+\s+\{.*} $parsed_line_test]} {
           regexp {.*run\s+([0-9]+)\s+.*} $parsed_line_test all run_name
        set run_name "run_$run_name"
        set rpt_start_test 1
        continue
      }
     if {[regexp {.*extend\s+[0-9]} $parsed_line_test]} {
         set extend 1
         continue
      }
      if {$extend ==1} {
         if {[regexp {.*run_id\s+:\s+[0-9]+.*} $parsed_line_test]} {
          regexp {.*run_id\s+:\s+([0-9]+).*} $parsed_line_test all run_id
          set run_id $run_id
          set run_exist 1
          }
         if {[regexp {.*ucd_file\s+:\s+\<[a-z]+\>(.*)\<\/[a-z]+\>\;} $parsed_line_test]} {
            regexp {.*ucd_file\s+:\s+\<[a-z]+\>(.*)\<\/[a-z]+\>\;} $parsed_line_test all ucd_file
            if {[regexp {.*\$[A-Z]+.*} $ucd_file]} {
            set ucd_log_file [split $ucd_file "/"]
            set ucd_log_file [lreplace $ucd_log_file 0 0]
            set ucd_log_file [join $ucd_log_file "/"]
            set local_ucd_file "$local_log/$ucd_log_file"
            set local_ucd_file [file normalize $local_ucd_file]
            set local_ucd_dir [split $local_ucd_file "/"]
            set local_ucd_dir [lreplace $local_ucd_dir end end]
            set local_ucd_dir [join $local_ucd_dir "/"]
            } else {
            set local_ucd_file "$ucd_file"
            set local_ucd_file [file normalize $local_ucd_file]
            set local_ucd_dir [split $local_ucd_file "/"]
            set local_ucd_dir [lreplace $local_ucd_dir end end]
            set local_ucd_dir [join $local_ucd_dir "/"]
            }
           if {$merge_ucd ==1 } {
             set ucd [glob -nocomplain -directory $local_ucd_dir *.ucd]
             if {[file exists $ucd]} {
               #####DB6 contains all the ucd database name extracted from the vsof file###########
               lappend DB6 $local_ucd_dir
               #set MODE "cadence"
             } else {
                puts "ERROR: Cannot find database file '$local_ucd_file'. Please make sure the file exists and is readable."
                #  exit 2
             }
           } else {
              if {$run_dir ==1 } {
                if {[string equal $db_single ""] } {
                   puts "ERROR: No ucd input given. You must specify the input after option '-run_dir'.\n"
                  # printHelp
                   exit 2
                   } else {
                   set db_single [file normalize $db_single]
                   set tmpF [glob -nocomplain -directory $db_single *.ucd]
                   if {[file exists $tmpF]} {
                      set DB7 $db_single
                   } else {
                       puts "ERROR: Cannot find database file '$db_single'. Please make sure the file exists and is readable."
                       exit 2
                   } 
                }    
             } else {
              puts "ERROR:  Specify either options '-merge' or '-run_dir'."
              exit 2
           }

          }  
     ######check tool avaialbility##############################
           set ICCR "iccr"
            #Also check if appropriate commands are available to be executed.
           if {[catch  {exec  $ICCR $ICCRMODE -help >& .null} msg]} {
            puts "ERROR: Executing command '$ICCR' failed : $msg"
            exit 3
           } else {
            logfile " - iccr found"
           }
     ############################################################

     #CREATE TEMP REPORTS DIRECTORIES
      if {[file exists $tmp_RPTDIR]} {
        # puts "INFO: Report directory already exists. Storing reports in 'ivs_RPTDIR' directory"
         set tmp_RPTDIR [file join [pwd] "ivs_RPTDIR"]
       # file delete -force $tmp_RPTDIR
      }
      if {([file exists $tmp_HTMLPATH] && ($HREF == 1))} {
        # puts "INFO: HTML Report directory already exists. Storing reports in 'ivs_HTMLDIR' directory"
         set tmp_HTMLPATH [file join [pwd] "ivs_HTMLDIR"]
         file delete -force $tmp_HTMLPATH
      }
     ##########################################################
     #Create directories
   file mkdir $tmp_RPTDIR
    if {($HREF == 1)} {
     file mkdir $tmp_HTMLPATH
    }

    #Path for XML Storage
    set OUTDIR "$outdir"
    if {[file isdirectory "$outdir"]} {
      logfile "\"XML file is in :-$OUTDIR\""
    } elseif {[file isfile "$outdir"]} {
         puts "ERROR: Cannot create output directory '$outdir' File with same name already exists."
         exit 2
    } else {
    #Directory doesnot exists.
       puts "ERROR: '$outdir' DIRECTORY DOESNOT EXISTS."
    }

    set HREFPREFIX $hrefprefix
    if {$HREFPREFIX != ""} {
       puts "INFO: Using '$HREFPREFIX' as html prefix for refering to html reports."
     }
    ##########################################################
    ##GENERATE OUTPUT REPORT FOR DATABASE POINTED BY .VSOF FILE
    set cmdf [file join $tmp_RPTDIR "cmdfile.txt"]
           set cmdfile [open $cmdf w]
           set report_sum [file join $tmp_RPTDIR "report_summary.txt"]
           set report_detail [file join $tmp_RPTDIR "report_detail.txt"]
           if {$merge_ucd ==1 } {
                
             #puts "$DB6***"
           set report_merge [file join $tmp_RPTDIR "merge"]
             puts $cmdfile "set_merge -union"
             puts $cmdfile "merge $DB6 -message -output $report_merge"
             puts $cmdfile "load_test $report_merge"
           puts $cmdfile "report_summary -instance *... >$report_sum"
           puts $cmdfile "report_detail -instance *... -all >$report_detail"
           close $cmdfile
           } elseif {$run_dir ==1 } {
              puts $cmdfile "load_test $DB7"
           puts $cmdfile "report_summary -instance *... >$report_sum"
           puts $cmdfile "report_detail -instance *... -all >$report_detail"
           close $cmdfile            
           }
          
           logfile "\n\nCreating text reports from:"
           logfile "\t $ICCR $ICCRMODE $cmdf"
           if {[catch  {exec $ICCR $ICCRMODE $cmdf} msg]} {
               if {[regexp -nocase {.*iccr:.*\*E.*} $msg]} {
                   puts "Error on generating reports for using iccr:  $msg"
                  # exit 1
               } else {
                   logfile " \"report_summary.txt\" file created in \"$tmp_RPTDIR\" directory"
                   logfile  " \"report_detail.txt\" file created in \"$tmp_RPTDIR\" directory"
               }
           }

        if {$HREF==1} {
           set cmdf [file join $tmp_HTMLPATH "cmdfile.txt"]
           set cmdfile [open $cmdf w]
           set report_html [file join $tmp_HTMLPATH "report_html"]
           if {$merge_ucd ==1 } {
           set report_merge [file join $tmp_RPTDIR "merge"]
             puts $cmdfile "set_merge -union"
             puts $cmdfile "merge $DB6 -message -output $report_merge"
             puts $cmdfile "load_test $report_merge"
           puts $cmdfile "report_html -instance *... -output $report_html -all"
           close $cmdfile
           } elseif {$run_dir ==1 } {
              puts $cmdfile "load_test $DB7"
           puts $cmdfile "report_html -instance *... -output $report_html -all"
           close $cmdfile
           }  
           #puts $cmdfile "report_html -instance *...  -output $report_html -all"
           #close $cmdfile
           ######
           if {![catch  {exec $ICCR $ICCRMODE $cmdf} msg]} {
               if {[regexp -nocase {.*iccr:.*\*E.*} $msg]} {
                   puts "Error on generating html reports for using iccr:  $msg"
                   set HTMLERROR "1"
               } else {
                   set HTMLERROR "0"
                   logfile "\n\nExecuted db to html ...."
                   logfile  " \"report_html\" directory created in \"$tmp_HTMLPATH\" directory"
               }
           } else {
               if {[regexp -nocase {.*iccr:.*\*E.*} $msg]} {
                   puts "Error on generating html reports for using iccr:  $msg"
                   set HTMLERROR "1"
               } else {
                   set HTMLERROR "0"
                   logfile "\n\nExecuted db to html ...."
                   logfile  " \"report_html\" directory created in \"$tmp_HTMLPATH\" directory"
               }
           }

        } else {
          set HTMLERROR 1
        }

        # Start parsing data from the reports ( Stores data in form of lists from the logfiles)
  #######################################################################################################

  #Initializing the variables:-
#  set TEST_LIST ""
  set ASSERTION_LIST ""
  set COVERAGE_LIST ""
  set DIRECTIVE_LIST ""
  set CODE_COVERAGE_LIST ""
 # set Test ""
  set Assertion ""
  set CoverGroup ""
  set CoverPoint ""
  set Cross ""
  set CoverGroup_Instance ""
  set CoverPoint_Instance ""
  set Cross_Instance ""
  set Directive ""
  set Branch ""
  set Statement ""
  set Toggle ""
  set Condition ""
  set fsm ""
  set fsm_transition ""
  #set FSM_State ""
  #set FSM_Transition ""
  set Fec_Condition ""
   
  #Changing Grade to Percent value(e.g 0.73 changes to 73%)
  proc grad_2_prcnt {grade} {
    set percent ""
    if {[string equal "1.00" $grade]} {
       set percent 100
     } else {
       regsub {0\.} $grade "" grade
       set percent [string replace $grade 0 1 "[string range $grade 0 1]\."]
       if {[regexp {^[0-9]+\. *$} $percent]} {
          regsub {\.} $percent "" percent
        }
     }

    if { $percent == 00} {
      set percent 0
    }
    if {[regexp {^[0-9]+\.0$} $percent]} {
         regsub {\.0} $percent "" percent
     }
      return $percent
   }
  ####end of proc######
   set rpt_start 0
    if {[file exists [file join $tmp_RPTDIR "report_summary.txt"]]} {
        set log [open [file join $tmp_RPTDIR "report_summary.txt"] r ]
        logfile "\n########## PARSE ALL DATA ##########"
        while {![eof $log]} {
           set parsed_line [gets $log]
           if [regexp "^.*Coverage Summary Report.*$" $parsed_line] {
              set rpt_start 1
              continue
           }
           if {$rpt_start == 1} {
              if {[regexp "^.*=.*$" $parsed_line] || [regexp "^ *$" $parsed_line]} {
                 continue
              }

              #VPI NAME
              if {[regexp {^\s*\:[\w]+\s*$} $parsed_line]} {
                  set parsed_line [join $parsed_line]
                  regsub {\:[\w]+$} $last_vpiname $parsed_line vpiname
              } elseif {[regexp {^\s*[\w]+[\w:]*\s*$} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set vpiname $parsed_line
                 #set vpiname "run_$run_id:$vpiname"
                 set last_vpiname $vpiname
              } elseif {[regexp {^\s*\.[\w]+\s*$} $parsed_line]} {
                  set parsed_line [join $parsed_line]
                  regsub {\.[\w]+$} $last_vpiname $parsed_line vpiname
              } elseif {[regexp {^\s*[\w]+[\w.]*\s*$} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set vpiname $parsed_line
                 set last_vpiname $vpiname
              } elseif {[regexp {^\s*[\w]+\s*$} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set vpiname $parsed_line
                 set last_vpiname $vpiname
              #Statement=(BC) in report
              } elseif {[regexp {.*BC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Statement"
                 lappend Statement $tmp_vpiname
                 lappend CODE_COVERAGE_LIST $tmp_vpiname
                 logfile "\"Statement\" variable append with $tmp_vpiname"
                #Branch=(BRC) in report
              } elseif {[regexp {.*BRC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Branch"
                 lappend Branch $tmp_vpiname
                 lappend CODE_COVERAGE_LIST $tmp_vpiname
                 logfile "\"Branch\" variable append with $tmp_vpiname"
              #Expression=(EC) in report
              } elseif {[regexp {.*EC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Expression"
                 lappend Expression $tmp_vpiname
                 lappend CODE_COVERAGE_LIST $tmp_vpiname
                 logfile "\"Expression\" variable append with $tmp_vpiname"
                #Toggle=(TFC) in report
              } elseif {[regexp {.*TFC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "Toggle"
                 lappend Toggle $tmp_vpiname
                 lappend CODE_COVERAGE_LIST $tmp_vpiname
                 logfile "\"Toggle\" variable append with $tmp_vpiname"
              #FSM State=(SC) in report
              } elseif {[regexp {.*SC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "fsm"
                                 #lappend tmp_vpiname "FSM_State"
                 lappend fsm $tmp_vpiname
                 #lappend FSM_State $tmp_vpiname
                 lappend CODE_COVERAGE_LIST $tmp_vpiname
                                 logfile "\"fsm\" variable append with $tmp_vpiname"
                 #logfile "\"FSM_State\" variable append with $tmp_vpiname"
                 #FSM Transition=(TRC) in report
              } elseif {[regexp {.*TRC:\s+[0-9]+%.*} $parsed_line]} {
                 set parsed_line [join $parsed_line]
                 set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 regsub {%$} $value "" value
                 set tmp_vpiname $vpiname
                 lappend tmp_vpiname "$value"
                 lappend tmp_vpiname "FSM_trans"
                 lappend FSM_trans $tmp_vpiname
                 lappend CODE_COVERAGE_LIST $tmp_vpiname
                 logfile "\"FSM_trans\" variable append with $tmp_vpiname"
              #Assertion=(FC) in report
              #} elseif {[regexp {.*FC:\s+[0-9]+%.*} $parsed_line]} {
               #  set parsed_line [join $parsed_line]
                # set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                 #regsub {%$} $value "" value
                 #set tmp_vpiname $vpiname
                 #if {$value != 100} {
                  #  set value "fail"
                 #} else {
                  #  set value "pass"
                 #}
                 #lappend tmp_vpiname "$value"
                # lappend tmp_vpiname "Assertion"
                 #lappend Assertion $tmp_vpiname
                 #lappend ASSERTION_LIST $tmp_vpiname
                 #logfile "\"Assertion\" variable append with $tmp_vpiname"
                #CoverGroup=(DC) in report
              #} elseif {[regexp {.*DC:\s+[0-9]+%.*} $parsed_line]} {
               # set parsed_line [join $parsed_line]
               #  set value [lindex $parsed_line [expr [llength $parsed_line] - 2]]
                # regsub {%$} $value "" value
                 #set tmp_vpiname $vpiname
                 #lappend tmp_vpiname "$value"
                 #lappend tmp_vpiname "CoverGroup"
                 #lappend CoverGroup $tmp_vpiname
                 #lappend COVERAGE_LIST $tmp_vpiname
                 #logfile "\"CoverGroup\" variable append with $tmp_vpiname"
              }
           }
        }
        close $log
    }
      

      ####for functional coverage###
  proc line2list {got ret} {
   upvar $ret my_lst
   set extract [split $got]
        set my_lst {}
        foreach element $extract {
            if {$element!=""} {
              lappend my_lst $element
           }
         }

   }

  set assert_found 0
  set coverage_found 0
  set count 0
  if {[file exists [file join $tmp_RPTDIR "report_detail.txt"]]} {
        set log2 [open [file join $tmp_RPTDIR "report_detail.txt"] r ]
        logfile "\n########## PARSE ALL DATA ##########"
        while {![eof $log2]} {
        set line [gets $log2]
        #### searching for "contol-oriented" hading
       if {[regexp ".*Control-oriented.*" $line]==1} {
           set coverage_found 0
           lappend match_list $line
           incr count
           set assert_found 1
           set type_assert "Assertion"
        }

        #### searching for "data-oriented" hading
       if {[regexp ".*Data-oriented.*" $line]==1} {
         set assert_found 0
         lappend match_list $line
         incr count
         set coverage_found 1
       }

       ####  for diffrent instance name under same "control-oriented" hading
       if {$assert_found==2 & [regexp "Instance name" $line]==1} {
          set assert_found 1
        }


      #### extracting instance name
      if {$assert_found==1 & [regexp "Instance name" $line]==1} {
              set path_extract [split $line]
              set path_assert [lindex $path_extract end]
              set assert_found 2
       }

       ####  extracting indexes
       if {$assert_found==2 & [regexp "cnt            coverage point  line origin description" $line]==1} {
                set lst {}
                line2list $line lst
                set value_index_assert [lsearch $lst "cnt"]
                set name_index_assert [lsearch $lst "coverage"]
                set assert_found 3
       }

       set lst {}
       line2list $line lst
       if {$assert_found==4 & [llength $lst]==0} {set assert_found 1}

       if {$assert_found==4} {
               set lst {}
                line2list $line lst
                set name_assert [lindex $lst $name_index_assert]
                set value_assert [lindex $lst $value_index_assert]
                if { $value_assert==0} {
                  set assert_status "Fail"
                } else {
                  set assert_status "Pass"
                }
                set assert_list "$path_assert.$name_assert $assert_status $type_assert"
                lappend Assertion $assert_list
                lappend ASSERTION_LIST $assert_list
        }

       if {$assert_found==3 & [string match "--------------*" $line]==1} {
          set assert_found 4
        }
          #######  assertion code ends
      #######  coverage code starts
      ####  for diffrent instance name under same "Date-oriented" hading

      if {$coverage_found!=0 & [regexp "Instance name:" $line]==1} { set coverage_found 1}

      ####  extracting instance name

      if {$coverage_found==1 & [regexp "Instance name" $line]==1} {
          set path_extract [split $line]
          set path_cover [lindex $path_extract end]
          set coverage_found 2
        }

   if {$coverage_found==2 & [regexp "Number of covered bins:" $line]==1} {set coverage_found 3}

   if {$coverage_found==3 & [regexp "Coverage           Count      Name                                Line Origin" $line]==1}  {set coverage_found 4}

    ####  for diffrent covergroup within same instance hading
    set lst {}
    line2list $line lst
    if {$coverage_found>5 & [llength $lst]==0} {set coverage_found 5}
     set count_coverpoint_coverage 1
     ####  for avoiding bins
     if {$coverage_found==6} {
        set sub_string [string range $line 0 9]
        if {$sub_string=="          "} {
           set count_coverpoint_coverage 1
         } else {
           set count_coverpoint_coverage 0
         }
      }
      ####  extracting coverpoint and cross
     if {$coverage_found==6 & $count_coverpoint_coverage==0} {
         set lst {}
         line2list $line lst
         set name_coverpoint_cover [lindex $lst 3]
         set value_coverpoint_cover [expr round([lindex $lst 0] * 100)]
         if {[regexp ": cross" $line]==1} {
             set cover_list "$path_cover.$name_coverpoint_cover $value_coverpoint_cover Cross"
             lappend Cross $cover_list
         } else {
             set cover_list "$path_cover.$name_coverpoint_cover $value_coverpoint_cover Coverpoint"
             lappend CoverPoint $cover_list
         }

         lappend COVERAGE_LIST $cover_list
      }
     ####  extracting covergroup
     set lst {}
     line2list $line lst
     if {$coverage_found==5 & [llength $lst]!=0} {
        set lst {}
        line2list $line lst
        set name_covergroup_cover [lindex $lst 3]
        set value_covergroup_cover [expr round([lindex $lst 0] * 100)]
        set cover_list "$path_cover.$name_covergroup_cover $value_covergroup_cover covergroup"
        lappend CoverGroup $cover_list
        lappend COVERAGE_LIST $cover_list
        set count_coverpoint_coverage 0
        set coverage_found 6

     }
     if {$coverage_found==4 & [string match "---------*" $line]==1}  {
        set coverage_found 5
      }

     }
    close $log2
  }
    

  ###############################             
          }
       }
      ########For extracting test name from .vsof file########
       if {$rpt_start_test == 1} {
          if {[regexp {.*full_title:\s+\"(.*)\"} $parsed_line_test]} {
           regexp {.*full_title:\s+\"(.*)\"} $parsed_line_test all one 
           set tests [split $one "/"]
           set testname [lindex $tests end]
           set tmp_testname $testname
           foreach ele $testname_list {
            if {[string match $ele "$testname"]} {
             set metric_exist 1
             }
           }
           if {$metric_exist == 0} {
             lappend testname_list  $testname
             set metric_testname $testname
           } elseif {$metric_exist == 1} {
             set metric_testname ""
           }
                  
           }
            if {[regexp {.*run_dir:\s+\"(.*)\"} $parsed_line_test]} {
            regexp {.*run_dir:\s+\"(.*)\"} $parsed_line_test all first
            if {[regexp {.*\$[A-Z]+.*} $first]} {
            set log_file [split $first "/"]
            set log_file [lreplace $log_file 0 0]
            set log_file [join $log_file "/"]
            set local_log_dir "$local_log/$log_file"
            } else {
            set local_log_dir "$first"
            }
            if {[file exists [file join $local_log_dir "local_log.log"]]} {
            set logs [open [file join $local_log_dir "local_log.log"] r ]
            set test_status ""
            while {![eof $logs]} {
               set line_parse [gets $logs]
               if {[regexp {UVM_ERROR\s+\:\s+[1-9]+.*} $line_parse]} {
                    set test_status "Fail"
                  #} elseif {[regexp {UVM_FATAL\s+\:\s+[1-9].*} $line_parse]} {
                  # set test_status "Fail"
                } elseif {[regexp {\s+\*\*\*\s+Error:(.*)} $line_parse]} {
                    set test_status "Fail"
                } elseif {[regexp {.*:\s+\*E,(.*)} $line_parse]} {
                    set test_status "Fail"
                }
              }
              close $logs
                if {![string equal "Fail" $test_status]} {
                 set test_status "Pass"
                }
                lappend tmp_testname $test_status
                lappend tmp_testname "Test"
                logfile "\"Test\" variable append with $tmp_testname"
               lappend Test $tmp_testname
               lappend TEST_LIST $tmp_testname
               if {![string equal $metric_testname ""]} {
                lappend metric_testname $test_status
                lappend metric_testname "Test"
                logfile "\"Test\" variable append with $metric_testname"
                 lappend Test1 $metric_testname
                 lappend TEST_LIST1 $metric_testname
               }
        }
      } 
   }
  }
 close $log_test
}
#puts "$Test"
#################################################################
# Files from where data is to be extracted for Synopsys and Mentor

if  {[string equal $MODE "mentor"]} {

    set log [open [file join $tmp_RPTDIR "tests_rpt.txt"] r ]
    logfile "\n\n########## TESTS ##########"
    set tmp_testname ""
    ##Test storage structure
    #[list <test_name> <Pass|Fail> "Test"]
    while {![eof $log]} {
        set parsed_line [gets $log]
        set parsed_line [join $parsed_line]
        
        set elems [split $parsed_line =]
        set key [string trim [lindex $elems 0]]
        set val [string trim [lindex $elems 1]]
        
        if {[string equal "TESTNAME" $key]} {
            set tmp_testname $val 
        } elseif {[string equal "TESTSTATUS" $key]} {
            if {$val == 0} {
                lappend tmp_testname "Pass"
            } else {
                lappend tmp_testname "Fail"
            }
            lappend tmp_testname "Test"
            logfile "\"Test\" variable append with $tmp_testname"
            
            #AB: What is this Test list for ? 
            lappend Test $tmp_testname
            lappend TEST_LIST $tmp_testname
        }
    }
    close $log
}
#############################################################
#assertions log file
if {[file exists [file join $tmp_RPTDIR "assertion_rpt.txt"]]} {
    set log [open [file join $tmp_RPTDIR "assertion_rpt.txt"] r ]
    logfile "\n########## ASSERTIONS ##########"
    set synopsys_rpt 0 
    if  {[string equal $MODE "mentor"]} {
        logfile "\nValues in {} are {(Failure Count) (Pass Count) (Vacuous Count) \
       (Disabled Count) (Attempt Count)} \tif \"0\" indicates Assertion Failure\n"
        set tmp_assertname ""
        set old_assertname ""
        set name_col 0
        #Changing clumn index FOR ModelSim
        set fail_count_col 6
        set pas_count_col 7
        #Following 3 columns do not exist if there is no assertion.
        set vacuous_cnt_col 8
        set disable_cnt_col 9
        set attempt_cnt_col 10
        #FOR QUESTA:
        #set fail_count_col 7
        #set pas_count_col 8
        #Following 3 columns do not exist if there is no assertion.
        #set vacuous_cnt_col 9
        #set disable_cnt_col 10
        #set attempt_cnt_col 11
        ##Assertion storage structure 
        #[list <assertion_name> <data_list> "Assertion"]
        #      data_list = <fail_count> OR
        #                  <fail_count> <pas_count> <vacuous_cnt> <disable_cnt> <attempt_cnt>            
    } elseif {[string equal $MODE "synopsys"]} {
        logfile "\n"
        set tmp_assertname ""
        set old_assertname ""
        set assert_not_attempt 0
    }
    while {![eof $log]} {
        set parsed_line [gets $log]
        if {[string equal $MODE "mentor"]} {
            set parsed_line [join $parsed_line]
        }
        if {[string match "/*" $parsed_line] && [string equal $MODE "mentor"]} {
            ##Remove 'assert__' from the assert name 
            regsub -all "/assert__" $parsed_line  "/" tmp_name
            set tmp_assertname $tmp_name
            ##Not including "##" or auto generated names after the original assert names for immediate assertions
        } elseif {[string match "Immediate*" $parsed_line] \
                      && [regexp "\/.*__.*\/.*immed__.*" $tmp_assertname]} { 
            set pass_count 0
            set fail_count 0
            set assertname [join [split $tmp_assertname "\/"] " "]
            ##If not to 1nclude even '__' terms change lrange to "lrange $assertname 0 [expr [lsearch $assertname *__* ] - 1 ]"
            set assertname "\/[join [lrange $assertname 0 [lsearch $assertname *__* ]] "\/"]"
            
            if {[lindex $parsed_line $fail_count_col] > 0 } {
                incr fail_count
            } elseif {(([lindex $parsed_line $fail_count_col] == "-") \
                          || ([lindex $parsed_line $fail_count_col] == "0")) \
                     && (([lindex $parsed_line $pas_count_col] > "0") \
                          || [string equal [lindex $parsed_line $pas_count_col] "-"])} {
                incr pass_count
            } elseif {[lindex $parsed_line $pas_count_col] == "0"} {
                incr fail_count
            }
            ##name to be checked..........
            if {[lindex $parsed_line $fail_count_col] == "-" \
                    && [lindex $parsed_line $pas_count_col] == "-" } {
                lappend assertname "" "Assertion"
            } elseif {$pass_count > "$fail_count"} {
                lappend assertname "Pass" "Assertion"
            } elseif {$fail_count >= "$pass_count"} {
                lappend assertname "Fail" "Assertion"
            }
            if {[lindex $old_assertname 0] == [lindex $assertname 0]} {
                if {[lindex $old_assertname 1] == "Fail"} {
                    set [lindex $assertname 1] "Fail"
                }
            } elseif {$old_assertname != ""} {
                lappend ASSERTION_LIST $old_assertname
                logfile "\"Assertion\" variable append with $old_assertname " 
            }
            
            set old_assertname $assertname
            
            ##For concurrent assertions
        } elseif {[string match "Concurrent*" $parsed_line]} {
            if {[lindex $parsed_line $fail_count_col] == "-" \
                    && [lindex $parsed_line $pas_count_col] == "-" } {
                lappend tmp_assertname "" "Assertion"
            } elseif {[lindex $parsed_line $fail_count_col] > 0 } {
                lappend tmp_assertname "Fail" "Assertion"
            } elseif {(([lindex $parsed_line $fail_count_col] == "-") \
                          || ([lindex $parsed_line $fail_count_col] == "0")) \
                     && (([lindex $parsed_line $pas_count_col] > "0") \
                          || [string equal [lindex $parsed_line $pas_count_col] "-"])} {
                lappend tmp_assertname "Pass" "Assertion"
            } elseif {[lindex $parsed_line $pas_count_col] == "0"} {
                lappend tmp_assertname "Fail" "Assertion"
            }
            lappend ASSERTION_LIST $tmp_assertname
            logfile "\"Assertion\" variable append with $tmp_assertname "
            
        } elseif {[regexp {^Assertions Without Attempts:.*$} $parsed_line]} {
           set assert_not_attempt 1
        } elseif {[string match "*ASSERTIONS*CATEGORY*SEVERITY*ATTEMPTS*REAL*" $parsed_line] && $assert_not_attempt==0 } {
            set synopsys_rpt 1
            continue
        } elseif {[string match "*CATEGORY*SEVERITY*ATTEMPTS*MATCHES*" $parsed_line] && $assert_not_attempt==0 } {
            set synopsys_rpt 2
            continue
        }
        if {$synopsys_rpt > 0} {
            #set tmp_assertname [lindex $parsed_line 0 ]
            regexp {\s*([^\s]+)\s*} $parsed_line m0 m1
            set tmp_assertname "$m1"

            if {[regexp "^ *$" $parsed_line]} {
                set synopsys_rpt 0
                continue
            }
            #Removing Package name from assert name: bcoz- 
            #Pkg separator (.\) escapes the char following it and causes trouble ahead.
            #e.g. assert name "xyz_pkg.\axyz_port::connect" becomes xyz_port::connect
            regsub -all {.*\.\\} $tmp_assertname "" tmp_assertname
            # Remove ".unnamed$$_x" from the assertion name created by synopsys
            if  {[regexp ".*\.unnamed.*\_.*" $tmp_assertname]} {
                regsub -all ".unnamed.*" $tmp_assertname "" tmp_name
                set tmp_assertname $tmp_name
            }
            set line_length [llength $parsed_line]
            set incomplete_count_col [expr $line_length - 1]
            if {$synopsys_rpt == 1} {
                set fail_count_col [expr $line_length - 2]
                set real_count_col [expr $line_length - 3]
                set attempt_count_col [expr $line_length - 4]
            } elseif {$synopsys_rpt == 2} {
                #set fail_count_col [expr $line_length - 2]
                set real_count_col [expr $line_length - 2]
                set attempt_count_col [expr $line_length - 3]
            }
            set assertname $tmp_assertname
            #If Attempt count and real count are 0, Cannot determine pass or fail 
            if {([lindex $parsed_line $real_count_col] == 0) && ([lindex $parsed_line $attempt_count_col] == 0)} {
                lappend assertname "" "Assertion"
                lappend ASSERTION_LIST $assertname
                logfile "\"Assertion\" variable append with $assertname "
                set old_assertname $assertname
                continue
            }
            set fail_count 0
            set pass_count 0
            if {$synopsys_rpt == 1} {
                if {[lindex $parsed_line $fail_count_col] ==  0} {
                    if {[lindex $parsed_line $incomplete_count_col] == 0} {
                        incr pass_count
                    } else {
                        incr fail_count
                    }
                } elseif {[lindex $parsed_line $fail_count_col] >  0} {
                    incr fail_count
                }
            } elseif {$synopsys_rpt == 2} {
                if {[lindex $parsed_line $real_count_col] >  0} {
                    if {[lindex $parsed_line $incomplete_count_col] == 0} {
                        incr pass_count
                    } else {
                        incr fail_count
                    }
                } elseif {[lindex $parsed_line $real_count_col] ==  0} {
                    incr fail_count
                }
            }
            if {$pass_count > 0} {
                lappend assertname "Pass" "Assertion"
            } elseif {$fail_count > 0} {
                lappend assertname "Fail" "Assertion"
            }
            if {[string equal [lindex $assertname 0] [lindex $old_assertname 0] ]} {
                if {[string equal [lindex $assertname 1] [lindex $old_assertname 1] ]} {
                    continue
                } else {
                    if {[string equal [lindex $old_assertname 1] "Fail"]} {
                        continue
                    } elseif {[string equal [lindex $old_assertname 1] "Pass"] && [string equal [lindex $assertname 1] "Fail"]} {
                        set ASSERTION_LIST "[lreplace $ASSERTION_LIST end end]" 
                    } elseif {[string equal [lindex $old_assertname 1] "Pass"] && [string equal [lindex $assertname 1] "Pass"]} {
                        continue
                    }
                }
            }
            lappend ASSERTION_LIST $assertname
            logfile "\"Assertion\" variable append with $assertname "
            set old_assertname $assertname
        }

    }
    close $log
}
##################################################################
#coverage log file
if {[file exists [file join $tmp_RPTDIR "coverage_rpt.txt"]] && ([string equal "synopsys" $MODE] || [string equal "mentor" $MODE])} {
    set log [open [file join $tmp_RPTDIR "coverage_rpt.txt"] r ]
    logfile "\n########## COVERAGE #########"

    ##Coverage|Cross|Coverpoint structure
    #[list <coverage_name|cross_name|coverpoint_name> <value> "<Coverage|Cross|Coverpoint>"]
    set covergroup_name ""
    set synopsys_rpt 0 
    set cov_value_true 0
    set instance_true 0
    set tmp_grp_inst_name ""
    set tmp_grp_name ""
    set covpnt_cros_table 0
    while {![eof $log]} {
        set parsed_line [gets $log]
        set parsed_line [join $parsed_line]
        
        #Replace all % signs
        regsub -all {%} $parsed_line {} parsed_line
        #storing data in lists:-
        if {[string match "TYPE*" $parsed_line]} {
            #Expected columns in a line = 5
            set exp_cols_size 5
            if {([llength $parsed_line] < $exp_cols_size) && (![eof $log])} {
                #Merge the continuing line to the line being worked on i.e 'parsed_line'
                set nxt_parsed_line [gets $log]
                set nxt_parsed_line [join $nxt_parsed_line]
                regsub -all {%} $nxt_parsed_line {} nxt_parsed_line
                foreach word $nxt_parsed_line {
                    lappend parsed_line $word
                }
            }
            lappend CoverGroup "[lindex $parsed_line 1] [lindex $parsed_line 2] CoverGroup"
            set covergroup_name [lindex $parsed_line 1]
            set covergroup_val [lindex $parsed_line 2]
            lappend COVERAGE_LIST "$covergroup_name $covergroup_val CoverGroup"
            logfile "\n\"Covergroup\" variable append with $covergroup_name $covergroup_val CoverGroup "
            
        } elseif {[string match "Coverpoint*" $parsed_line] && [string match "*::*" $parsed_line]} {
            #Extract coverpoint 
            regexp {[\w]+::([^\s]+)} $parsed_line all name
            #Replace <covergroup::coverpoint> with covergroups complete hier name and coverpoint name
            set parsed_line [lreplace $parsed_line 1 1 "$covergroup_name\/$name" ]
            set cover_point_hier_name [lindex $parsed_line 1]
            set cover_point_val [lindex $parsed_line 2]
            lappend CoverPoint "$cover_point_hier_name $cover_point_val CoverPoint"
            lappend COVERAGE_LIST "[lindex $parsed_line 1] [lindex $parsed_line 2] CoverPoint"
            logfile "\"Coverpoint\" variable append with [lrange $parsed_line 1 2] CoverPoint"
            
        } elseif {[string match "Cross *" $parsed_line] && [string match "*::*" $parsed_line]} {    
            regexp {[\w]+::([^\s]+)} $parsed_line all name
            set parsed_line [lreplace $parsed_line 1 2 "$covergroup_name\/$name" [string trimright [lindex $parsed_line 2] %]]
            lappend Cross "[lindex $parsed_line 1] [lindex $parsed_line 2] Cross"
            lappend COVERAGE_LIST "[lindex $parsed_line 1] [lindex $parsed_line 2] Cross"
            logfile "\"Cross\" variable append with [lrange $parsed_line 1 2] Cross"
            
        } elseif {[regexp "Covergroup\\s*instance.*" $parsed_line] } {
          if  {([llength $parsed_line] >= 5)} {
          #Per instance based CGs
             set parsed_line [lreplace $parsed_line 3 3 [string trimright [lindex $parsed_line 3] %] ]
          } elseif  {([llength $parsed_line] < 5)} {
             #Merge the continuing line to the line being worked on i.e 'parsed_line'
             set nxt_parsed_line [gets $log]
             set nxt_parsed_line [join $nxt_parsed_line]
             regsub -all {%} $nxt_parsed_line {} nxt_parsed_line
             foreach word $nxt_parsed_line {
               lappend parsed_line $word
             }
          }
          lappend CoverGroup_Instance "[lindex $parsed_line 2] [lindex $parsed_line 3] CoverGroup"
          lappend COVERAGE_LIST "[lindex $parsed_line 2] [lindex $parsed_line 3] CoverGroup"
          set CoverGroup_Instance_name [lindex $parsed_line 2]
          logfile "\n\"Covergroup_instance\" variable append with [lrange $parsed_line 2 3] CoverGroup "

      } elseif {[string match "Coverpoint*" $parsed_line] && (![string match "*::*" $parsed_line])} {
          set parsed_line [lreplace $parsed_line 1 2  "$CoverGroup_Instance_name\/[lindex $parsed_line 1]"\
                       [string trimright [lindex $parsed_line 2] %] ]
          lappend CoverPoint_Instance "[lindex $parsed_line 1] [lindex $parsed_line 2] CoverPoint"
          lappend COVERAGE_LIST "[lindex $parsed_line 1] [lindex $parsed_line 2] CoverPoint"
          logfile "\"Coverpoint_instance\" variable append with [lrange $parsed_line 1 2] CoverPoint "

      } elseif {[string match "Cross *" $parsed_line] && (![string match "*::*" $parsed_line]) \
                 && (![string match "*type coverage*" $parsed_line])} {
          set parsed_line [lreplace $parsed_line 1 2 "$CoverGroup_Instance_name\/[lindex $parsed_line 1]"\
                      [string trimright [lindex $parsed_line 2] %] ]
          lappend Cross_instance "[lindex $parsed_line 1] [lindex $parsed_line 2] Cross"
          lappend COVERAGE_LIST "[lindex $parsed_line 1] [lindex $parsed_line 2] Cross"
          logfile "\"Cross_instance\" variable append with [lrange $parsed_line 1 2] Cross "

        } elseif {[string match "===============*" $parsed_line]} {
            if {$synopsys_rpt == 0} {
                set synopsys_rpt 1
            } else {
                set synopsys_rpt 0
            }
        } elseif  {[string match "Group :*" $parsed_line] && ($synopsys_rpt ==1)} {
            set tmp_grp_name [join [lrange $parsed_line 2 end]]
            if {[regexp {.*::SHAPE{.*}.*} "${tmp_grp_name}"]} {
                regsub -all {::SHAPE.*} $tmp_grp_name "" tmp_name
                set tmp_grp_name $tmp_name
            }
            #removing "::coverage" in the coverage name,which seems to be added by the synopsys tool.
            # This keyword is added in the coverage name in some cases, depends upon how you define the coverage.
            # Not sure whether to keep it ? 
            #eg: "::coverage::xyz" is replaced to "xyz".
            #eg: "::xyz" is replaced  if comes at the starting, changes to "xyz".
            regsub "^:+coverage:+" $tmp_grp_name "" tmp_grp_name
            regsub "^::" $tmp_grp_name "" tmp_grp_name
 
            set instance_true 0
            #set covpoint_cross_true 0
            set type_name "CoverGroup"
            set tmp_grp_inst_name ""
        } elseif {[string match "Group Instance :*" $parsed_line] && ($synopsys_rpt ==1)} {
            #set tmp_grp_inst_name $tmp_grp_name 
            #append tmp_grp_inst_name   "::[lindex $parsed_line [expr [llength $parsed_line] -1]]"
            #append tmp_grp_inst_name   ".[lindex $parsed_line [expr [llength $parsed_line] -1]]"
            set tmp_grp_inst_name   ".[lindex $parsed_line [expr [llength $parsed_line] -1]]"
            set type_name "CoverGroup_Instance"
        } elseif {([regexp "SCORE\\s.*GOAL.*" $parsed_line] && ![regexp {NAME} $parsed_line]) && ($synopsys_rpt == 0)} {
            set cov_value_true 1
            set cov_value [lsearch $parsed_line "SCORE"]
        } elseif {$cov_value_true == 1} {
            set cov_value_true 0 
            if {[string equal $type_name "CoverGroup"]} {
                set cov_name "$tmp_grp_name [lindex $parsed_line $cov_value] CoverGroup"
                lappend CoverGroup $cov_name
                logfile "\"CoverGroup\" variable append with $cov_name"
            } elseif {[string equal $type_name "CoverGroup_Instance"]} {
                set cov_name "$tmp_grp_inst_name [lindex $parsed_line $cov_value] CoverGroup"
                lappend CoverGroup_Instance $cov_name
                logfile "\"CoverGroup_Instance\" variable append with $cov_name"
            } 
            lappend COVERAGE_LIST $cov_name 
        } elseif {[regexp {[0-9]+ Instances:.*} $parsed_line]} {
            set instance_true 0
        } elseif {[regexp "(VARIABLE|CROSS) .*PERCENT.*" $parsed_line]} {
            set covpnt_cros_table 1
            set type_name [lindex $parsed_line 0]
            set covpnt_cros_val_col [lsearch $parsed_line PERCENT]
        } elseif {($covpnt_cros_table == 1) && ($instance_true == 0)} {
            if {[regexp "^ *$" $parsed_line]} {
                set covpnt_cros_table 0
                continue
            }
            if {![string equal "$tmp_grp_inst_name" ""]} {
            set covpnt_cross_name "$tmp_grp_inst_name"
            } else {
            set covpnt_cross_name "$tmp_grp_name"
            }
            #append covpnt_cross_name "::[lindex $parsed_line 0]"
            append covpnt_cross_name ".[lindex $parsed_line 0]"
            #VARIABLE for Coverpoint in Synopsys
            if {[string equal $type_name "VARIABLE"]} {
                lappend covpnt_cross_name "[lindex $parsed_line $covpnt_cros_val_col]" "CoverPoint"
                lappend CoverPoint $covpnt_cross_name
                lappend COVERAGE_LIST $covpnt_cross_name
                logfile "\"CoverPoint\" variable append with $covpnt_cross_name"
            } elseif {[string equal $type_name "CROSS"]} {
                lappend covpnt_cross_name "[lindex $parsed_line $covpnt_cros_val_col]" "Cross"
                lappend Cross $covpnt_cross_name
                lappend COVERAGE_LIST $covpnt_cross_name
                logfile "\"Cross\" variable append with $covpnt_cross_name"
            }
        } elseif {($covpnt_cros_table == 1) && ($instance_true == 1) && (![string equal "$tmp_grp_inst_name" ""])} { 
            if {[regexp "^ *$" $parsed_line]} {
                set covpnt_cros_table 0
                continue
            }
            set covpnt_cross_name "$tmp_grp_inst_name"
            #append covpnt_cross_name "::[lindex $parsed_line 0]"
            append covpnt_cross_name ".[lindex $parsed_line 0]"
            #VARIABLE for Coverpoint in Synopsys
            if {[string equal $type_name "VARIABLE"]} {
                lappend covpnt_cross_name "[lindex $parsed_line $covpnt_cros_val_col]" "CoverPoint"
                lappend CoverPoint_Instance $covpnt_cross_name
                lappend COVERAGE_LIST $covpnt_cross_name
                logfile "\"CoverPoint_Instance\" variable append with $covpnt_cross_name"
            } elseif {[string equal $type_name "CROSS"]} {
                lappend covpnt_cross_name "[lindex $parsed_line $covpnt_cros_val_col]" "Cross"
                lappend Cross_Instance $covpnt_cross_name
                lappend COVERAGE_LIST $covpnt_cross_name
                logfile "\"Cross_Instance\" variable append with $covpnt_cross_name"
            }
        }
    }
    close $log
}

############################################################
# directive log file:
if {[file exists [file join $tmp_RPTDIR "directive_rpt.txt"]]} {
    set log [open [file join $tmp_RPTDIR "directive_rpt.txt"] r ]
    set directive_name ""
    logfile "\n########## DIRECTIVE ##########"
    
    while {![eof $log]} {
        set parsed_line [gets $log]
        set parsed_line [join $parsed_line]
        if {[string match "\/*" $parsed_line]} {
            ##Remove 'cover__' from the directive name
            regsub -all "/cover__" [lindex $parsed_line 0]  "/" tmp_name
            set directive_name $tmp_name
            #Expected columns in a line = 5
            set exp_cols_size 7
            if {([llength $parsed_line] < $exp_cols_size) && (![eof $log])} {
                #Merge the continuing line to the line being worked on i.e parsed_line
                set tmp_parsed_line [gets $log]
                set tmp_parsed_line [join $tmp_parsed_line]
                regsub -all {%} $tmp_parsed_line {} tmp_parsed_line
                foreach word $tmp_parsed_line {
                    lappend parsed_line $word
                }
            }
            if {[string equal "Covered" [lindex $parsed_line 6]]} {
                set value 100
                lappend Directive "$directive_name $value Directive"
                lappend DIRECTIVE_LIST "$directive_name $value Directive"
                logfile "\"Directive\" variable append with $directive_name $value Directive "
            } elseif {([string equal "Uncovered" [lindex $parsed_line 6]]) \
                   || ([string equal "ZERO" [lindex $parsed_line 6]])} {
                set value 0
                lappend Directive "$directive_name $value Directive"
                lappend DIRECTIVE_LIST "$directive_name $value Directive"
                logfile "\"Directive\" variable append with $directive_name $value Directive "
            }
        }  
    }
    close $log
}
##############################################################
# code coverage log file:
if {[file exists [file join $tmp_RPTDIR "code_coverage_rpt.txt"]]} { 
    set log [open [file join $tmp_RPTDIR "code_coverage_rpt.txt"] r ]
    set instance_name ""
    set synopsys_enb 0
    logfile "\n########## CODE COVERAGE ##########"
    set curr_hier_name ""
    set hier_num 0
    set old_hier_num 0
    while {![eof $log]} {
        set parsed_line [gets $log]
        if {[string equal "mentor" $MODE ]} {
           set parsed_line [join $parsed_line]
        }
        regsub -all {%} $parsed_line {} parsed_line
        set value ""
        if {[string match "Instance*" $parsed_line]} {
            set instance_name [lindex $parsed_line 1]
            logfile "\n"

        } elseif {[regexp Stmts.*|Branches.*|Conditions.*|States.*|Transitions.* [lindex $parsed_line 0]]} {
            if {[lindex $parsed_line 0] == "Branches"} {
                set name Branch 
            } elseif {[lindex $parsed_line 0] == "Conditions"} {
                set name Condition
            } elseif {[lindex $parsed_line 0] == "States"} {
                set name "fsm"
				#set name "FSM_State"
            } elseif {[lindex $parsed_line 0] == "Transitions"} {
                set name "FSM_Trans"
            } elseif {[lindex $parsed_line 0] == "Stmts"} {
                set name Statement
            }
            
            # if active =0 and hits =0 : Mentor shows 100% coverage . Which seems to be a bug
            if {[lindex $parsed_line 1] == "0" && [lindex $parsed_line 2] == "0"} {
                lappend value ""
            } else {
                set value [lindex $parsed_line end]
            }
            lappend $name  "$instance_name $value $name"
            lappend CODE_COVERAGE_LIST "$instance_name $value $name"
            logfile "\"$name\" variable append with $instance_name $value $name"
            
        } elseif {[regexp "Toggle.*" [lindex $parsed_line 0]]} {
            if {[lindex $parsed_line 0] == "Toggle"} {
                set name Toggle
            } 
            
            # if active =0 and hits =0 : Mentor shows 100% coverage . Which seems to be a bug
            #Index here are diff from Stmts/Branches etc coz 'Toggle Nodes' and 'Fec Conditions' are seprated by a space 
            #which shifts an index by 1
            if {[lindex $parsed_line 2] == "0" && [lindex $parsed_line 3] == "0"} {
                lappend value ""
            } else {
                set value [lindex $parsed_line end]
            }
            lappend $name  "$instance_name $value $name"
            lappend CODE_COVERAGE_LIST "$instance_name $value $name"
            logfile "\"$name\" variable append with $instance_name $value $name"
        } elseif {[regexp "^\\s*------*$" $parsed_line]} {
            set hier "\%"
            if {[regexp "\\s*" $parsed_line match]} {
               set old_hier_num $hier_num
               set hier_num [expr [string length $match] / 2]
               if {$old_hier_num > $hier_num} {
                  set old_hier_num [expr $hier_num - [expr $old_hier_num - $hier_num]]
               }
               append hier $hier_num
            }
            regsub -all {\s+} $parsed_line "$hier" parsed_line
            continue
        } elseif {[regexp "^\\s*$" $parsed_line]} {
            set synopsys_enb 0
        }
        if {[regexp "^\\s*SCORE.*$" $parsed_line]} {
            set synopsys_enb 1
            set line_indx [lsearch $parsed_line "LINE"]
            set cond_indx [lsearch $parsed_line "COND"]
            set togl_indx [lsearch $parsed_line "TOGGLE"]
            set fsm_indx  [lsearch $parsed_line "FSM"]
            set brnc_indx [lsearch $parsed_line "BRANCH"]
            set name_indx end 
          
           continue
        }
        if {($synopsys_enb == 1) && (! [regexp ".*\\\$.*" $parsed_line])} {
            set parsed_line [join $parsed_line]
            set tmp_name [lindex $parsed_line $name_indx]
            #Update the hierarchical name
            if {$hier_num == 0} {
               set curr_hier_name [set hier_$hier_num "$tmp_name"]
            } else {
               set curr_hier_name [set hier_$hier_num [subst $[subst hier_$old_hier_num]].$tmp_name ]
            }
            set index 0
            # Replace "--" by empty string
            foreach var $parsed_line {
               if {[regexp {\-\-} $var]} {
                  regsub {\-\-} $var "" var
               }
               set parsed_line [lreplace $parsed_line $index $index $var] 
               incr index
            }
            #Store Code coverage results
            set line_value [lindex $parsed_line $line_indx]
            set cond_value [lindex $parsed_line $cond_indx]
            set togl_value [lindex $parsed_line $togl_indx]
            set fsm_value [lindex $parsed_line $fsm_indx]
            set brnc_value [lindex $parsed_line $brnc_indx]
            #Store in lists
            set line_coverage $curr_hier_name
            lappend line_coverage "$line_value" "Statement"
            set cond_coverage $curr_hier_name
            lappend cond_coverage "$cond_value" "Condition"
            set togl_coverage $curr_hier_name
            lappend togl_coverage "$togl_value" "Toggle"
            set fsm_coverage $curr_hier_name
            lappend fsm_coverage "$fsm_value" "FSM"
            set brnc_coverage $curr_hier_name
            lappend brnc_coverage "$brnc_value" "Branch"
 
            # Putting lists in CODE_COVERAGE_LIST list
            lappend CODE_COVERAGE_LIST $line_coverage
            logfile "\"Statement\" variable append with $line_coverage"
            lappend CODE_COVERAGE_LIST $cond_coverage 
            logfile "\"Condition\" variable append with $cond_coverage"
            lappend CODE_COVERAGE_LIST $togl_coverage
            logfile "\"Toggle\" variable append with $togl_coverage"
            lappend CODE_COVERAGE_LIST $fsm_coverage
            logfile "\"FSM\" variable append with $fsm_coverage"
            lappend CODE_COVERAGE_LIST $brnc_coverage
            logfile "\"Branch\" variable append with $brnc_coverage"
        }
    }
    close $log
}

#############################################################################
#FOR SVG
set CONT 1
if {($SVG == 1)} {
   if {(![string equal $svg_inputfile ""]) && [file isdirectory $svg_inputfile]} {
      set COV_LIST $COVERAGE_LIST
      set svg_dir $svg_inputfile
      set num 0
      set check_data {}
      foreach metrix $COV_LIST {
          incr num
          set metric_tmp_list [split [lindex $metrix 0] "\/.:"]
          if {[string equal {} [lindex $metric_tmp_list 0]]} {
             set metric_tmp_list [lreplace $metric_tmp_list 0 0]
          }
          set blk_name ""
          set elements ""
          if {[string equal $MODE "mentor"]} {
             foreach ele $metric_tmp_list {
                if {[regexp -nocase "^.*_regmem_pkg$" $ele]} {
                   regsub "_regmem_pkg" $ele "" blk_name
                } elseif {[regexp -nocase "^$blk_name\_block$" $ele]} {
                   regsub "_block" $ele "" blk_name
                   lappend elements $blk_name
                } elseif {[regexp -nocase "^$blk_name\_.*" $ele]} {
                   set elements [split $ele "_"]
                } elseif {![regexp -nocase "cg_vals|cg_addr" $ele]} {
                   if {[string match $ele [lindex $metric_tmp_list end]]} {
                      lappend elements $ele
                   }
                }
             }
          } elseif {[string equal $MODE "synopsys"]} {
             if {[regexp -nocase "^ral_reg_.*(\.|\:)+field_values.*$" $metrix]} {
                regsub "^ral_reg_" [lindex $metrix 0] "" blk_name
                regsub "::field_values" $blk_name "" blk_name
                regsub "_value" $blk_name "" blk_name
                set elements [split $blk_name "_\."]
                set blk_name [lindex $elements  0]
                set tmp_replace_indx [lsearch -regexp $elements "^ *$"]
                set elements [lreplace $elements $tmp_replace_indx $tmp_replace_indx]
                set tmp_replace_indx [lsearch -regexp $elements "^\[0-9\]+$"]
                set elements [lreplace $elements $tmp_replace_indx $tmp_replace_indx]
                #puts "$metrix:\t\t -$metric_tmp_list \t\t:$elements \t:$tmp_replace_indx"
             } elseif {[regexp -nocase "^ral_.*_block_.*$" $metrix]} {
                regsub "^ral_.*_block_" [lindex $metrix 0] "" blk_name
                regsub "::addr_map" $blk_name "_" blk_name
                set elements [split $blk_name "_."]
                set blk_name [lindex $elements  0]
                set tmp_replace_indx [lsearch -regexp $elements "^ *$"]
                set elements [lreplace $elements $tmp_replace_indx $tmp_replace_indx]
                set tmp_replace_indx [lsearch -regexp $elements "^\[0-9\]+$"]
                set elements [lreplace $elements $tmp_replace_indx $tmp_replace_indx]
                #puts "$metrix:\t\t -$metric_tmp_list \t\t:$elements \t:$tmp_replace_indx"
             } else {
                incr num -1
                continue
             }

          }
          set  svg_data "$elements" 
          lappend svg_data "[lindex $metrix 1]"
          lappend svg_data "[lindex $metrix 2]"
          set svg_inputfile [file join $svg_dir "$blk_name\.txt"]
          if {$num <= 1} {
             set svg_write [open "$svg_inputfile" w]
          } else {
             set svg_write [open "$svg_inputfile" a]
          }
          set dump 1
          foreach test $check_data {
             #if {[string match [lindex $svg_data 1] [lindex $test 1]] && [string match [lindex $svg_data 2] [lindex $test 2]] && [regexp -nocase ".*\[0-9\]+.*" [lindex $svg_data 2]]} {}
             if {[string match [lindex $svg_data 1] [lindex $test 1]] && ![string match [lindex $svg_data end] [lindex $test end]] && [string match [lindex $svg_data 2] [lindex $test 2]]} {
                #puts "[lindex $svg_data 0] ==  [lindex $test 0]"
                set dump 0
                break
             } elseif {[regexp ".*\[\[0-9\]+\].*" [lindex $svg_data 2]]} {
                set dump 0
                break
             } else {
                set dump 1
             }
          }    
          if {$dump == 1} {
             puts $svg_write $svg_data
          }
          lappend check_data $svg_data 
          close $svg_write
      }
   } else {
      puts "Please check whether 'IDS_SIM_DIR' environment variable exists and has correct path."
   }
      set CONT 0
}


############################################################################
if {($CONT == 1)} {
#Extracting links into variables
set HTMLDIR $tmp_HTMLPATH

if {$keep_htmldir} {
    puts "INFO: HTML reports saved in '$HTMLDIR'."
}
if {$keep_rptdir} {
    puts "INFO: Text reports saved in '$tmp_RPTDIR'."
}
##Assumption: We have output file names based on the type of info they contain
set cover_htmlist ""
set assert_htmlist ""
set code_cover_htmlist ""
set test_htmlist ""
set code_cover_htmlist ""
set directive_htmlist ""
set cadence_htmlist ""

if {($HTMLERROR == 0)} {
    if {[string equal $MODE "mentor"]} {
        if {[catch  {glob -type f [file join $HTMLDIR "pages" "\{a,z\}*"]} msg]} {
            logfile "Found no assertion htmlfile"
            set assert_htmlist ""
        } else {
            set assert_htmlist [glob -type f [file join $HTMLDIR "pages" "\{a,z\}*"]]
        }
        if {[catch  {glob -type f [file join $HTMLDIR "pages" "\{g\}*"]} msg]} {
            logfile "Found no covergroup htmlfile"
            set cover_htmlist ""
        } else {
            set cover_htmlist [glob -type f [file join $HTMLDIR "pages" "\{g\}*"]]
        }
        if {[catch  {glob -type f [file join $HTMLDIR "pages" "\{r\}*"]} msg]} {
            logfile "Found no test htmlfile"
            set test_htmlist ""
        } else {
            set test_htmlist [glob -type f [file join $HTMLDIR "pages" "\{r\}*"]]
        }
        if {[catch  {glob -type f [file join $HTMLDIR "pages" "\{d\}*"]} msg]} {
            logfile "Found no directive htmlfile"
            set directive_htmlist ""
        } else {
            set directive_htmlist [glob -type f [file join $HTMLDIR "pages" "\{d\}*"]]
        }
        if {[catch  {glob -type f [file join $HTMLDIR "pages" "\{z\}*"]} msg]} {
            logfile "Found no code coverage  htmlfile"
            set code_cover_htmlist ""
        } else {
            set code_cover_htmlist [glob -type f [file join $HTMLDIR "pages" "\{z\}*"]]
        }

    } elseif {[string equal $MODE "synopsys"]} {
  
        if {[catch  {glob -type f [file join $HTMLDIR "assert*"]} msg]} {
            logfile "Found no assertion htmlfile"
            set assert_htmlist ""
        } else {
            set assert_htmlist [glob -type f [file join $HTMLDIR "assert*"]]
        }
        if {[catch  {glob -type f [file join $HTMLDIR "grp*"]} msg]} {
            logfile "Found no covergroup htmlfile"
            set cover_htmlist ""
        } else {
            set cover_htmlist [glob -type f [file join $HTMLDIR "grp*"]]
        }
        if {[catch  {glob -type f [file join $HTMLDIR "hier*"]} msg]} {
            logfile "Found no code coverage htmlfile"
            set code_cover_htmlist ""
        } else {
            set code_cover_htmlist [glob -type f [file join $HTMLDIR "hier*"]]
        }
    } elseif {[string equal $MODE "cadence"]} {
        if {[catch  {glob -type f [file join $HTMLDIR "report_html" "dir_1" "summ_*"]} msg]} {
            logfile "Found no Summary htmlfile"
            set cadence_htmlist ""
        } else {
            set cadence_htmlist [glob -type f [file join $HTMLDIR "report_html" "dir_1" "summ_*"]]
        }
    } elseif {[string equal $MODE "aldec"]} {
        if {[catch  {glob -type f [file join $HTMLDIR "fcov_html_reports_files" "table.html"]} msg]} {
            logfile "Found no Functional Coverage Summary htmlfile"
            set cover_htmlist ""
        } else {
            set cover_htmlist [glob -type f [file join $HTMLDIR "fcov_html_reports_files" "table.html"]]
        }
        if {[catch  {glob -type f [file join $HTMLDIR "ccov_html_reports_files" "hierarchy.html"]} msg]} {
            logfile "Found no Code Coverage Summary htmlfile"
            set code_cover_htmlist ""
        } else {
            set code_cover_htmlist [glob -type f [file join $HTMLDIR "ccov_html_reports_files" "hierarchy.html"]]
        }
    }
}

#############################################################################
###Procedure for filtering the links excluding files containing "work.xyz" type in scope or design unit.
proc filter_links {type_list} {
    set newlist ""
    logfile "\n Filtering links:"
    foreach var $type_list {
        set file [open "$var" r]
        set data [read $file]
        if {([regexp -linestop ".*<h.*>.*Scope:.*work\..+<\/h.*>.*" $data])} {
        } elseif {([regexp -linestop ".*<h.*>.*Design Unit:.*work\..+<\/h.*>.*" $data])} {
        } else {
            lappend newlist $var
        }
    }
    return $newlist
    logfile "Filtered the href links\n"
}
###End Proc filter_links

##############################################################################
#Calling procedure "filter_links" for filtering the list

if {[string equal $MODE "mentor"] && ($HTMLERROR == 0)} {
    set assert_htmlist [filter_links $assert_htmlist]
    #puts "new list:--[llength $assert_htmlist]\n $assert_htmlist"

    set cover_htmlist [filter_links $cover_htmlist]
    #puts "new list:--[llength $cover_htmlist]\n $cover_htmlist"

    set code_cover_htmlist [filter_links $code_cover_htmlist]
    #puts "new list:--[llength $code_cover_htmlist]\n $code_cover_htmlist"

    set test_htmlist [filter_links $test_htmlist]
    #puts "new list:--[llength $test_htmlist]\n $test_htmlist"

    set directive_htmlist [filter_links $directive_htmlist]
    #puts "new list:--[llength $directive_htmlist]\n $directive_htmlist"
}

############################################################################
##Procedure for extracting the link with the help of the priority 
proc link_include {link_name_list file_list MODE} {
    logfile "\nSearching href link for [lindex $link_name_list 0]"
    lappend link_name_list ""
    set link_name $link_name_list
    #Any IVS link name
    set name [lindex $link_name_list 0]
    if {[string equal $MODE "mentor"]} {
        set split_name [join [split $name "/"]]
    } elseif {[string equal $MODE "synopsys"] || [string equal $MODE "aldec"]} {
        set split_name [join [split $name ".:*/"]]
    } elseif {[string equal $MODE "cadence"]} {
        set split_name [join [split $name "."]]
    }
    set desird_priority [llength $split_name]
    # Check for the result if "" than exit
    if {([lindex $link_name 1]  == "") && [string equal $MODE "mentor"]} {
        return $link_name_list
    }
    set join_name [join $split_name "\.\*"]
    ##For entries in the regular expressions at various formats
    set number_entry $desird_priority
    set tmp_list ""
    foreach var $split_name {
        lappend tmp_list $var
        set join_name$number_entry [join $tmp_list "\.\*"]
        incr number_entry -1 
    }
    
    #Checking the files recursively
    foreach file_name $file_list {
        set current_priority [llength $split_name]
        #Storing file in a variable
        set file [open $file_name r]
        set data [read $file]
        close $file
        ##For Cadence
        if {[string equal $MODE "cadence"]} {
           if {[regexp -linestop ".*Coverage Summary Report.*" $data]} {
              if {[regexp -linestop ".*Instance name:.*$join_name *\<BR\> *" $data]} {
                set current_priority 0
              } elseif {[regexp  ".*$join_name.*" $data]} {
                  set number_entry 1
                  foreach var $split_name {
                      if {[regexp -linestop ".*Instance name:.*[subst $[subst join_name$number_entry]] *\<BR\> *" $data]} {
                          if {[llength $split_name] == 2} {
                             set current_priority 1
                          } else {
                             set current_priority $number_entry
                          }
                          break
                      }
                      incr number_entry
                  }
              }
           }
        #Aldec
        } elseif {[string equal $MODE "aldec"]} {
           if {[regexp -linestop ".*href=.*tree.css.*" $data]} {
               set current_priority 0
           } elseif {[regexp -linestop ".*type=\"text/css.*" $data]} {
               set current_priority 0
           } 
        ##For Test(Mentor And Synopsys)
        } elseif {([lindex $link_name 2] == "Test") && [string equal $MODE "mentor"]} {
            if {[regexp "Test:\\s*$name" $data match submatch]} {
                set current_priority 0
            }

            ##For Directive
        } elseif {([lindex $link_name 2] == "Directive") && [string equal $MODE "mentor"]} {
            if {[regexp -linestop "(Questa|ModelSim).*Cover Directive Report.*" $data]} {
                if {[regexp -linestop "Scope:.*$join_name.*" $data]} {
                    set current_priority 0
                } elseif {[regexp  ".*$join_name.*" $data]} {
                    set number_entry 1
                    foreach var $split_name {
                        if {[regexp -linestop "Scope:.*[subst $[subst join_name$number_entry]].*" $data]} {
                            set current_priority [expr $number_entry -1]
                            break
                        }
                        incr number_entry
                    }
                }
            }

            ##For Covergroup,Coverpoint and Cross
        } elseif {( ([lindex $link_name 2] == "CoverGroup") \
                        || ([lindex $link_name 2] == "CoverPoint") || ([lindex $link_name 2] == "Cross") ) && [string equal $MODE "mentor"]} {
            if {[regexp -linestop "(Questa|ModelSim).*Covergroup Coverage Report.*" $data]} {
                if {[regexp -linestop "Scope:.*$join_name.*" $data]} {
                    set current_priority 0
                } elseif {[regexp  ".*$join_name.*" $data]} {
                    set number_entry 1
                    foreach var $split_name {
                        if {[regexp -linestop "Scope:.*[subst $[subst join_name$number_entry]].*" $data]} {
                            set current_priority $number_entry
                            break
                        }
                        incr number_entry
                    } 
                }
            }
        } elseif {( ([lindex $link_name 2] == "CoverGroup") || ([lindex $link_name 2] == "CoverPoint") \
                                  || ([lindex $link_name 2] == "Cross") ) && [string equal $MODE "synopsys"]} {
            if {[regexp -linestop ".*Unified\\s*Coverage\\s*Report\\s*::\\s*Group\\s*::\\s*[lindex $link_name_list 0].*" $data] \
                    && [regexp -linestop ".*[lindex $link_name_list 1].*" $data] } { 
                set current_priority 0
            } elseif {[regexp -linestop ".*$join_name.*" $data] && [regexp -linestop ".*[lindex $link_name_list 1].*" $data]} {
                set current_priority 1
            } elseif {[regexp ".*$join_name.*" $data] && [regexp -linestop ".*[lindex $link_name_list 1].*" $data]} {
                set current_priority 2
            }
            
            ##For Code Coverage
		} elseif {( ([lindex $link_name 2] == "Branch") || ([lindex $link_name 2] == "Condition") \
                        || ([lindex $link_name 2] == "fsm") || ([lindex $link_name 2] == "FSM_Trans") \
                        || ([lindex $link_name 2] == "Toggle") || ([lindex $link_name 2] == "Statement") ) && [string equal $MODE "mentor"]} {
            if {[regexp -linestop "(Questa|ModelSim).*Coverage Summary.*" $data]} {
                set vpi_type [split [lindex $link_name 2] "_"]
                set vpi_type [join $vpi_type "\.\*"]
                if {[regexp -linestop "Scope:.*$join_name.*" $data] && [regexp -linestop "$vpi_type.*" $data] \
                        && [regexp -linestop "name:.*$join_name\.htm.*" $data]} {
                    set current_priority 0
                } elseif {[regexp ".*$join_name.*" $data] && [regexp -linestop "$vpi_type.*" $data] \
                              && [regexp -linestop "name:.*$join_name\.htm.*" $data]} {
                    set number_entry 1
                    foreach var $split_name {
                        if {[regexp -linestop "Scope:.*[subst $[subst join_name$number_entry]].*" $data]} {
                            set current_priority $number_entry
                            break
                        }
                        incr number_entry
                    }
                }
            }

        } elseif {( ([lindex $link_name 2] == "Branch") || ([lindex $link_name 2] == "Condition") \
                        || ([lindex $link_name 2] == "FSM") \
                        || ([lindex $link_name 2] == "Toggle") || ([lindex $link_name 2] == "Statement") ) && [string equal $MODE "synopsys"]} {
                set pattern ".*$join_name.*" 
            if {[regexp -linestop "Design Hierarchy" $data] && [regexp {[subst $pattern]} $data] \
                                          && [regexp -linestop ".*[lindex $link_name_list 1].*" $data]} {  
                    set current_priority 0
            }

        ##For Assertion
        } elseif {([lindex $link_name 2] == "Assertion") && [string equal $MODE "mentor"]} {
            if {[regexp -linestop "(Questa|ModelSim).*Assertion Coverage Report.*" $data]} {
                if {[regexp -linestop "Scope:.*$join_name.*" $data] \
                        && [regexp -linestop "[lindex $link_name 2].*" $data]} {
                    set current_priority 0
                } elseif {[regexp ".*$join_name.*" $data] && [regexp -linestop "[lindex $link_name 2].*" $data]} {
                    set number_entry 1
                    foreach var $split_name {
                        if {[regexp -linestop "Scope:.*[subst $[subst join_name$number_entry]].*" $data]} {
                            set current_priority $number_entry
                            break
                        }
                        incr number_entry
                    }
                }
            } elseif {[regexp -linestop "Questa.*Coverage Summary.*" $data]} {
                if {[regexp -linestop "Scope:.*$join_name.*" $data] && [regexp -linestop "[lindex $link_name 2].*" $data] \
                        && [regexp -linestop "name:.*$join_name\.htm.*" $data]} {
                    set current_priority 0
                } elseif {[regexp ".*$join_name.*" $data] && [regexp -linestop "[lindex $link_name 2].*" $data] \
                              && [regexp -linestop "name:.*$join_name\.htm.*" $data]} {
                    set number_entry 1
                    foreach var $split_name {
                        if {[regexp -linestop "Scope:.*[subst $[subst join_name$number_entry]].*" $data]} {
                            set current_priority $number_entry
                            break
                        }
                        incr number_entry
                    }
                }
            }
        } elseif {[regexp -linestop "Unified Coverage Report *:: *Assertions.*" $data] && [string equal $MODE "synopsys"]} {
            if {[regexp -linestop "[lindex $link_name_list 2].*" $data]} {
                set current_priority 1
            } elseif {[regexp ".*$join_name.*" $data]} {
                set number_entry 1
                foreach var $split_name {
                    if {[regexp -linestop ".*[subst $[subst join_name$number_entry]].*" $data]} {
                        set current_priority $number_entry
                        break
                    }
                    incr number_entry
                }
            }
        }        
        
        ###Setting up link in the main link variable
        if {($desird_priority > $current_priority) } {
            set desird_priority $current_priority
            set link_name_list [lreplace $link_name_list end end "$file_name" ]
        }

        if {$desird_priority == "0"} {
            logfile "$link_name_list file set for [lindex $link_name_list 0]\n"
            return $link_name_list
        }
           
        if {($desird_priority == $current_priority) && ([llength $split_name] == 1) } {
            set desird_priority $current_priority
            set link_name_list [lreplace $link_name_list end end "$file_name" ]
        }
    }
    logfile "$link_name_list file set for [lindex $link_name_list 0]\n"
    return $link_name_list

}
######proc link_include end########

##########################################################################################
### Procedure for making final list including links
proc adding_link {type_list html_pages_list MODE} {
    set list1 ""
    set type_name $type_list
    foreach link_struct $type_name {
        # Store Tests in final list 
        if {[regexp "Test" [lindex $link_struct 2]]} {
            lappend list1 [link_include $link_struct $html_pages_list $MODE]
            logfile "Storing $link_struct for $MODE"

            # Store Assertions in final list
        } elseif {[regexp "Assertion" [lindex $link_struct 2]]} {
            lappend list1 [link_include $link_struct $html_pages_list $MODE]
            logfile "Storing $link_struct for $MODE"

            # Store Covergroups, Coverpoints, Cross in final list
        } elseif {[regexp "CoverGroup||CoverPoint||Cross" [lindex $link_struct 2]]} {
            lappend list1 [link_include $link_struct $html_pages_list $MODE]
            logfile "Storing $link_struct for $MODE"

            # Store Directives in final list
        } elseif {[regexp "Directive" [lindex $link_struct 2]]} {
            lappend list1 [link_include $link_struct $html_pages_list $MODE]
            logfile "Storing $link_struct for $MODE"

            # Store Branches, Conditions,FSM_States, FSM_Transitions, Statements and Toggles Coverage in final list
		} elseif {[regexp "Branch|Condition|fsm|FSM_Transition|Statement|Toggle" [lindex $link_struct 2]]} {	
        # elseif {[regexp "Branch||Condition||FSM_State||FSM_Transition||Statement||Toggle" [lindex $link_struct 2]]} 
            lappend list1 [link_include $link_struct $html_pages_list $MODE]
            logfile "Storing $link_struct for $MODE"
        }
    }
    return $list1
}
### End Proc adding_link
####################################################################################
proc include_metric {stage m_list} {
    set final_mlist {}
    #set types "Test Assertion CoverGroup CoverPoint Cross Directive Branch Condition FSM_State FSM_Transition Statement Toggle"
    set types "Test Assertion CoverGroup CoverPoint Cross Directive Branch Condition fsm FSM_Transition Statement Toggle"
    if {$stage == 1} {
        set m_list [split $m_list ","]
        foreach list_ele $m_list {
            foreach type $types {
               if {[string equal "[lindex $list_ele 2]" $type]} { 
                   #puts "ELE: [lindex $list_ele 2]"
                   lappend final_mlist $list_ele
               }
            }
        }
    } else {
        set final_mlist ''
    }
    return $final_mlist
}

####################################################################################
##Making the final list in which the html file link is added
set FINAL_LIST ""
puts ""
if {[string equal $MODE "mentor"]} {
    if {[info exists assert_htmlist]} {
      lappend FINAL_LIST [adding_link $ASSERTION_LIST $assert_htmlist $MODE]
      puts "No. of Assertions-                   [llength $ASSERTION_LIST]"
    }
    if {[info exists cover_htmlist]} {
      lappend FINAL_LIST [adding_link $COVERAGE_LIST $cover_htmlist $MODE]
      puts "No. of Covergroups/Coverpoint/Cross- [llength $COVERAGE_LIST]"
    }
    if {[info exists test_htmlist]} {
      lappend FINAL_LIST [adding_link $TEST_LIST $test_htmlist $MODE]
      puts "No. of Tests-                        [llength $TEST_LIST]"
    }
    if {[info exists directive_htmlist]} {
      lappend FINAL_LIST [adding_link $DIRECTIVE_LIST $directive_htmlist $MODE]
      puts "No. of Directives-                   [llength $DIRECTIVE_LIST]"
    }
    if {[info exists code_cover_htmlist]} {
      lappend FINAL_LIST [adding_link $CODE_COVERAGE_LIST $code_cover_htmlist $MODE]
      puts "No. of Code-Coverage-                [llength $CODE_COVERAGE_LIST]"
    }
}

if {[string equal $MODE "cadence"]} {
    if {[info exists cadence_htmlist] || ($nodb)} {
       lappend FINAL_LIST [adding_link $ASSERTION_LIST $cadence_htmlist $MODE]
       lappend FINAL_LIST [adding_link $COVERAGE_LIST $cadence_htmlist $MODE]
       lappend FINAL_LIST [adding_link $CODE_COVERAGE_LIST $cadence_htmlist $MODE]
       lappend FINAL_LIST [adding_link $TEST_LIST $cadence_htmlist $MODE]
    }
    puts "No. of Assertions-                   [llength $ASSERTION_LIST]"
    puts "No. of Covergroups/Coverpoint/Cross- [llength $COVERAGE_LIST]"
    puts "No. of Code-Coverage-                [llength $CODE_COVERAGE_LIST]"
    puts "No. of Tests-                        [llength $TEST_LIST]"
}

if {[string equal $MODE "aldec"]} {
    if {[info exists cover_htmlist]} {
       lappend FINAL_LIST [adding_link $COVERAGE_LIST $cover_htmlist $MODE]
       puts "No. of Covergroups/Coverpoint/Cross- [llength $COVERAGE_LIST]"
    }
    if {[info exists code_cover_htmlist]} {
       lappend FINAL_LIST [adding_link $CODE_COVERAGE_LIST $code_cover_htmlist $MODE]
       puts "No. of Statements/Branches- [llength $CODE_COVERAGE_LIST]"
    }
}

if {[string equal $MODE "synopsys"]} {
    if {(!([string equal "" $DB1]) && !($exitDB1)) || ($nodb)} {
        lappend FINAL_LIST [adding_link $ASSERTION_LIST $assert_htmlist $MODE]
        lappend FINAL_LIST [adding_link $COVERAGE_LIST $cover_htmlist $MODE]
        puts "No. of Assertions-                   [llength $ASSERTION_LIST]"
        puts "No. of Covergroups/Coverpoint/Cross- [llength $COVERAGE_LIST]"
    }
    if {[llength $CODE_COVERAGE_LIST] != 0} {
        lappend FINAL_LIST [adding_link $CODE_COVERAGE_LIST $code_cover_htmlist $MODE]
        puts "No. of Code-Coverage-                [llength $CODE_COVERAGE_LIST]"
    }
}

#Include metric entered by the user manually in Command Prompt
set new_metric [include_metric $metric $metric_list]

lappend FINAL_LIST $new_metric
lappend MASS_LIST $new_metric

# Setting All data in a list
set whole_list ""
logfile "#########################################################\n\n#####STORED DATA:#####"
set a 0

for {set i 0} {$i <= [expr [llength $FINAL_LIST] - 1 ]} {incr i} {
    set tmp_list [lindex $FINAL_LIST $i]
    foreach var $tmp_list {
        incr a
        logfile "$a:[llength $var] $var"

    }
}
############################################################################
#FILTERING THE Metrics for Plan Creation
proc filter_metric {filter metric_list} {
   set metric {}
   if {![string equal "" $filter]} {
      set filter [join [split $filter ".:\/"] "\*"]
      foreach metric_type $metric_list {
        foreach metric_t $metric_type {
          set metric_name [lindex $metric_t 0]
          if {[string match "${filter}*" $metric_name]} {
              lappend metric "$metric_t"
          }
        }
      }
   } else {
      set metric "$metric_list"
   }
   return $metric
}

#############################################################################
#File name parsing
set xmlpath $OUTDIR
if {[file isdirectory "$OUTDIR"]} {
    set fname ""
    if {[string equal "mentor" $MODE]} {
       set fname [string map "[file extension $DB] {}" [file tail $DB]]
    } elseif {[string equal "synopsys" $MODE]} {
       if {![string equal "" $DB1]} {
          set fname [string map "[file extension $DB1] {}" [file tail $DB1]]
       } elseif {![string equal "" $DB2]} {
          set fname [string map "[file extension $DB2] {}" [file tail $DB2]]
       } elseif {$nodb} {
          set fname [file tail $RPT]
       }
    } elseif {[string equal "cadence" $MODE]} {
       if {![string equal "" $DB]} {
          set fname [lindex [file split $DB] end ]
       } elseif {$nodb} {
          set fname [string map "[file extension $RPT] {}" [file tail $RPT]]
       } elseif {![string equal "" $DB4]} {
         #set fname [lindex [file split $DB4] end ]
         set fname [string map "[file extension $DB4] {}" [file tail $DB4]]
       }
    } elseif {[string equal "aldec" $MODE]} {
       set fname [string map "[file extension $DB3] {}" [file tail $DB3]]
    }
    
}
#############################################################################
#Remove filter from the metric name
proc filter_hier {filter metric_name} {
   set filterd_metric ""
   if {![string equal "" $filter]} {
     set filterd_metric [string map [list $filter ""] $metric_name] 
   }
   return $filterd_metric
}


#Changing Hierarchy spliter from '.|::' to '/'
proc hier_replace {val keep_hier} {
   set metric_name ""
   if {!($keep_hier)} { 
      set metric_name [join [split $val ".:"] "\/"]
      set metric_name "/$metric_name"
      regsub {\/\/+} $metric_name "\/" metric_name
   } else {
      set metric_name $val
   }
  
   return $metric_name
}

######proc for hierarchical IVS Plan XML########

####sorting hdl_path for unique values###
proc uniq_list {input_LIST} {
    foreach ele $input_LIST {
       set arr_temp [split $ele "/"]
       set input_LIST [linsert $input_LIST end [lindex $arr_temp 0]]
       for {set i 1} {$i  <= [expr [llength $arr_temp] - 1 ]} {incr i} {
           set list($i) {}
           for {set j 0} {$j <= $i} {incr j} {
              lappend list($i) [lindex $arr_temp $j]
            }
           set list_element($i) [join $list($i) "/"]
           lappend input_LIST $list_element($i)
        }
    }
    set input_LIST [lsort -unique $input_LIST]
    return $input_LIST
}
######sorting hdl paths#####
proc sort_list {input} {
   set length_list {}
   set var 0
   set final_list {}
   foreach val $input {
     set new_list($var) [split $val "/"]
     set length_list [concat $length_list [llength new_list($var)]]
     set var [expr $var+1]
   }
   set length_list [lsort $length_list]
   set max_length [lindex [expr [llength $length_list-1] ] ]
   for {set i 1} {$i<=$max_length} {incr i} {
       for {set j 0} {$j<$var} {incr j} {
          if {[llength $new_list($j)]==$i} {
             set new_word [join $new_list($j) "/"]
             set final_list [concat $final_list $new_word]
          }
       }
    }

   return $final_list
}


########proc to replace regexp special characters in hdlpath##
proc createValidregexpPattern {inStr} {
   set specialcharacter {"*" "+" "?" "." "{" "}" "$" "^" "(" ")" "[" "]" "\\"}
   foreach splchar $specialcharacter {
      if {$splchar=="\\"} {
         set searchstr \$splchar
      } else {
           set searchstr \\$splchar
      }
      regsub $searchstr $inStr "\\$splchar" inStr
    }
 return $inStr
}

proc removeRegExpexceptions {inStr} {
    #  regsub \\\\ $inStr "\\" inStr
    set splchar {(\\)+([\*\+\?\.\{\}\(\)\[\]])+}
     regsub -all $splchar $inStr {\2} inStr
return $inStr
}

#########proc to find out the least common path#####
proc summary_config {xmlfile} {

puts $xmlfile "  \<summaryconfig\>"
  puts $xmlfile " [string repeat " " 2] \<expectSingleResult\>false\<\/expectSingleResult\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"test\" isselected=\"true\"\>tally\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"message\" isselected=\"true\"\>distinct\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"assertion\" isselected=\"true\"\>tally\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"covergroup\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"coverpoint\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"cross\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"branch\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"condition\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"directive\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"expression\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"fsm\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"statement\" isselected=\"true\"\>average\<\/value\>"
    puts $xmlfile " [string repeat " " 2] \<value type=\"toggle\" isselected=\"true\"\>average\<\/value\>"
puts $xmlfile "  \<\/summaryconfig\>"

}

proc hierarchical_list {first_list second_list} {
 set final_list {}
 foreach ele $first_list {
    lappend final_list $ele
 }
 foreach item $second_list {
    set second_list [lreplace $second_list [lsearch $second_list $item] [lsearch $second_list $item]]
    set lcp_list {}
    set shall_be_mg ""

    foreach subitem $second_list {
      set least_common_path {}
      set all {}
      if {[regexp ^$item/ $subitem]} {
         regexp ^$item/(\[^/\]+) $subitem all least_common_path
         lappend lcp_list $item/$least_common_path
      }
    }
    set lcp_list [lsort -unique $lcp_list]

    if {[llength $lcp_list] > 1 | [llength $lcp_list] == 0 } {
        set shall_be_mg 0
     }
    if {$shall_be_mg==0} {
        lappend final_list $item
     }
 }
 return $final_list
}
#####end of proc to find the least common path#########
###main proc for hierarchical IVS Plan XML##### 
proc createXml {inList xmlfile} {
   for {set i 0} {$i<[llength $inList]} {incr i} {
      set name {}
      set nextele {}
      set nextlist {}
      set hdl_path {}
      set type {}
      set var [lindex $inList $i]
      set var [createValidregexpPattern $var]
      if {[regexp {.*?\/*?[^\/]+\:.+$} $var]} {
          regexp {(.*?)\/*?([^\/]+)\:(.+)$} $var a hdl_path name type
          #(need review) regular expression for extracting metric name,type ###
          puts -nonewline  $xmlfile "[string repeat " " 4]\<metric name=\"$name\" template=\"metric\" type=\"[string tolower $type]\""
          if {$hdl_path==""} {
             puts -nonewline  $xmlfile "\>\n"
             summary_config $xmlfile
             puts $xmlfile "[string repeat " " 4]\<\/metric\> \<\!-- $name --\>"
          } else  {
             puts -nonewline  $xmlfile  " hdl_path=\"$hdl_path\"\>\n"
             summary_config $xmlfile
        puts $xmlfile "[string repeat " " 4]\<\/metric\> \<\!-- $name --\>"
          }
       } else {
          set name $var
          set hdl_path $var
       }
     
      if {[regexp {:.+} $var]} {
         #removing "type" from $var to create hierarchy
         regsub :.+$ $var "" var
         #done removing "type"
         ###call proc to replace regexp special characters from $var#####
         set var [createValidregexpPattern $var]
       }
       foreach ele $inList {
           if {[regexp ^$var\/ $ele]} {
                 regsub ^$var\/ $ele "" nextele
                 set nextele [removeRegExpexceptions $nextele]
                 set nextlist [concat $nextlist $nextele]
                 set ele [createValidregexpPattern $ele]
                 set inList [lreplace $inList [lsearch $inList $ele] [lsearch $inList $ele]]
            }
        }

      if { !([llength $nextlist] == 0)} {
         ##regsub for extracting metricgroup hdlpath###
        regsub :$type$ $var "" hdlpath
        set name [split $var "\/"]
        set name [lindex $name end]
        set name [removeRegExpexceptions $name]
        set hdlpath [removeRegExpexceptions $hdlpath]
        set var [removeRegExpexceptions $var]
        puts -nonewline  $xmlfile "[string repeat " " 4]\<metric name=\"$name\" template=\"metricgroup\" hdl_path=\"$hdlpath\"\>\n"
        summary_config $xmlfile
        createXml $nextlist $xmlfile
        puts $xmlfile "[string repeat " " 4]\<\/metric\> \<\!-- $name --\>"
      }
   }

}
###end of proc for hierarchichal IVSPlan####
################################################
#Creating XML for importing data /VPIS in plan
if {[regexp "(type|name|hierarchy)" $imp_val]} {
    if {[string equal $MODE "aldec"]} {
       if {[info exists COVERAGE_LIST ]} {
          logfile "putting COVERAGE_LIST in MASS_LIST"
          lappend MASS_LIST $COVERAGE_LIST
       }
       if {[info exists Branch_list ]} {
          logfile "putting Branch_list in MASS_LIST"
          lappend MASS_LIST $Branch_list
       }
       if {[info exists Statement_list ]} {
          logfile "putting Statement_list in MASS_LIST"
          lappend MASS_LIST $Statement_list
       }
    } elseif {[string equal $MODE "synopsys"]} {
       if {[info exists TEST_LIST ]} {
          logfile "putting TEST_LIST in MASS_LIST"
          lappend MASS_LIST $TEST_LIST
       }
       if {[info exists ASSERTION_LIST]} {
          logfile "putting ASSERTION_LIST in MASS_LIST"
          lappend MASS_LIST $ASSERTION_LIST
       }
       if {[info exists DIRECTIVE_LIST]} {
          logfile "putting DIRECTIVE_LIST in MASS_LIST"
          lappend MASS_LIST $DIRECTIVE_LIST
       }
       #if {[info exists CoverGroup]} {
        #  logfile "putting CoverGroup in MASS_LIST"
        #  lappend MASS_LIST $CoverGroup
       #}
       #if {[info exists CoverGroup_instance]} {
        #  logfile "putting CoverGroup_instance in MASS_LIST"
         # lappend MASS_LIST $CoverGroup_instance
       #}
       #if {[info exists CoverPoint]} {
        #  logfile "putting CoverPoint in MASS_LIST"
         # lappend MASS_LIST $CoverPoint
       #}
      # if {[info exists CoverPoint_instance]} {
       #   logfile "putting CoverPoint_instance in MASS_LIST"
       #   lappend MASS_LIST $CoverPoint_instance
      # }
       #if {[info exists Cross]} {
        #  logfile "putting Cross in MASS_LIST"
         # lappend MASS_LIST $Cross
       #}
       
       #if {[info exists Cross_instance]} {
        #  logfile "putting Cross_instance in MASS_LIST"
         # lappend MASS_LIST $Cross_instance
       #}
       if {[info exists COVERAGE_LIST]} {
          logfile "putting Cross_instance in MASS_LIST"
          lappend MASS_LIST $COVERAGE_LIST
       }
       if {([info exists CODE_COVERAGE_LIST] == 1) && ($imp_code_cov == 1)} {
          logfile "putting CODE_COVERAGE_LIST in MASS_LIST"
          lappend MASS_LIST $CODE_COVERAGE_LIST
       }

   } elseif {[string equal $MODE "cadence"] || [string equal $MODE "mentor"]} {
    #   if {[info exists TEST_LIST ]} {
     #     logfile "putting TEST_LIST in MASS_LIST"
      #    lappend MASS_LIST $TEST_LIST
       #}
       if {![string equal "" $DB4]} {
        if {[info exists TEST_LIST1]} {
          logfile "putting TEST_LIST1 in MASS_LIST"
          lappend MASS_LIST $TEST_LIST1
         }
        } else {
           if {[info exists TEST_LIST ]} {
           logfile "putting TEST_LIST in MASS_LIST"
           lappend MASS_LIST $TEST_LIST
           }
        }
       if {[info exists ASSERTION_LIST]} {
          logfile "putting ASSERTION_LIST in MASS_LIST"
          lappend MASS_LIST $ASSERTION_LIST
       }
       if {[info exists DIRECTIVE_LIST]} {
          logfile "putting DIRECTIVE_LIST in MASS_LIST"
          lappend MASS_LIST $DIRECTIVE_LIST
       }
       #if {[info exists CoverGroup]} {
        #  logfile "putting CoverGroup in MASS_LIST"
         # lappend MASS_LIST $CoverGroup
       #}
       #if {[info exists CoverGroup_instance]} {
        #  logfile "putting CoverGroup_instance in MASS_LIST"
         # lappend MASS_LIST $CoverGroup_instance
       #}
       #if {[info exists CoverPoint]} {
        #  logfile "putting CoverPoint in MASS_LIST"
         # lappend MASS_LIST $CoverPoint
       #}
       #if {[info exists CoverPoint_instance]} {
        #  logfile "putting CoverPoint_instance in MASS_LIST"
         # lappend MASS_LIST $CoverPoint_instance
       #}
       #if {[info exists Cross]} {
        #  logfile "putting Cross in MASS_LIST"
         # lappend MASS_LIST $Cross
       #}
       #if {[info exists Cross_instance]} {
        #  logfile "putting Cross_instance in MASS_LIST"
         # lappend MASS_LIST $Cross_instance
       #}
       if {[info exists COVERAGE_LIST]} {
          logfile "putting Cross_instance in MASS_LIST"
          lappend MASS_LIST $COVERAGE_LIST
       }
       if {$imp_code_cov == 1} {
          if {[info exists Toggle]} {
             logfile "putting Toggle in MASS_LIST"
             lappend MASS_LIST $Toggle
          }
          if {[info exists Expression]} {
             logfile "putting Toggle in MASS_LIST"
             lappend MASS_LIST $Expression
          }
          if {[info exists Branch]} {
             logfile "putting Branch in MASS_LIST"
             lappend MASS_LIST $Branch
          }
		  if {[info exists fsm]} {
             logfile "putting fsm in MASS_LIST"
             lappend MASS_LIST $fsm
          }
          #if {[info exists FSM_State]} 
          #   logfile "putting FSM_State in MASS_LIST"
          #   lappend MASS_LIST $FSM_State
          #
          #if {[info exists FSM_Trans ]} 
          #   logfile "putting FSM_Trans in MASS_LIST"
          #   lappend MASS_LIST $FSM_Trans
          #
          if {[info exists Condition]} {
             logfile "putting Condition in MASS_LIST"
             lappend MASS_LIST $Condition
          }
          if {[info exists Statement]} {
             logfile "putting Statement in MASS_LIST"
             lappend MASS_LIST $Statement
          }
       }
   }
   

   set tmp_list [filter_metric $FILTER $MASS_LIST]
   if {![string equal "" $FILTER]} {
      set MASS_LIST {}
      lappend MASS_LIST $tmp_list
   } else {
      set MASS_LIST $tmp_list
   }
   #puts "$MASS_LIST"
   #IMPORT BY TYPE
   if {[string equal "type" $imp_val]} {
      set xmlfile [file join $xmlpath "${fname}_type_ivs_plan.xml"]
      set xml [open "$xmlfile" w+]
      logfile "\n Making xml file for IVS IMPORT......"
      puts $xml "\<?xml version\=\"1.0\" encoding\=\"ISO-8859-1\"?\>\n\<plan name=\"IVSPlan\"\>"
      if {!([llength $MASS_LIST] == "0")} {
      puts $xml "  \<metric template =\"metricgroup\" name=\"top\" heading=\"1\"\>"
      for {set i 0} {$i <= [expr [llength $MASS_LIST] - 1 ]} {incr i} {
       set tmp_list [lindex $MASS_LIST $i]
       if {![string equal [lindex [lindex $tmp_list 0] 2] ""]} {
         if {[string equal [lindex [lindex $tmp_list 0] 2] "Test"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"Tests\" heading=\"1\"\>"
             summary_config $xml
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Assertion"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"Assertion\" heading=\"1\"\>"
             summary_config $xml
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "CoverGroup"] || [string equal [lindex [lindex $tmp_list 0] 2] "CoverPoint"] || [string equal [lindex [lindex $tmp_list 0] 2] "Cross"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"FunctionalCoverage\" heading=\"1\"\>"
             summary_config $xml
         #} elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "CoverPoint"]} {
         #    puts $xml "        \<metric template =\"metricgroup\" name=\"FunctionalCoverage CoverPoint\" heading=\"1\"\>"
         #} elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Cross"]} {
          #   puts $xml "        \<metric template =\"metricgroup\" name=\"FunctionalCoverage Cross\" heading=\"1\" \>"
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Directive"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"Directive\" heading=\"1\" \>"
             summary_config $xml
         } elseif  {[regexp "FSM|Branch|Condition|Toggle|Statement" [lindex [lindex $tmp_list 0] 2] ] && [string equal "synopsys" $MODE]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"CodeCoverage All\" heading=\"1\" \>"
             summary_config $xml
         } elseif  {[string match "fsm*" [lindex [lindex $tmp_list 0] 2] ]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"CodeCoverage FSM\" heading=\"1\"\>"
             summary_config $xml
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Branch"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"CodeCoverage Branch\" heading=\"1\"\>"
             summary_config $xml
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Condition"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"CodeCoverage Condition\" heading=\"1\"\>"
             summary_config $xml
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Toggle"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"CodeCoverage Toggle\" heading=\"1\"\>"
             summary_config $xml
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Statement"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"CodeCoverage Statement\" heading=\"1\"\>"
         } elseif  {[string equal [lindex [lindex $tmp_list 0] 2] "Expression"]} {
             puts $xml "        \<metric template =\"metricgroup\" name=\"CodeCoverage Expression\" heading=\"1\"\>"
             summary_config $xml
         }
        
         foreach var $tmp_list {
            if {[string equal [lindex $var 1] ""]} {continue}
            if {[string equal "" [lindex $var 0]]} {continue}
            set metric_name [hier_replace "[lindex $var 0]" "$keep_hier"]
            set hdl_path [string trimleft $metric_name "\/"]
            set metric_arr [split $metric_name "/"]
            set hdl_arr [lreplace $metric_arr end end]
            set hdl_path [join $hdl_arr "/"]
            set name_metric [lindex $metric_arr [expr [llength $metric_arr] - 1]]
            if {[string match "fsm*" [lindex $var 2]]} {
             puts $xml "        \<metric template=\"metric\" name=\"$name_metric\" type=\"fsm\" hdl_path=\"$hdl_path\" heading=\"2\" \>"
             summary_config $xml
             puts $xml "        \<\/metric\>"
            } else {
             puts $xml "        \<metric template=\"metric\" name=\"$name_metric\" type=\"[string tolower [lindex $var 2]]\" hdl_path=\"$hdl_path\" heading=\"2\" \>"
             
              summary_config $xml
              puts $xml "        \<\/metric\>"
            }
         }
        puts $xml "        \<\/metric\>"
        }
       }
      puts $xml "  \<\/metric\>"
     }
     puts $xml "  \<\/plan\>"
     close $xml
      
    
   } elseif {[string equal "hierarchy" $imp_val]} {
    set xmlfile [file join $xmlpath "${fname}_hier_ivs_plan.xml"]
    set xml [open "$xmlfile" w+]
    logfile "\n Making xml file for IVS IMPORT......"
    puts $xml "\<?xml version\=\"1.0\" encoding\=\"ISO-8859-1\"?\>\n\<plan name=\"IVSPlan\"\>"
    if {!([llength $MASS_LIST] == "0")} {
      puts $xml "  \<metric template =\"metricgroup\" name=\"top\" heading=\"1\"\>"
      set total {}
      for {set i 0} {$i <= [expr [llength $MASS_LIST] - 1 ]} {incr i} {
        set tmp_list [lindex $MASS_LIST $i]
        foreach var $tmp_list {
            if {[string equal [lindex $var 1] ""]} {continue}
            if {[string equal "" [lindex $var 0]]} {continue}
            set metric_name [hier_replace "[lindex $var 0]" "$keep_hier"]
            set hdl_path [string trimleft $metric_name "\/"]
            regsub -all "\/+" $hdl_path "\/" hdl_path 
            set metric_arr [split $metric_name "/"]
            set name_metric [lindex $metric_arr [expr [llength $metric_arr] - 1]]
            lappend total $name_metric $hdl_path [lindex $var 2]
            lappend final_path $hdl_path:[lindex $var 2]
         }
       }
       ####calling proc to create unique list of hdl_paths###
       set unique_list [uniq_list $final_path]
       ###code to create two separate list one with ":" and other without####
       set first_list {}
       set second_list {}
       foreach ele $unique_list {
           if {[regexp {(.*?)\:(.*?)} $ele]} {
               lappend first_list $ele
           } else {
               lappend second_list $ele
           }
        }
       ###end of code for two separate list##########
       ####proc to find hierarchy of metricgroup######
       set final_list [hierarchical_list $first_list $second_list]
       ####proc to sort hdl_path according to ascending number of elements in path###
       set final_xml [sort_list $final_list]
       ####proc to create the final hierarchichal PLAN xml###
       createXml $final_xml $xml
       
      ###end of the proc##

      puts $xml "  \<\/metric\>"
     }
     puts $xml "  \<\/plan\>"
     close $xml

   } elseif {[string equal "name" $imp_val]} {
      #Combine the all lists in One List
      set TOTAL_LST {}
      foreach type $MASS_LIST { 
         foreach {VPI_LIST} $type {
            lappend TOTAL_LST $VPI_LIST
         }
      }
      if {[string match [lindex $TOTAL_LST 0] "''"]  } {
       set TOTAL_LST [lreplace $TOTAL_LST 0 0]
       }
      set xmlfile [file join $xmlpath "${fname}_ivs_plan.xml"]
      set xml [open "$xmlfile" w+]
      logfile "\n Making xml file for IVS IMPORT......"
      puts $xml "\<?xml version\=\"1.0\" encoding\=\"ISO-8859-1\"?\>\n\<plan name=\"IVSPlan\"\>"
      if {!([llength $TOTAL_LST] == "0")} {
       puts $xml " \<metric template =\"metricgroup\" name=\"top\" heading=\"1\"\>"
       summary_config $xml
       foreach list_item $TOTAL_LST {
        set metric_item [split $list_item]
        set hierarchy_path [lindex $metric_item 0]
        regsub -all "\:+" $hierarchy_path "\." hierarchy_path 
        if {[regexp {\{\.(.*)\}} $hierarchy_path ]} {
        regexp {\{\.(.*)\}} $hierarchy_path all hierarchy_path
        } elseif {[regexp {^\.(.*)} $hierarchy_path]} {
        regexp {^\.(.*)} $hierarchy_path all hierarchy_path
        } elseif {[regexp {^[\w]+\:.*$} $hierarchy_path]} {
           regsub -all "\:+" $hierarchy_path "\." hierarchy_path
        } elseif {[regexp {^[\w]+\..*$} $hierarchy_path]} {
          regsub -all "/" $hierarchy_path "\." hierarchy_path
        } elseif {[regexp {^/(.*)$} $hierarchy_path]} {
          regexp  {^/(.*)$} $hierarchy_path all $hierarchy_path
         regsub -all "/" $hierarchy_path "\." hierarchy_path 
        }
          
        set hierarchy_path_arr [split $hierarchy_path "."]
        set metric_name [lindex $hierarchy_path_arr end]
        set hdl_path [lreplace $hierarchy_path_arr end end]
        set hdl_path [join $hdl_path "/"]
        set metric_type [lindex $metric_item 2]
        if {[string match "FSM*" $metric_type]} {
              puts $xml "[string repeat " " 4] \<metric template=\"metric\" name=\"$metric_name\" hdl_path=\"$hdl_path\" type=\"fsm\"\>"
              summary_config $xml
              puts $xml "\<\/metric\>"
            } elseif {[string match "Test*" $metric_type]} {
              puts $xml "[string repeat " " 4] \<metric template=\"metric\" name=\"$metric_name\" hdl_path=\"$hdl_path\" type=\"[string tolower $metric_type]\"\>"
              summary_config $xml
              puts $xml "\<\/metric\>"
            } else {

            puts $xml "[string repeat " " 4] \<metric template=\"metric\" name=\"$metric_name\" hdl_path=\"$hdl_path\" type=\"[string tolower $metric_type]\"\>"
              summary_config $xml
              puts $xml "\<\/metric\>"
            } 
       }

   puts $xml "\<\/metric\>"
   puts $xml "\<\/plan\>"
   close $xml  
   }



#########################33

   if 0 {
      foreach list_item $TOTAL_LST {
         set lnk [string trim [lindex $list_item 0]]
         if {[string equal [lindex $list_item 1] ""]} {continue}
         set hier_elms [split $lnk ".\/::"]
         set ivs_hier_name ""
         if {[string equal "" [lindex $hier_elms 0]]} {
           set hier_elms [lreplace $hier_elms 0 1 "[lindex $hier_elms 1]"]
         }
         if {[llength $hier_elms] > 1} {
            #a hier item
            foreach hier_i $hier_elms {
               if {![string equal "" $hier_i]} {
                   set ivs_hier_name "${ivs_hier_name}/$hier_i"
               }
            }
         } else {
            #top most item
            set ivs_hier_name  "/[lindex $hier_elms 0]"
         }

         set tmp_hier_name [string range $ivs_hier_name 0 [string last "/" $ivs_hier_name ]]
         regsub {/(.*)/$} $tmp_hier_name "/\\1" tmp_hier_name
         if {![string equal $tmp_hier_name "/"]} {
            ##This is to make sure that condition never comes where - vpi group name is empty
            set ivs_hier_name $tmp_hier_name
         }

         if {[llength [array get resArr $ivs_hier_name]] > 0} {
            #we already have a key by this name , so append result to the existing list
            set newlst [lindex [array get resArr $ivs_hier_name] 1]
            lappend newlst $list_item
            array set resArr [list $ivs_hier_name $newlst]
         } else {
            array set resArr [list $ivs_hier_name [list $list_item]]
         }
      }

      proc getIVSHierName {ivshier} {
        set ivshier "\/[string map {. /} $ivshier]"
        return $ivshier
      }

      foreach {key val} [array get resArr] {
         set lookupKey "${key}/*"
         set updatedLst {}
         foreach elem $val {
            set ivs_vpi [getIVSHierName [lindex $elem 0]]
            set lookupVpi "${ivs_vpi}"
            if {[string equal [array names resArr $lookupVpi] ""]} {
               lappend updatedLst $elem
            } else {
            #this VPI must be Skipped 
            }
         } 
         #If Updated list is empty, then  Group wont be created.
         if {[string equal $updatedLst ""]} {
            continue
         }

         if {[string equal [array names resArr $lookupKey] ""]} {
            #No element found. the leaf item isn't a container
            #update the list of VPIs
            array set resArr [list $key $updatedLst]
         } else {
            #this leaf must be treated as a group
            set leafElem [string range $key [string last "/" $key] end]
            set newKey "${key}"
            array set resArr [list $newKey $updatedLst]
            if {[string equal "" $FILTER]} {
               #array unset resArr $key
            }
         }
      }

      set xmlfile [file join $xmlpath "${fname}_ivs_plan.xml"]
      set xml [open "$xmlfile" w+]
      logfile "\n Making xml file for IVS IMPORT......"
      puts $xml "\<?xml version\=\"1.0\" encoding\=\"ISO-8859-1\"?\>\n\<plan name=\"IVSPlan\"\>"
      if {!([llength $TOTAL_LST] == "0")} {
       puts $xml " \<metric template =\"metricgroup\" name=\"top\" heading=\"1\"\>"
       foreach {key val} [array get resArr] {
         set key_split [split $key "\/"]
         set key_split [lreplace $key_split 0 0]
         if {![string equal "" $FILTER]} {
            set FILTER [hier_replace $FILTER $keep_hier]
            if ([string equal "" $max_hier]) {
               set max_hier 1
            }
            set flt_split [split $FILTER "\/"]
            set flt_split [lreplace $flt_split 0 0]
            set key_index [expr [llength $flt_split] + $max_hier - 1]
            if {[llength $key_split] < $key_index} {
               set key_index [llength $key_split]
               puts "INFO\: Value of -max_hier_level exceeds the Hierarchy Level.\n Setting it default value \'1\'"
            }
            if {[string equal "0" $max_hier]} {
               set grp_name [lindex $flt_split end]
               set prefix_name "$FILTER"
            } elseif {$max_hier > 1} {
               set grp_name [lrange $key_split [llength $flt_split] $key_index]
               set grp_name "\/[join $grp_name \/ ]"
               set prefix_name "$FILTER$grp_name"
            } else {
               set grp_name "\/"
               append grp_name "[lindex $key_split $key_index]"
               set prefix_name "$FILTER$grp_name"
            }
            set hdl_path_name "$grp_name"
            if {!($keep_hier)} {
             set hdl_path_name "$prefix_name"
            }
         } else {
            if {[string equal "" $max_hier]} {
               set grp_name $key 
            } else {
               if {[llength $key_split] > $max_hier} {
                  set grp_name [lrange $key_split 0 $max_hier]
               } else {
                  set grp_name [lrange $key_split 0 end]
               }
               set grp_name "/[join $grp_name \/]"
            }
            set hdl_path_name "$grp_name"
         }
         foreach valitem $val {
            if {[string equal '' [lindex $valitem 0]]} {continue}
            set metric_name [hier_replace "[lindex $valitem 0]" "$keep_hier"]
            set key_split [split $metric_name "\/"]
            set key_split [lreplace $key_split 0 0]
            if {!($keep_hier) && (![string equal "" $FILTER])} {
               set metric_name [string map [list $prefix_name ""] $metric_name]
            } elseif {($keep_hier) && [string equal "" $FILTER]} {
               set metric_name [string map [list $grp_name ""] $metric_name]
            }
            set metric_name [string trimleft $metric_name "\/"]
            set metric_arr [split $metric_name "\/"]
            set metric_name [lindex $metric_arr end]

            set hdl_path_final [string trimleft $hdl_path_name "\/"]
            if {[string equal $hdl_path_final "$metric_name"]} {
               set hdl_path_name ""
            } else {
               set hdl_path_name $hdl_path_name
            }         
            if {[string match "FSM*" [lindex $valitem 2]]} {
              puts $xml "[string repeat " " 4] \<metric template=\"metric\" name=\"$metric_name\" hdl_path=\"$hdl_path_name\" type=\"fsm\"\/\>"
            } elseif {[string match "Test*" [lindex $valitem 2]]} {
              #  set metric_name_test [string trimleft $hdl_path_name "\/"]
              puts $xml "[string repeat " " 4] \<metric template=\"metric\" name=\"$metric_name\" hdl_path=\"$hdl_path_name\" type=\"[string tolower [lindex $valitem 2] ]\"\/\>"
            } else {
              puts $xml "[string repeat " " 4] \<metric template=\"metric\" name=\"$metric_name\" hdl_path=\"$hdl_path_name\" type=\"[string tolower [lindex $valitem 2] ]\"\/\>"
            }
         }
      }
   puts $xml "[string repeat " " 1]\<\/metric\>"
   }
   puts $xml "\<\/plan\>"
   close $xml
   }
  ######
 }

  #############################################
 



   logfile "Made IMPORT-XML file.."
   logfile "Path of xml file:-$xmlfile"

   ##Do we delete the html dir too ?
   if {! $keep_htmldir} {
  #     file delete -force $tmp_HTMLPATH
   }
   if {! $keep_rptdir} {
 #      file delete -force $tmp_RPTDIR
   }
   if {$HREF == 0} {
       file delete -force "$TEMP_DIR"
   }
    
   file delete -force "urgReport"
   file delete -force ".null"
   puts "INFO: IVS XML file successfully generated: '$xmlfile'."
   if {!([lsearch $userinput "-verbose"] == "-1")} {
       puts "INFO: Log file created at \"[file join [pwd] \"$logfilename\"]\"."
   }
   puts ""
   ###Generate plan xml and upload in one step if upload is set to "1"##
   if {$upload_plan ==1 } {
   set comment ""
   set override ""
   upload_result_proc $upload_plan $url $file_path $project_name $xmlfile $sourceid $upload_type $comment $override 
   }

   exit 2
}

###########################################################################
#Making IVS supported Input XML File
set xmlfile [file join $xmlpath "${fname}_ivs.xml"]
#puts "||||||||||||||||||||||$xmlfile||||||||||||||||||||"
set xml [open "$xmlfile" w+]
logfile "\n Making xml file......"
puts $xml "<\?xml version\=\"1.0\" encoding\=\"UTF-8\"\?>"
puts -nonewline $xml "<regression "
if {$regression != ""} {
    puts -nonewline $xml "name=\"$regression\" "
}
if {$project_name != ""} {
    puts -nonewline $xml "project=\"$project_name\" "
} 
if {$runid != ""} {
   puts -nonewline $xml "runid=\"$runid\" "
}
if {$hdl_path != ""} {
    puts -nonewline $xml "hdl_path=\"$hdl_path\" "
}
if {$sourceid != ""} {
    puts -nonewline $xml "soruceid=\"$sourceid\" "
}
puts -nonewline $xml ">\n"


#puts "FINAL_LIST\n\n\n$FINAL_LIST\n\n\n"
for {set i 0} {$i <= [expr [llength $FINAL_LIST] - 1 ]} {incr i} {
    set tmp_list [lindex $FINAL_LIST $i]
  
    foreach var $tmp_list {
        set tmp_metric [lindex $var 0]
        if {[string match '' $tmp_metric]} { continue }
        set metric_name [hier_replace $tmp_metric "$keep_hier"]
        set new [regexp {.*/(\w*)$} $metric_name \\1 metric_name_extract_last ]
        set new1 [regexp {(.*)/\w*$} $metric_name \\1 metric_name_extract_first ]
#        puts $xml "\n     <result name=\"$metric_name_extract_last\" type=\"[lindex $var 2]\" hdl_path=\"$metric_name_extract_first\" >\n         <value>[lindex $var 1]</value>"
#        puts $xml "metric name is : $metric_name"

	if {!([lindex $var 1] == "")} {

        puts -nonewline $xml "[string repeat " " 4]<result name=\"$metric_name_extract_last\" type=\"[string tolower [lindex $var 2]]\" "
              if {$metric_name_extract_first != ""} {
                   puts -nonewline $xml "hdl_path=\"$metric_name_extract_first\" "
              }
	puts $xml ">"
          if {[regexp -nocase {^Pass.*$} [lindex $var 1] match]} {
	     puts $xml "[string repeat " " 7]<value>pass</value>" 
          } elseif {[regexp -nocase {^Fail.*$} [lindex $var 1] match1]} { 
              puts $xml "[string repeat " " 7]<value>fail</value>"
          } else {
             if {[regexp {^[0-9]+\.0$} [lindex $var 1]]} {
                regsub {\.0} [lindex $var 1] "" val
               puts $xml "[string repeat " " 7]<value>$val</value>"
             } else {
             puts $xml "[string repeat " " 7]<value>[lindex $var 1]</value>"
            }   
          }
           if {!([lindex $var end] == "")} {
              set href_path [lindex $var end]
              if {![string equal $HREFPREFIX ""]} {
                  set map [list $HTMLDIR $HREFPREFIX]
                  set href_path [string map $map $href_path]
              } else {
                  set href_path "file:\/\/$href_path"
              }
              puts $xml "[string repeat " " 7]<href>$href_path</href>"
          }
#        puts $xml "        <type>[string tolower [lindex $var 2]]</type>"
        puts $xml "[string repeat " " 4]<\/result>"
    }
  }
}
# Appending results from transcript file

set files [glob -nocomplain $OUTDIR/*.txt]
if {[expr [llength $files] > 0]} {
foreach filee $files {
set trns [open $filee]
while {![eof $trns]} {
 set line [gets $trns]
 if { [regexp "<result" $line]>0 || [regexp "<value>" $line]>0 || [regexp "<msg" $line]>0 || [regexp "</result>" $line]>0 } {
         if { [regexp "#" $line]>0 } {
	 set line [split $line #]
         puts $xml [lindex $line 1]  
	 } else {
		 puts $xml $line
	 }
    }
}
}
}





# puts "$OUTDIR outdir"
# if {[file isfile $OUTDIR/*.txt] == 1} {
# set files [glob $OUTDIR/*.txt]
# foreach filee $files {
# set trns [open $filee]
# set status ""
# while {![eof $trns]} {
 # set line [gets $trns]
 # if { [regexp "<result" $line]>0 || [regexp "<value>" $line]>0 || [regexp "<msg" $line]>0 || [regexp "</result>" $line]>0 } {
         # if { [regexp "#" $line]>0 } {
	 # set line [split $line #]
         # puts $xml [lindex $line 1]  
	 # } else {
		 # puts $xml $line
	 # }
    # }
 # if { [regexp "UVM_ERROR :" $line] } {
	 # set line1 [split $line {:\S+}  ]
	 # set uvmError [regexp -inline -all -- {\S+} [lindex $line1 1]]
	 # if {[expr $uvmError == 0]} {
             # set status "pass"

	    # } else {
             # set status "fail"
	  # }
	  
    # }
    
  # if {[regexp "testname :" $line]} {
	 # set line [split $line {:\S+}  ]
	 # set wordList [regexp -inline -all -- {\S+} [lindex $line 1]]
         # puts -nonewline $xml "[string repeat " " 4]<result name=\"$wordList\" type=\"test\""
	 # puts $xml ">"
             # puts $xml "[string repeat " " 7]<value>$status</value>"
             # puts $xml "[string repeat " " 4]<\/result>"
    # }  

  	
# }
# }}
# if { [string compare [lindex $argv 1] "uvm_arv_main_seq.ucdb" ]==0 } {

# #puts "option 1 is [lindex $argv 1]"
# set trns [open $OUTDIR/transcript]
# set temp [open $OUTDIR/transcript.tmp w]
# while {![eof $trns]} {
         # set line [gets $trns]
         # if { [regexp "<result" $line]>0 || [regexp "<value>" $line]>0 || [regexp "<msg" $line]>0 || [regexp "</result>" $line]>0 } {
         # set line [split $line #]
         # puts $xml [lindex $line 1]
         # } else {
         # puts $temp $line
         # }
         # }
         # close $trns
         # close $temp
         # file rename -force  $OUTDIR/transcript.tmp  $OUTDIR/transcript
# } elseif { [string compare [lindex $argv 1] "simv.vdb" ]==0 } {
# set trns [open $OUTDIR/vcs.log]
# set temp [open $OUTDIR/transcript.tmp w]
# while {![eof $trns]} {
         # set line [gets $trns]
         # if { [regexp "<result" $line]>0 || [regexp "<value>" $line]>0 || [regexp "<msg" $line]>0 || [regexp "</result>" $line]>0 } {
         # puts $xml $line
         # } else {
         # puts $temp $line
         # }
         # }
         # close $trns
         # close $temp
         # file rename -force  $OUTDIR/transcript.tmp $OUTDIR/vcs.log
# } elseif { [string compare [lindex $argv 1] "cov_work/scope/test/" ]==0 } {
# set trns [open $OUTDIR/irun.log]
# set temp [open $OUTDIR/transcript.tmp w]
# while {![eof $trns]} {
         # set line [gets $trns]
         # if { [regexp "<result" $line]>0 || [regexp "<value>" $line]>0 || [regexp "<msg" $line]>0 || [regexp "</result>" $line]>0 } {
         # puts $xml $line
         # } else {
         # puts $temp $line
         # }
         # }
         # close $trns
         # close $temp
         # file rename -force  $OUTDIR/transcript.tmp $OUTDIR/irun.log
# }

	 
puts $xml "</regression>"

close $xml
logfile "Made XML file.."
logfile "Path of xml file:-$xmlfile"

###### Empty temporary directories: ########

##Do we delete the html dir too ?
if {! $keep_htmldir} {
#    file delete -force $tmp_HTMLPATH
}
if {! $keep_rptdir} {
#    file delete -force $tmp_RPTDIR
}
if {$HREF == 0} {
     file delete -force "$TEMP_DIR"
}

file delete -force "urgReport"
file delete -force ".null"
puts "INFO: IVS XML file successfully generated: '$xmlfile'."
if {!([lsearch $userinput "-verbose"] == "-1")} {
    puts "INFO: Log file created at \"[file join [pwd] $logfilename]\"."
}
puts ""

}

### Submit the results in IVS
if {$submit_results == 1} {
puts "sub enter here"
     if {![string equal $runid ""]} {
        set cmd_runid {-runid}
     } 
     if {($upload == 1)} {
        set cmd_upload {-upload}
     }
     if {[catch {submitResult -ivs $url -u $username -p $password -dir $xmlpath -file "${fname}_ivs.xml" -project $project_name -plan $plan_name $cmd_runid $runid $cmd_upload} msg]} {
         puts "ERROR: $msg"
     } else {
        logfile "Script uploaded"
     }
 
}


		
		
#GENERATE result XML AND UPLOAD IN ONE STEP###########
   if {$upload_result ==1 } {
    upload_result_proc $upload_result $url $file_path $project_name $xmlfile $sourceid $upload_type $comment $override
   }

#if {$upload_result == 1} {
#     if {$file_path == 1} {
#         if {[catch {exec curl --form userImage=@$file_path "$url/uploadFile?project=$project_name&sourceid=$sourceid&uploadtype=result"} err ]} {
#            if {[string match "*SUCCESS*" $err]} {
#               puts "INFO: $file_path successfully uploaded\n"
#            } elseif {[string match -nocase "*Error*" $err]} {
#               puts "INFO: $file_path not uploaded. See error below:\n \n  $err\n"
#            } else {
#               puts "INFO: Unknown error. See details below:\n $err\n"
#            }
#         }
#    } else {
#         if {[catch {exec curl --form userImage=@$xmlfile "$url/uploadFile?project=$project_name&sourceid=$sourceid&uploadtype=result"} err ]} {
#            if {[string match "*SUCCESS*" $err]} {
#                puts "INFO: $xmlfile successfully uploaded\n"
#            } elseif {[string match -nocase "*Error*" $err]} {
#              puts "INFO: $xmlfile not uploaded. See error below:\n \n  $err\n"
#            } else {
#              puts "INFO: Unknown error. See details below:\n $err\n"
#            }
#         }
#    }
#}

#    if {[catch {exec upload.sh} err]}
#    if {[catch {exec curl --form userImage=@result1.xml "http://statustool.com:9090/IVS-1.0-SNAPSHOT/uploadFile?project=vipin&sourceid=aaa&uploadtype=result"} err]}


#if {[string equal $username ""] || [string equal $password ""] || [string equal $project_name ""] \
              || [string equal $plan_name ""] || [string equal $url ""]} {
#    puts {With '-submitResult' options  "-ivs <ivs_url> -u <username> -p <password> -project <projectname> -plan_name <planname>" options are mandatory.}
#    }





##################################### EOF #####################################
