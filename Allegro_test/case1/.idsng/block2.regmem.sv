//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Admin
// generated from    : C:\Users\Admin\Documents\GitHub\git_test\Allegro_test\case1\case1.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AXI
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

`include "ref_name.regmem.sv"

/*----------------------------------------------------------------------
Class       : block2_reggroup1_reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block2_reggroup1_reg1
`define CLASS_block2_reggroup1_reg1
class block2_reggroup1_reg1 extends uvm_reg;
    `uvm_object_utils(block2_reggroup1_reg1)

    rand uvm_reg_field fld;

    function int get_cov(cov_typ ct);
        case (ct.name())

            "wr_cg_vals" :
            begin
                `ifdef VCS
                return wr_cg_vals.get_coverage();
                `else
                return wr_cg_vals.get_inst_coverage();
                `endif
            end

            "rd_cg_vals" :
            begin
                `ifdef VCS
                return rd_cg_vals.get_coverage();
                `else
                return rd_cg_vals.get_inst_coverage();
                `endif
            end

        endcase
    endfunction

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    local uvm_reg_data_t m_cov_mask = 'hFFFFFFFF;

    covergroup wr_cg_bits;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg1_wr_cg_bits";
        `endif

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0] && m_cov_mask[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[0] && m_cov_mask[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[0] && m_cov_mask[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[0] && m_cov_mask[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[0] && m_cov_mask[4])
        {
            illegal_bins b_x = {1,2};
        }
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[0] && m_cov_mask[5])
        {
            illegal_bins b_x = {1,2};
        }
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[0] && m_cov_mask[6])
        {
            illegal_bins b_x = {1,2};
        }
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[0] && m_cov_mask[7])
        {
            illegal_bins b_x = {1,2};
        }
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[1] && m_cov_mask[8])
        {
            illegal_bins b_x = {1,2};
        }
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[1] && m_cov_mask[9])
        {
            illegal_bins b_x = {1,2};
        }
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[1] && m_cov_mask[10])
        {
            illegal_bins b_x = {1,2};
        }
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[1] && m_cov_mask[11])
        {
            illegal_bins b_x = {1,2};
        }
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[1] && m_cov_mask[12])
        {
            illegal_bins b_x = {1,2};
        }
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[1] && m_cov_mask[13])
        {
            illegal_bins b_x = {1,2};
        }
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[1] && m_cov_mask[14])
        {
            illegal_bins b_x = {1,2};
        }
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[1] && m_cov_mask[15])
        {
            illegal_bins b_x = {1,2};
        }
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[2] && m_cov_mask[16])
        {
            illegal_bins b_x = {1,2};
        }
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[2] && m_cov_mask[17])
        {
            illegal_bins b_x = {1,2};
        }
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[2] && m_cov_mask[18])
        {
            illegal_bins b_x = {1,2};
        }
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[2] && m_cov_mask[19])
        {
            illegal_bins b_x = {1,2};
        }
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[2] && m_cov_mask[20])
        {
            illegal_bins b_x = {1,2};
        }
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[2] && m_cov_mask[21])
        {
            illegal_bins b_x = {1,2};
        }
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[2] && m_cov_mask[22])
        {
            illegal_bins b_x = {1,2};
        }
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[2] && m_cov_mask[23])
        {
            illegal_bins b_x = {1,2};
        }
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[3] && m_cov_mask[24])
        {
            illegal_bins b_x = {1,2};
        }
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[3] && m_cov_mask[25])
        {
            illegal_bins b_x = {1,2};
        }
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[3] && m_cov_mask[26])
        {
            illegal_bins b_x = {1,2};
        }
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[3] && m_cov_mask[27])
        {
            illegal_bins b_x = {1,2};
        }
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[3] && m_cov_mask[28])
        {
            illegal_bins b_x = {1,2};
        }
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[3] && m_cov_mask[29])
        {
            illegal_bins b_x = {1,2};
        }
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[3] && m_cov_mask[30])
        {
            illegal_bins b_x = {1,2};
        }
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[3] && m_cov_mask[31])
        {
            illegal_bins b_x = {1,2};
        }

    endgroup

    covergroup rd_cg_bits;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg1_rd_cg_bits";
        `endif

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0] && m_cov_mask[0] )
        {
            illegal_bins b_x = {1,2};
        }
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[0] && m_cov_mask[1] )
        {
            illegal_bins b_x = {1,2};
        }
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[0] && m_cov_mask[2] )
        {
            illegal_bins b_x = {1,2};
        }
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[0] && m_cov_mask[3] )
        {
            illegal_bins b_x = {1,2};
        }
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[0] && m_cov_mask[4] )
        {
            illegal_bins b_x = {1,2};
        }
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[0] && m_cov_mask[5] )
        {
            illegal_bins b_x = {1,2};
        }
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[0] && m_cov_mask[6] )
        {
            illegal_bins b_x = {1,2};
        }
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[0] && m_cov_mask[7] )
        {
            illegal_bins b_x = {1,2};
        }
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[1] && m_cov_mask[8] )
        {
            illegal_bins b_x = {1,2};
        }
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[1] && m_cov_mask[9] )
        {
            illegal_bins b_x = {1,2};
        }
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[1] && m_cov_mask[10] )
        {
            illegal_bins b_x = {1,2};
        }
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[1] && m_cov_mask[11] )
        {
            illegal_bins b_x = {1,2};
        }
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[1] && m_cov_mask[12] )
        {
            illegal_bins b_x = {1,2};
        }
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[1] && m_cov_mask[13] )
        {
            illegal_bins b_x = {1,2};
        }
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[1] && m_cov_mask[14] )
        {
            illegal_bins b_x = {1,2};
        }
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[1] && m_cov_mask[15] )
        {
            illegal_bins b_x = {1,2};
        }
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[2] && m_cov_mask[16] )
        {
            illegal_bins b_x = {1,2};
        }
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[2] && m_cov_mask[17] )
        {
            illegal_bins b_x = {1,2};
        }
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[2] && m_cov_mask[18] )
        {
            illegal_bins b_x = {1,2};
        }
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[2] && m_cov_mask[19] )
        {
            illegal_bins b_x = {1,2};
        }
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[2] && m_cov_mask[20] )
        {
            illegal_bins b_x = {1,2};
        }
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[2] && m_cov_mask[21] )
        {
            illegal_bins b_x = {1,2};
        }
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[2] && m_cov_mask[22] )
        {
            illegal_bins b_x = {1,2};
        }
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[2] && m_cov_mask[23] )
        {
            illegal_bins b_x = {1,2};
        }
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[3] && m_cov_mask[24] )
        {
            illegal_bins b_x = {1,2};
        }
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[3] && m_cov_mask[25] )
        {
            illegal_bins b_x = {1,2};
        }
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[3] && m_cov_mask[26] )
        {
            illegal_bins b_x = {1,2};
        }
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[3] && m_cov_mask[27] )
        {
            illegal_bins b_x = {1,2};
        }
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[3] && m_cov_mask[28] )
        {
            illegal_bins b_x = {1,2};
        }
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[3] && m_cov_mask[29] )
        {
            illegal_bins b_x = {1,2};
        }
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[3] && m_cov_mask[30] )
        {
            illegal_bins b_x = {1,2};
        }
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[3] && m_cov_mask[31] )
        {
            illegal_bins b_x = {1,2};
        }

    endgroup

    covergroup wr_cg_vals;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg1_wr_cg_vals";
        `endif

        fld: coverpoint fld.value[31:0];
    endgroup

    covergroup rd_cg_vals;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg1_rd_cg_vals";
        `endif

        fld: coverpoint fld.value[31:0];
    endgroup

    // Function : new
    function new(string name = "block2_reggroup1_reg1");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.fld = uvm_reg_field::type_id::create("fld");

        this.fld.configure(this, 32,  0, "RW", 0, 'd0, 1, 1, 1);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block2_reggroup1_reg2
-----------------------------------------------------------------------*/

`ifndef CLASS_block2_reggroup1_reg2
`define CLASS_block2_reggroup1_reg2
class block2_reggroup1_reg2 extends uvm_reg;
    `uvm_object_utils(block2_reggroup1_reg2)

    rand uvm_reg_field fld1;

    function int get_cov(cov_typ ct);
        case (ct.name())

            "wr_cg_vals" :
            begin
                `ifdef VCS
                return wr_cg_vals.get_coverage();
                `else
                return wr_cg_vals.get_inst_coverage();
                `endif
            end

            "rd_cg_vals" :
            begin
                `ifdef VCS
                return rd_cg_vals.get_coverage();
                `else
                return rd_cg_vals.get_inst_coverage();
                `endif
            end

        endcase
    endfunction

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    local uvm_reg_data_t m_cov_mask = 'hFFFFFFFF;

    covergroup wr_cg_bits;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg2_wr_cg_bits";
        `endif

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0] && m_cov_mask[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[0] && m_cov_mask[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[0] && m_cov_mask[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[0] && m_cov_mask[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[0] && m_cov_mask[4])
        {
            illegal_bins b_x = {1,2};
        }
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[0] && m_cov_mask[5])
        {
            illegal_bins b_x = {1,2};
        }
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[0] && m_cov_mask[6])
        {
            illegal_bins b_x = {1,2};
        }
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[0] && m_cov_mask[7])
        {
            illegal_bins b_x = {1,2};
        }
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[1] && m_cov_mask[8])
        {
            illegal_bins b_x = {1,2};
        }
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[1] && m_cov_mask[9])
        {
            illegal_bins b_x = {1,2};
        }
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[1] && m_cov_mask[10])
        {
            illegal_bins b_x = {1,2};
        }
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[1] && m_cov_mask[11])
        {
            illegal_bins b_x = {1,2};
        }
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[1] && m_cov_mask[12])
        {
            illegal_bins b_x = {1,2};
        }
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[1] && m_cov_mask[13])
        {
            illegal_bins b_x = {1,2};
        }
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[1] && m_cov_mask[14])
        {
            illegal_bins b_x = {1,2};
        }
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[1] && m_cov_mask[15])
        {
            illegal_bins b_x = {1,2};
        }
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[2] && m_cov_mask[16])
        {
            illegal_bins b_x = {1,2};
        }
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[2] && m_cov_mask[17])
        {
            illegal_bins b_x = {1,2};
        }
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[2] && m_cov_mask[18])
        {
            illegal_bins b_x = {1,2};
        }
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[2] && m_cov_mask[19])
        {
            illegal_bins b_x = {1,2};
        }
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[2] && m_cov_mask[20])
        {
            illegal_bins b_x = {1,2};
        }
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[2] && m_cov_mask[21])
        {
            illegal_bins b_x = {1,2};
        }
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[2] && m_cov_mask[22])
        {
            illegal_bins b_x = {1,2};
        }
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[2] && m_cov_mask[23])
        {
            illegal_bins b_x = {1,2};
        }
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[3] && m_cov_mask[24])
        {
            illegal_bins b_x = {1,2};
        }
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[3] && m_cov_mask[25])
        {
            illegal_bins b_x = {1,2};
        }
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[3] && m_cov_mask[26])
        {
            illegal_bins b_x = {1,2};
        }
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[3] && m_cov_mask[27])
        {
            illegal_bins b_x = {1,2};
        }
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[3] && m_cov_mask[28])
        {
            illegal_bins b_x = {1,2};
        }
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[3] && m_cov_mask[29])
        {
            illegal_bins b_x = {1,2};
        }
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[3] && m_cov_mask[30])
        {
            illegal_bins b_x = {1,2};
        }
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[3] && m_cov_mask[31])
        {
            illegal_bins b_x = {1,2};
        }

    endgroup

    covergroup rd_cg_bits;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg2_rd_cg_bits";
        `endif

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0] && m_cov_mask[0] )
        {
            illegal_bins b_x = {1,2};
        }
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[0] && m_cov_mask[1] )
        {
            illegal_bins b_x = {1,2};
        }
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[0] && m_cov_mask[2] )
        {
            illegal_bins b_x = {1,2};
        }
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[0] && m_cov_mask[3] )
        {
            illegal_bins b_x = {1,2};
        }
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[0] && m_cov_mask[4] )
        {
            illegal_bins b_x = {1,2};
        }
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[0] && m_cov_mask[5] )
        {
            illegal_bins b_x = {1,2};
        }
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[0] && m_cov_mask[6] )
        {
            illegal_bins b_x = {1,2};
        }
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[0] && m_cov_mask[7] )
        {
            illegal_bins b_x = {1,2};
        }
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[1] && m_cov_mask[8] )
        {
            illegal_bins b_x = {1,2};
        }
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[1] && m_cov_mask[9] )
        {
            illegal_bins b_x = {1,2};
        }
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[1] && m_cov_mask[10] )
        {
            illegal_bins b_x = {1,2};
        }
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[1] && m_cov_mask[11] )
        {
            illegal_bins b_x = {1,2};
        }
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[1] && m_cov_mask[12] )
        {
            illegal_bins b_x = {1,2};
        }
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[1] && m_cov_mask[13] )
        {
            illegal_bins b_x = {1,2};
        }
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[1] && m_cov_mask[14] )
        {
            illegal_bins b_x = {1,2};
        }
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[1] && m_cov_mask[15] )
        {
            illegal_bins b_x = {1,2};
        }
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[2] && m_cov_mask[16] )
        {
            illegal_bins b_x = {1,2};
        }
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[2] && m_cov_mask[17] )
        {
            illegal_bins b_x = {1,2};
        }
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[2] && m_cov_mask[18] )
        {
            illegal_bins b_x = {1,2};
        }
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[2] && m_cov_mask[19] )
        {
            illegal_bins b_x = {1,2};
        }
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[2] && m_cov_mask[20] )
        {
            illegal_bins b_x = {1,2};
        }
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[2] && m_cov_mask[21] )
        {
            illegal_bins b_x = {1,2};
        }
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[2] && m_cov_mask[22] )
        {
            illegal_bins b_x = {1,2};
        }
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[2] && m_cov_mask[23] )
        {
            illegal_bins b_x = {1,2};
        }
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[3] && m_cov_mask[24] )
        {
            illegal_bins b_x = {1,2};
        }
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[3] && m_cov_mask[25] )
        {
            illegal_bins b_x = {1,2};
        }
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[3] && m_cov_mask[26] )
        {
            illegal_bins b_x = {1,2};
        }
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[3] && m_cov_mask[27] )
        {
            illegal_bins b_x = {1,2};
        }
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[3] && m_cov_mask[28] )
        {
            illegal_bins b_x = {1,2};
        }
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[3] && m_cov_mask[29] )
        {
            illegal_bins b_x = {1,2};
        }
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[3] && m_cov_mask[30] )
        {
            illegal_bins b_x = {1,2};
        }
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[3] && m_cov_mask[31] )
        {
            illegal_bins b_x = {1,2};
        }

    endgroup

    covergroup wr_cg_vals;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg2_wr_cg_vals";
        `endif

        fld1: coverpoint fld1.value[31:0];
    endgroup

    covergroup rd_cg_vals;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_reggroup1_reg2_rd_cg_vals";
        `endif

        fld1: coverpoint fld1.value[31:0];
    endgroup

    // Function : new
    function new(string name = "block2_reggroup1_reg2");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.fld1 = uvm_reg_field::type_id::create("fld1");

        this.fld1.configure(this, 32,  0, "RW", 0, 'd0, 1, 1, 1);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : block2_reggroup1
-----------------------------------------------------------------------*/
`ifndef CLASS_block2_reggroup1
`define CLASS_block2_reggroup1
class block2_reggroup1 extends uvm_reg_file;
    `uvm_object_utils(block2_reggroup1)

    rand block2_reggroup1_reg1 reg1;

    rand block2_reggroup1_reg2 reg2;

    // Function : new
    function new(string name = "block2_reggroup1");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        reg1   =   block2_reggroup1_reg1::type_id::create("reg1");
        reg2   =   block2_reggroup1_reg2::type_id::create("reg2");

        //config
        reg1.configure(get_block(), this, "reg1");
        reg2.configure(get_block(), this, "reg2");

        //build
        reg1.build();
        reg2.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg( reg1, offset +  'h0, "RW");
        mp.add_reg( reg2, offset +  'h4, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        reg1.set_offset(mp, offset +  'h0);
        reg2.set_offset(mp, offset +  'h4);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class      : block2_block
-----------------------------------------------------------------------*/
`ifndef CLASS_block2_block
`define CLASS_block2_block
class block2_block extends uvm_reg_block;
    `uvm_object_utils(block2_block)

    rand block2_reggroup1 reggroup1;
    rand block2_block1 ref_name;

    local uvm_reg_addr_t m_offset;
    covergroup cg_addr;
        `ifdef INCA
        option.per_instance=1;
        option.name="block2_block_cg_addr";
        `endif

        reggroup1 : coverpoint m_offset
        {
            bins hit =  { ['h0 : 'h7] };
        }
        ref_name : coverpoint m_offset
        {
            bins hit =  { ['h8 : 'h13] };
        }

    endgroup

    // Function : new
    function new(string name = "block2_block");
        super.new(name, build_coverage(UVM_CVR_ADDR_MAP));

        if (has_coverage(UVM_CVR_ADDR_MAP)) begin
            cg_addr = new();
        end
    endfunction

    // Function : build
    virtual function void build();
        //REGGROUP1
        reggroup1   =   block2_reggroup1::type_id::create("reggroup1");
        reggroup1.configure(this, null, "reggroup1");
        reggroup1.build();

        //REF_NAME
        ref_name   =   block2_block1::type_id::create("ref_name");
        ref_name.configure(this, "ref_name");
        ref_name.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'hC, 4, UVM_LITTLE_ENDIAN, 1);
        reggroup1.map( default_map, 'h0);
        default_map.add_submap( ref_name.default_map, 'h8);

        reggroup1.clear_hdl_path();
        reggroup1.add_hdl_path("");
        reggroup1.reg1.clear_hdl_path();
        reggroup1.reg1.add_hdl_path_slice("reggroup1_reg1_fld_q", 0, 32);
        reggroup1.reg2.clear_hdl_path();
        reggroup1.reg2.add_hdl_path_slice("reggroup1_reg2_fld1_q", 0, 32);

        lock_model();
    endfunction

    protected virtual function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map map);
        if (get_coverage(UVM_CVR_ADDR_MAP))  begin

            m_offset  = offset;
            cg_addr.sample();
            if (this.get_parent() != null) begin
                this.get_parent().sample(m_offset+'hC,is_read,map);
            end
        end

    endfunction
endclass : block2_block
`endif
