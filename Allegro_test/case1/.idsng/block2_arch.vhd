--Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
--
--*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
-- created by        :
-- generated by      : Admin
-- generated from    : C:\Users\Admin\Documents\GitHub\git_test\Allegro_test\case1\case1.idsng
-- IDesignSpec rev   : idsbatch v4.16.26.2

--*** This code is generated with following settings ***
-- Reg Width                  : 32
-- Address Unit               : 8
-- C++ Types int              : hwint
-- Bus Type                   : AXI
-- BigEndian                  : false
-- LittleEndian               : false
-- Dist. Decode and Readback  : false
-----------------------------------------------------------------------------------------------------------------
--

-------------------------------------------------------------
-- ARCHITECTURE : block2_e ENTITY
-------------------------------------------------------------

architecture rtl of block2_e is
    
    -- AXI signals
    
    signal clk              :   std_logic;
    signal reset_l          :   std_logic;
    signal raddress         :   std_logic_vector(G_AXI_ADDR_WIDTH-1  downto 0);
    signal arprot_i         :   std_logic_vector(2 downto 0);
    signal awprot_i         :   std_logic_vector(2 downto 0);
    signal wr_error         :   std_logic;
    signal wr_decode_error  :   std_logic;
    signal rd_decode_error  :   std_logic;
    signal rd_error         :   std_logic;
    signal rd_stb           :   std_logic;
    signal rd_wait          :   std_logic;
    signal wr_stb           :   std_logic;
    signal address          :   std_logic_vector(G_AXI_ADDR_WIDTH-1  downto 0);
    signal wr_data          :   std_logic_vector(G_AXI_BUS_WIDTH-1   downto 0);
    signal request          :   std_logic;
    signal rd_data_vld      :   std_logic;
    signal rd_data_vld0     :   std_logic;
    signal rd_data          :   std_logic_vector(G_AXI_BUS_WIDTH-1   downto 0);
    signal reg_enb          :   std_logic_vector(G_AXI_BUS_WIDTH-1   downto 0);
    signal byte_enb         :   std_logic_vector(G_AXI_BUS_WIDTH/8-1 downto 0);
    signal wr_slave_select  :   std_logic;
    signal rd_slave_select  :   std_logic;
    signal slvwaddr         :   std_logic_vector(G_AXI_ADDR_WIDTH -1 downto 0);
    signal slvraddr         :   std_logic_vector(G_AXI_ADDR_WIDTH -1 downto 0);
    
    
    signal rd_data0      :  std_logic_vector(G_AXI_BUS_WIDTH-1 downto 0);
    
    
    -------------------------------------------
    -- signal declaration
    -------------------------------------------
    -- block end address
    constant block2_end_addr : natural := 19;
    
    
    --: REGGROUP1:SECTION OFFSET RECORD
    type block2_reggroup1_offset is record
        reg1 : natural;
        reg2 : natural;
    end record;
    
    type block2_reggroup1_offset_array is array ((block2_reggroup1_count - 1) downto 0) of block2_reggroup1_offset;
    signal offset_reggroup1 : block2_reggroup1_offset_array;
    -- END SECTION OFFSET RECORD : REGGROUP1
    
    --: REGGROUP1:SECTION DECODE RECORD
    type block2_reggroup1_decode is record
        reg1 :std_logic;
        reg2 :std_logic;
    end record;
    
    type block2_reggroup1_decode_array is array ((block2_reggroup1_count - 1) downto 0) of block2_reggroup1_decode;
    signal decode_reggroup1 : block2_reggroup1_decode_array;
    -- END SECTION DECODE RECORD : REGGROUP1
    
    --: REGGROUP1:SECTION RDECODE RECORD
    type block2_reggroup1_rdecode is record
        reg1 :std_logic;
        reg2 :std_logic;
    end record;
    
    type block2_reggroup1_rdecode_array is array ((block2_reggroup1_count - 1) downto 0) of block2_reggroup1_rdecode;
    signal rdecode_reggroup1 : block2_reggroup1_rdecode_array;
    -- END SECTION RDECODE RECORD : REGGROUP1
    
    --: REGGROUP1:SECTION  RD_DATA RECORD : REGGROUP1
    type block2_reggroup1_rd_data is record
        reg1 : std_logic_vector((G_AXI_BUS_WIDTH - 1) downto 0);
        reg2 : std_logic_vector((G_AXI_BUS_WIDTH - 1) downto 0);
    end record;
    type block2_reggroup1_rd_data_array is array ((block2_reggroup1_count - 1) downto 0) of block2_reggroup1_rd_data;
    signal rd_data_reggroup1 : block2_reggroup1_rd_data_array;
    -- END SECTION RD_DATA RECORD : REGGROUP1
    
    --: REGGROUP1  SECTION  WRITE_VALID RECORD
    type block2_reggroup1_wr_valid is record
        reg1 : std_logic;
        reg2 : std_logic;
    end record;
    type block2_reggroup1_wr_valid_array is array ((block2_reggroup1_count - 1) downto 0) of block2_reggroup1_wr_valid;
    signal wr_valid_reggroup1 : block2_reggroup1_wr_valid_array;
    -- END  WRITE_VALID RECORD : REGGROUP1
    
    --: REGGROUP1 SECTION READ_VALID RECORD
    type block2_reggroup1_rd_valid is record
        reg1 : std_logic;
        reg2 : std_logic;
    end record;
    type block2_reggroup1_rd_valid_array is array ((block2_reggroup1_count - 1) downto 0) of block2_reggroup1_rd_valid;
    signal rd_valid_reggroup1 : block2_reggroup1_rd_valid_array;
    -- END READ_VALID RECORD : REGGROUP1
    
    type block2_reggroup1_q is record
        reg1_fld  : std_logic_vector(31 downto 0) ;
        reg2_fld1 : std_logic_vector(31 downto 0) ;
    end record;
    type block2_reggroup1_q_array is array ((block2_reggroup1_count - 1) downto 0) of block2_reggroup1_q;
    signal q_reggroup1 : block2_reggroup1_q_array;
    
    --: REGGROUP1:SECTION OFFSET RECORD
    type block2_ref_name_ref_name_reggroup1_offset is record
        reg1 : natural;
        reg2 : natural;
    end record;
    
    type block2_ref_name_ref_name_reggroup1_offset_array is array ((block2_ref_name_ref_name_reggroup1_count - 1) downto 0) of block2_ref_name_ref_name_reggroup1_offset;
    -- END SECTION OFFSET RECORD : REGGROUP1
    
    --: REGGROUP1:SECTION DECODE RECORD
    type block2_ref_name_ref_name_reggroup1_decode is record
        reg1 :std_logic;
        reg2 :std_logic;
    end record;
    
    type block2_ref_name_ref_name_reggroup1_decode_array is array ((block2_ref_name_ref_name_reggroup1_count - 1) downto 0) of block2_ref_name_ref_name_reggroup1_decode;
    -- END SECTION DECODE RECORD : REGGROUP1
    
    --: REGGROUP1:SECTION RDECODE RECORD
    type block2_ref_name_ref_name_reggroup1_rdecode is record
        reg1 :std_logic;
        reg2 :std_logic;
    end record;
    
    type block2_ref_name_ref_name_reggroup1_rdecode_array is array ((block2_ref_name_ref_name_reggroup1_count - 1) downto 0) of block2_ref_name_ref_name_reggroup1_rdecode;
    -- END SECTION RDECODE RECORD : REGGROUP1
    
    --: REGGROUP1:SECTION  RD_DATA RECORD : REF_NAME_REF_NAME_REGGROUP1
    type block2_ref_name_ref_name_reggroup1_rd_data is record
        reg1 : std_logic_vector((G_AXI_BUS_WIDTH - 1) downto 0);
        reg2 : std_logic_vector((G_AXI_BUS_WIDTH - 1) downto 0);
    end record;
    type block2_ref_name_ref_name_reggroup1_rd_data_array is array ((block2_ref_name_ref_name_reggroup1_count - 1) downto 0) of block2_ref_name_ref_name_reggroup1_rd_data;
    -- END SECTION RD_DATA RECORD : REGGROUP1
    
    --: REGGROUP1  SECTION  WRITE_VALID RECORD
    type block2_ref_name_ref_name_reggroup1_wr_valid is record
        reg1 : std_logic;
        reg2 : std_logic;
    end record;
    type block2_ref_name_ref_name_reggroup1_wr_valid_array is array ((block2_ref_name_ref_name_reggroup1_count - 1) downto 0) of block2_ref_name_ref_name_reggroup1_wr_valid;
    -- END  WRITE_VALID RECORD : REGGROUP1
    
    --: REGGROUP1 SECTION READ_VALID RECORD
    type block2_ref_name_ref_name_reggroup1_rd_valid is record
        reg1 : std_logic;
        reg2 : std_logic;
    end record;
    type block2_ref_name_ref_name_reggroup1_rd_valid_array is array ((block2_ref_name_ref_name_reggroup1_count - 1) downto 0) of block2_ref_name_ref_name_reggroup1_rd_valid;
    -- END READ_VALID RECORD : REGGROUP1
    
    type block2_ref_name_ref_name_reggroup1_q is record
        reg1_fld  : std_logic_vector(31 downto 0) ;
        reg2_fld1 : std_logic_vector(31 downto 0) ;
    end record;
    type block2_ref_name_ref_name_reggroup1_q_array is array ((block2_ref_name_ref_name_reggroup1_count - 1) downto 0) of block2_ref_name_ref_name_reggroup1_q;
    --: REF_NAME:SECTION OFFSET RECORD
    type block2_ref_name_offset is record
        reg1 : natural;
        ref_name_ref_name_reggroup1 : block2_ref_name_ref_name_reggroup1_offset_array;
    end record;
    
    type block2_ref_name_offset_array is array ((block2_ref_name_count - 1) downto 0) of block2_ref_name_offset;
    signal offset_ref_name : block2_ref_name_offset_array;
    -- END SECTION OFFSET RECORD : REF_NAME
    
    --: REF_NAME:SECTION DECODE RECORD
    type block2_ref_name_decode is record
        reg1 :std_logic;
        ref_name_ref_name_reggroup1 : block2_ref_name_ref_name_reggroup1_decode_array;
    end record;
    
    type block2_ref_name_decode_array is array ((block2_ref_name_count - 1) downto 0) of block2_ref_name_decode;
    signal decode_ref_name : block2_ref_name_decode_array;
    -- END SECTION DECODE RECORD : REF_NAME
    
    --: REF_NAME:SECTION RDECODE RECORD
    type block2_ref_name_rdecode is record
        reg1 :std_logic;
        ref_name_ref_name_reggroup1 : block2_ref_name_ref_name_reggroup1_rdecode_array;
    end record;
    
    type block2_ref_name_rdecode_array is array ((block2_ref_name_count - 1) downto 0) of block2_ref_name_rdecode;
    signal rdecode_ref_name : block2_ref_name_rdecode_array;
    -- END SECTION RDECODE RECORD : REF_NAME
    
    --: REF_NAME:SECTION  RD_DATA RECORD : REF_NAME
    type block2_ref_name_rd_data is record
        reg1 : std_logic_vector((G_AXI_BUS_WIDTH - 1) downto 0);
        ref_name_ref_name_reggroup1 : block2_ref_name_ref_name_reggroup1_rd_data_array;
    end record;
    type block2_ref_name_rd_data_array is array ((block2_ref_name_count - 1) downto 0) of block2_ref_name_rd_data;
    signal rd_data_ref_name : block2_ref_name_rd_data_array;
    -- END SECTION RD_DATA RECORD : REF_NAME
    
    --: REF_NAME  SECTION  WRITE_VALID RECORD
    type block2_ref_name_wr_valid is record
        reg1 : std_logic;
        ref_name_ref_name_reggroup1 : block2_ref_name_ref_name_reggroup1_wr_valid_array;
    end record;
    type block2_ref_name_wr_valid_array is array ((block2_ref_name_count - 1) downto 0) of block2_ref_name_wr_valid;
    signal wr_valid_ref_name : block2_ref_name_wr_valid_array;
    -- END  WRITE_VALID RECORD : REF_NAME
    
    --: REF_NAME SECTION READ_VALID RECORD
    type block2_ref_name_rd_valid is record
        reg1 : std_logic;
        ref_name_ref_name_reggroup1 : block2_ref_name_ref_name_reggroup1_rd_valid_array;
    end record;
    type block2_ref_name_rd_valid_array is array ((block2_ref_name_count - 1) downto 0) of block2_ref_name_rd_valid;
    signal rd_valid_ref_name : block2_ref_name_rd_valid_array;
    -- END READ_VALID RECORD : REF_NAME
    
    type block2_ref_name_q is record
        reg1_fld  : std_logic_vector(31 downto 0) ;
        ref_name_ref_name_reggroup1 : block2_ref_name_ref_name_reggroup1_q_array;
    end record;
    type block2_ref_name_q_array is array ((block2_ref_name_count - 1) downto 0) of block2_ref_name_q;
    signal q_ref_name : block2_ref_name_q_array;
    
    signal ext_out_d : block2_ext_outrec;     -- External out signal
    
    begin
        
        
        AXI_WIDGET: entity work.axi_widget
        
        generic map (
            bus_width   => G_AXI_BUS_WIDTH,
            addr_width  => G_AXI_ADDR_WIDTH
        )
        port map (
            aclk         =>   aclk,
            aresetn      =>   aresetn,
            awaddr       =>   awaddr,
            awvalid      =>   awvalid,
            awready      =>   awready,
            awprot       =>   awprot,
            wdata        =>   wdata,
            wvalid       =>   wvalid,
            wready       =>   wready,
            wstrb        =>   wstrb,
            bresp        =>   bresp,
            bready       =>   bready,
            bvalid       =>   bvalid,
            araddr       =>   araddr,
            arvalid      =>   arvalid,
            arready      =>   arready,
            arprot       =>   arprot,
            rdata        =>   rdata,
            rvalid       =>   rvalid,
            rready       =>   rready,
            rresp        =>   rresp,
            -- XRSL IO
            wr_slave_select=>      wr_slave_select,
            rd_slave_select=>      rd_slave_select,
            slvraddr       =>      slvraddr,
            slvwaddr       =>      slvwaddr,
            clk            =>      clk,
            reset_l        =>      reset_l,
            raddress       =>      raddress,
            arprot_i       =>      arprot_i,
            awprot_i       =>      awprot_i,
            wr_error       =>      wr_error,
            wr_decode_error=>      wr_decode_error,
            rd_decode_error=>      rd_decode_error,
            rd_error       =>      rd_error,
            rd_stb         =>      rd_stb,
            rd_wait        =>      rd_wait,
            wr_stb         =>      wr_stb,
            address        =>      address,
            wr_data        =>      wr_data,
            request        =>      request,
            rd_data_vld    =>      rd_data_vld,
            rd_data        =>      rd_data,
            byte_enb       =>      byte_enb
        );
        
        
        ext_out <= ext_out_d;
        
        
        -- Bit/Byte enable
        
        reg_enb <= (31 downto 24 => byte_enb(3)) &(23 downto 16 => byte_enb(2)) &(15 downto 8 => byte_enb(1)) &(7 downto 0 => byte_enb(0));
        
        
        -- REGGROUP1 offset
        generate_reggroup1_offset : for reggroup1_i in (block2_reggroup1_count - 1) downto 0 generate
            offset_reggroup1(reggroup1_i).reg1 <= G_block2_offset + 0 + reggroup1_i * 8 + 0;
            offset_reggroup1(reggroup1_i).reg2 <= G_block2_offset + 0 + reggroup1_i * 8 + 4;
        end generate generate_reggroup1_offset;
        
        -- REF_NAME offset
        generate_ref_name_offset : for ref_name_i in (block2_ref_name_count - 1) downto 0 generate
            offset_ref_name(ref_name_i).reg1 <= G_block2_offset + 8 + ref_name_i * 12 + 0;
            -- REGGROUP1 offset
            generate_ref_name_ref_name_reggroup1_offset : for ref_name_ref_name_reggroup1_i in (block2_ref_name_ref_name_reggroup1_count - 1) downto 0 generate
                offset_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 <= G_block2_offset + 8 + ref_name_i * 12 + 4 + ref_name_ref_name_reggroup1_i * 8 + 0;
                offset_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 <= G_block2_offset + 8 + ref_name_i * 12 + 4 + ref_name_ref_name_reggroup1_i * 8 + 4;
            end generate generate_ref_name_ref_name_reggroup1_offset;
            
        end generate generate_ref_name_offset;
        
        
        -------------------------------------
        -- Register/Section decode
        -------------------------------------
        
        -- REGGROUP1 decode
        generate_reggroup1_decode : for reggroup1_i in (block2_reggroup1_count - 1) downto 0 generate
            decode_reggroup1(reggroup1_i).reg1 <= '1' when to_integer(unsigned(address(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_reggroup1(reggroup1_i).reg1 else '0';
            decode_reggroup1(reggroup1_i).reg2 <= '1' when to_integer(unsigned(address(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_reggroup1(reggroup1_i).reg2 else '0';
        end generate generate_reggroup1_decode;
        
        -- REGGROUP1 rdecode
        generate_reggroup1_rdecode : for reggroup1_i in (block2_reggroup1_count - 1) downto 0 generate
            rdecode_reggroup1(reggroup1_i).reg1 <= '1' when to_integer(unsigned(raddress(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_reggroup1(reggroup1_i).reg1 else '0';
            rdecode_reggroup1(reggroup1_i).reg2 <= '1' when to_integer(unsigned(raddress(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_reggroup1(reggroup1_i).reg2 else '0';
        end generate generate_reggroup1_rdecode;
        
        
        -- REF_NAME decode
        generate_ref_name_decode : for ref_name_i in (block2_ref_name_count - 1) downto 0 generate
            decode_ref_name(ref_name_i).reg1 <= '1' when to_integer(unsigned(address(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_ref_name(ref_name_i).reg1 else '0';
            
            -- REGGROUP1 decode
            generate_ref_name_ref_name_reggroup1_decode : for ref_name_ref_name_reggroup1_i in (block2_ref_name_ref_name_reggroup1_count - 1) downto 0 generate
                decode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 <= '1' when to_integer(unsigned(address(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 else '0';
                decode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 <= '1' when to_integer(unsigned(address(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 else '0';
            end generate generate_ref_name_ref_name_reggroup1_decode;
            
        end generate generate_ref_name_decode;
        
        -- REF_NAME rdecode
        generate_ref_name_rdecode : for ref_name_i in (block2_ref_name_count - 1) downto 0 generate
            rdecode_ref_name(ref_name_i).reg1 <= '1' when to_integer(unsigned(raddress(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_ref_name(ref_name_i).reg1 else '0';
            -- REGGROUP1 rdecode
            generate_ref_name_ref_name_reggroup1_rdecode : for ref_name_ref_name_reggroup1_i in (block2_ref_name_ref_name_reggroup1_count - 1) downto 0 generate
                rdecode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 <= '1' when to_integer(unsigned(raddress(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 else '0';
                rdecode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 <= '1' when to_integer(unsigned(raddress(G_AXI_ADDR_WIDTH-1 downto 0))) = offset_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 else '0';
            end generate generate_ref_name_ref_name_reggroup1_rdecode;
            
        end generate generate_ref_name_rdecode;
        
        
        
        
        
        generate_reggroup1_reg_process : for  reggroup1_i in (block2_reggroup1_count - 1) downto 0 generate
            
            
            
            
            ----------------------------------------------------------------------------------------------------
            -- REGISTER      :  REG1
            -- ADDRESS       :  0x0C                WIDTH : 32
            -- HW ACCESS     :  READ-WRITE
            -- SW ACCESS     :  READ-WRITE
            --
            -- FIELDS   :
            --     31:0 : fld  ( SW : Read-Write HW : Read-Write )
            -----------------------------------------------------------------------------
            -- DESCRIPTION   :  NA
            --
            
            wr_valid_reggroup1(reggroup1_i).reg1 <= '1' when  decode_reggroup1(reggroup1_i).reg1 = '1' and wr_stb = '1'  else '0';
            rd_valid_reggroup1(reggroup1_i).reg1 <= '1' when  rdecode_reggroup1(reggroup1_i).reg1  = '1' and rd_stb = '1'  else '0';
            
            ----------------------------------------------------------------------------
            -- FIELD : FLD
            -- HW ACCESS  :  READ-WRITE                          WIDTH  :  32
            -- SW ACCESS  :  READ-WRITE                          OFFSET :  0
            -----------------------------------------------------------------
            -- DESCRIPTION   :
            --
            reggroup1reggroup1_ireg1_fld : process (clk)
            
            begin
                if rising_edge(clk) then
                    if reset_l = '0' then
                        q_reggroup1(reggroup1_i).reg1_fld  <=  default_reggroup1_reg1_fld;
                    else
                        if (reg_in_enb.reggroup1(reggroup1_i).reg1_fld= '1')  then         --  HW write
                            
                            q_reggroup1(reggroup1_i).reg1_fld <= reg_in.reggroup1(reggroup1_i).reg1_fld;
                        else
                            
                            if ((wr_valid_reggroup1(reggroup1_i).reg1) = '1' ) then          --  SW Write
                                q_reggroup1(reggroup1_i).reg1_fld <= ( wr_data(31 downto 0) and reg_enb(31 downto 0) ) or (q_reggroup1(reggroup1_i).reg1_fld and (not(reg_enb(31 downto 0))));
                                
                                
                            end if;
                        end if ;
                        
                    end if ; -- reset
                    
                end if; -- clock edge
                
            end process reggroup1reggroup1_ireg1_fld;
            -- End REGGROUP1REGGROUP1_IREG1_FLD process
            ----------------------------------------------------------------------------
            
            
            
            ------------------------------------------
            -- signal/output assignment
            ------------------------------------------
            
            rd_data_reggroup1(reggroup1_i).reg1 <=   q_reggroup1(reggroup1_i).reg1_fld;        -- Fields value concatenation of REG1 register
            
            reg_out.reggroup1(reggroup1_i).reg1_fld  <= q_reggroup1(reggroup1_i).reg1_fld;  -- HW output : FLD Read data
            
            reg_out_enb.reggroup1(reggroup1_i).reg1  <= wr_valid_reggroup1(reggroup1_i).reg1;-- HW output : REG1 enable
            
            
            
            -- END : REGISTER - REG1
            
            
            ----------------------------------------------------------------------------------------------------
            -- REGISTER      :  REG2
            -- ADDRESS       :  0x10                WIDTH : 32
            -- HW ACCESS     :  READ-WRITE
            -- SW ACCESS     :  READ-WRITE
            --
            -- FIELDS   :
            --     31:0 : fld1  ( SW : Read-Write HW : Read-Write )
            -----------------------------------------------------------------------------
            -- DESCRIPTION   :  NA
            --
            
            wr_valid_reggroup1(reggroup1_i).reg2 <= '1' when  decode_reggroup1(reggroup1_i).reg2 = '1' and wr_stb = '1'  else '0';
            rd_valid_reggroup1(reggroup1_i).reg2 <= '1' when  rdecode_reggroup1(reggroup1_i).reg2  = '1' and rd_stb = '1'  else '0';
            
            ----------------------------------------------------------------------------
            -- FIELD : FLD1
            -- HW ACCESS  :  READ-WRITE                          WIDTH  :  32
            -- SW ACCESS  :  READ-WRITE                          OFFSET :  0
            -----------------------------------------------------------------
            -- DESCRIPTION   :
            --
            reggroup1reggroup1_ireg2_fld1 : process (clk)
            
            begin
                if rising_edge(clk) then
                    if reset_l = '0' then
                        q_reggroup1(reggroup1_i).reg2_fld1  <=  default_reggroup1_reg2_fld1;
                    else
                        if (reg_in_enb.reggroup1(reggroup1_i).reg2_fld1= '1')  then         --  HW write
                            
                            q_reggroup1(reggroup1_i).reg2_fld1 <= reg_in.reggroup1(reggroup1_i).reg2_fld1;
                        else
                            
                            if ((wr_valid_reggroup1(reggroup1_i).reg2) = '1' ) then          --  SW Write
                                q_reggroup1(reggroup1_i).reg2_fld1 <= ( wr_data(31 downto 0) and reg_enb(31 downto 0) ) or (q_reggroup1(reggroup1_i).reg2_fld1 and (not(reg_enb(31 downto 0))));
                                
                                
                            end if;
                        end if ;
                        
                    end if ; -- reset
                    
                end if; -- clock edge
                
            end process reggroup1reggroup1_ireg2_fld1;
            -- End REGGROUP1REGGROUP1_IREG2_FLD1 process
            ----------------------------------------------------------------------------
            
            
            
            ------------------------------------------
            -- signal/output assignment
            ------------------------------------------
            
            rd_data_reggroup1(reggroup1_i).reg2 <=   q_reggroup1(reggroup1_i).reg2_fld1;        -- Fields value concatenation of REG2 register
            
            reg_out.reggroup1(reggroup1_i).reg2_fld1  <= q_reggroup1(reggroup1_i).reg2_fld1;  -- HW output : FLD1 Read data
            
            reg_out_enb.reggroup1(reggroup1_i).reg2   <= wr_valid_reggroup1(reggroup1_i).reg2;-- HW output : REG2 enable
            
            
            
            -- END : REGISTER - REG2
            
            
        end generate generate_reggroup1_reg_process;
        
        
        
        generate_ref_name_reg_process : for  ref_name_i in (block2_ref_name_count - 1) downto 0 generate
            
            
            
            
            ----------------------------------------------------------------------------------------------------
            -- REGISTER      :  REG1
            -- ADDRESS       :  0x14                WIDTH : 32
            -- HW ACCESS     :  READ-WRITE
            -- SW ACCESS     :  READ-WRITE
            --
            -- FIELDS   :
            --     31:0 : fld  ( SW : Read-Write HW : Read-Write )
            -----------------------------------------------------------------------------
            -- DESCRIPTION   :  NA
            --
            
            wr_valid_ref_name(ref_name_i).reg1 <= '1' when  decode_ref_name(ref_name_i).reg1 = '1' and wr_stb = '1'  else '0';
            rd_valid_ref_name(ref_name_i).reg1 <= '1' when  rdecode_ref_name(ref_name_i).reg1  = '1' and rd_stb = '1'  else '0';
            
            ----------------------------------------------------------------------------
            -- FIELD : FLD
            -- HW ACCESS  :  READ-WRITE                          WIDTH  :  32
            -- SW ACCESS  :  READ-WRITE                          OFFSET :  0
            -----------------------------------------------------------------
            -- DESCRIPTION   :
            --
            ref_nameref_name_ireg1_fld : process (clk)
            
            begin
                if rising_edge(clk) then
                    if reset_l = '0' then
                        q_ref_name(ref_name_i).reg1_fld  <=  default_ref_name_reg1_fld;
                    else
                        if (reg_in_enb.ref_name(ref_name_i).reg1_fld= '1')  then         --  HW write
                            
                            q_ref_name(ref_name_i).reg1_fld <= reg_in.ref_name(ref_name_i).reg1_fld;
                        else
                            
                            if ((wr_valid_ref_name(ref_name_i).reg1) = '1' ) then          --  SW Write
                                q_ref_name(ref_name_i).reg1_fld <= ( wr_data(31 downto 0) and reg_enb(31 downto 0) ) or (q_ref_name(ref_name_i).reg1_fld and (not(reg_enb(31 downto 0))));
                                
                                
                            end if;
                        end if ;
                        
                    end if ; -- reset
                    
                end if; -- clock edge
                
            end process ref_nameref_name_ireg1_fld;
            -- End REF_NAMEREF_NAME_IREG1_FLD process
            ----------------------------------------------------------------------------
            
            
            
            ------------------------------------------
            -- signal/output assignment
            ------------------------------------------
            
            rd_data_ref_name(ref_name_i).reg1 <=   q_ref_name(ref_name_i).reg1_fld;        -- Fields value concatenation of REG1 register
            
            reg_out.ref_name(ref_name_i).reg1_fld  <= q_ref_name(ref_name_i).reg1_fld;  -- HW output : FLD Read data
            
            reg_out_enb.ref_name(ref_name_i).reg1  <= wr_valid_ref_name(ref_name_i).reg1;-- HW output : REG1 enable
            
            
            
            -- END : REGISTER - REG1
            
            generate_ref_name_ref_name_reggroup1_reg_process : for  ref_name_ref_name_reggroup1_i in (block2_ref_name_ref_name_reggroup1_count - 1) downto 0 generate
                
                
                
                
                ----------------------------------------------------------------------------------------------------
                -- REGISTER      :  REG1
                -- ADDRESS       :  0x18                WIDTH : 32
                -- HW ACCESS     :  READ-WRITE
                -- SW ACCESS     :  READ-WRITE
                --
                -- FIELDS   :
                --     31:0 : fld  ( SW : Read-Write HW : Read-Write )
                -----------------------------------------------------------------------------
                -- DESCRIPTION   :  NA
                --
                
                wr_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 <= '1' when  decode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 = '1' and wr_stb = '1'  else '0';
                rd_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 <= '1' when  rdecode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1  = '1' and rd_stb = '1'  else '0';
                
                ----------------------------------------------------------------------------
                -- FIELD : FLD
                -- HW ACCESS  :  READ-WRITE                          WIDTH  :  32
                -- SW ACCESS  :  READ-WRITE                          OFFSET :  0
                -----------------------------------------------------------------
                -- DESCRIPTION   :
                --
                ref_nameref_name_iref_name_ref_name_reggroup1ref_name_ref_name_reggroup1_ireg1_fld : process (clk)
                
                begin
                    if rising_edge(clk) then
                        if reset_l = '0' then
                            q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld  <=  default_ref_name_ref_name_reggroup1_reg1_fld;
                        else
                            if (reg_in_enb.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld= '1')  then         --  HW write
                                
                                q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld <= reg_in.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld;
                            else
                                
                                if ((wr_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1) = '1' ) then          --  SW Write
                                    q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld <= ( wr_data(31 downto 0) and reg_enb(31 downto 0) ) or (q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld and (not(reg_enb(31 downto 0))));
                                    
                                    
                                end if;
                            end if ;
                            
                        end if ; -- reset
                        
                    end if; -- clock edge
                    
                end process ref_nameref_name_iref_name_ref_name_reggroup1ref_name_ref_name_reggroup1_ireg1_fld;
                -- End REF_NAMEREF_NAME_IREF_NAME_REF_NAME_REGGROUP1REF_NAME_REF_NAME_REGGROUP1_IREG1_FLD process
                ----------------------------------------------------------------------------
                
                
                
                ------------------------------------------
                -- signal/output assignment
                ------------------------------------------
                
                rd_data_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 <=   q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld;        -- Fields value concatenation of REG1 register
                
                reg_out.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld  <= q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1_fld;  -- HW output : FLD Read data
                
                reg_out_enb.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1  <= wr_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1;-- HW output : REG1 enable
                
                
                
                -- END : REGISTER - REG1
                
                
                ----------------------------------------------------------------------------------------------------
                -- REGISTER      :  REG2
                -- ADDRESS       :  0x1C                WIDTH : 32
                -- HW ACCESS     :  READ-WRITE
                -- SW ACCESS     :  READ-WRITE
                --
                -- FIELDS   :
                --     31:0 : fld1  ( SW : Read-Write HW : Read-Write )
                -----------------------------------------------------------------------------
                -- DESCRIPTION   :  NA
                --
                
                wr_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 <= '1' when  decode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 = '1' and wr_stb = '1'  else '0';
                rd_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 <= '1' when  rdecode_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2  = '1' and rd_stb = '1'  else '0';
                
                ----------------------------------------------------------------------------
                -- FIELD : FLD1
                -- HW ACCESS  :  READ-WRITE                          WIDTH  :  32
                -- SW ACCESS  :  READ-WRITE                          OFFSET :  0
                -----------------------------------------------------------------
                -- DESCRIPTION   :
                --
                ref_nameref_name_iref_name_ref_name_reggroup1ref_name_ref_name_reggroup1_ireg2_fld1 : process (clk)
                
                begin
                    if rising_edge(clk) then
                        if reset_l = '0' then
                            q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1  <=  default_ref_name_ref_name_reggroup1_reg2_fld1;
                        else
                            if (reg_in_enb.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1= '1')  then         --  HW write
                                
                                q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1 <= reg_in.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1;
                            else
                                
                                if ((wr_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2) = '1' ) then          --  SW Write
                                    q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1 <= ( wr_data(31 downto 0) and reg_enb(31 downto 0) ) or (q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1 and (not(reg_enb(31 downto 0))));
                                    
                                    
                                end if;
                            end if ;
                            
                        end if ; -- reset
                        
                    end if; -- clock edge
                    
                end process ref_nameref_name_iref_name_ref_name_reggroup1ref_name_ref_name_reggroup1_ireg2_fld1;
                -- End REF_NAMEREF_NAME_IREF_NAME_REF_NAME_REGGROUP1REF_NAME_REF_NAME_REGGROUP1_IREG2_FLD1 process
                ----------------------------------------------------------------------------
                
                
                
                ------------------------------------------
                -- signal/output assignment
                ------------------------------------------
                
                rd_data_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 <=   q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1;        -- Fields value concatenation of REG2 register
                
                reg_out.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1  <= q_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2_fld1;  -- HW output : FLD1 Read data
                
                reg_out_enb.ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2   <= wr_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2;-- HW output : REG2 enable
                
                
                
                -- END : REGISTER - REG2
                
                
            end generate generate_ref_name_ref_name_reggroup1_reg_process;
            
            
            
            
        end generate generate_ref_name_reg_process;
        
        
        
        
        
        -------------------------------
        --  Read Data back stages
        --------------------------
        read_back_mux : process(
            rd_valid_reggroup1,
            
            rd_data_reggroup1,
            
            rd_valid_ref_name,
            
            rd_data_ref_name
        )
        begin
            
            rd_data0     <= (others => '0');
            
            loop_reggroup1_rd_data : for reggroup1_i in block2_reggroup1_count - 1 downto 0 loop
                if (rd_valid_reggroup1(reggroup1_i).reg1 = '1') then
                    rd_data0 <= rd_data_reggroup1(reggroup1_i).reg1;
                end if;
                
                if (rd_valid_reggroup1(reggroup1_i).reg2 = '1') then
                    rd_data0 <= rd_data_reggroup1(reggroup1_i).reg2;
                end if;
                
            end loop loop_reggroup1_rd_data;
            
            loop_ref_name_rd_data : for ref_name_i in block2_ref_name_count - 1 downto 0 loop
                if (rd_valid_ref_name(ref_name_i).reg1 = '1') then
                    rd_data0 <= rd_data_ref_name(ref_name_i).reg1;
                end if;
                
                loop_ref_name_ref_name_reggroup1_rd_data : for ref_name_ref_name_reggroup1_i in block2_ref_name_ref_name_reggroup1_count - 1 downto 0 loop
                    if (rd_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1 = '1') then
                        rd_data0 <= rd_data_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg1;
                    end if;
                    
                    if (rd_valid_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2 = '1') then
                        rd_data0 <= rd_data_ref_name(ref_name_i).ref_name_ref_name_reggroup1(ref_name_ref_name_reggroup1_i).reg2;
                    end if;
                    
                end loop loop_ref_name_ref_name_reggroup1_rd_data;
                
            end loop loop_ref_name_rd_data;
            
        end process read_back_mux;
        
        -- End of Read Data back stages
        
        
        
        wr_error <= '0';
        
        rd_error <= '0';
        
        wr_decode_error <= '0';
        
        rd_decode_error <= '0';
        request <= '1';          -- HIGH(always for internal registers) indicates bus is free , LOW indicates bus is busy, external_wr_req(always for external registers)
        rd_data_vld0 <= rd_stb;  -- if all internal registers, route the read strobe back, data is already valid
        rd_wait  <= '1';         -- HIGH in case of internal registers implementation and external_rd_ack when to read external registers
        
        rd_data      <= rd_data0;
        rd_data_vld  <= rd_data_vld0;
        
        ext_out_d.dummy <= '0';
        
        wr_slave_select <= '1' when((slvwaddr(G_AXI_ADDR_WIDTH - 1 downto 0)  >= G_block2_offset) and (slvwaddr(G_AXI_ADDR_WIDTH - 1 downto 0)  <= G_block2_offset + block2_end_addr)) else '0';
        rd_slave_select <= '1' when((slvraddr(G_AXI_ADDR_WIDTH - 1 downto 0)  >= G_block2_offset) and (slvraddr(G_AXI_ADDR_WIDTH - 1 downto 0)  <= G_block2_offset + block2_end_addr)) else '0';
        
    end rtl;
-- end_arch

--
