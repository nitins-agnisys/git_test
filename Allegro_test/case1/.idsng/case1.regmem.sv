//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Admin
// generated from    : C:\Users\Admin\Documents\GitHub\git_test\Allegro_test\case1\case1.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AXI
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------
/*----------------------------------------------------------------------
Class       : block1_reg1
-----------------------------------------------------------------------*/

`ifndef CLASS_block1_reg1
`define CLASS_block1_reg1
typedef class chip_name_block;
    class block1_reg1 extends uvm_reg;
        `uvm_object_utils(block1_reg1)

        constraint  fld_enum
        {
            fld.value inside { chip_name_block::e1,chip_name_block::e2 };
        }

        rand uvm_reg_field fld;

        // Function : new
        function new(string name = "block1_reg1");
            super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
            add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        endfunction

        // Function : build
        virtual function void build();
            this.fld = uvm_reg_field::type_id::create("fld");

            this.fld.configure(this, 32,  0, "RW", 0, chip_name_block::e1, 1, 1, 0);

        endfunction
    endclass
    `endif

    /*----------------------------------------------------------------------
    Class       : block1_reggroup1_reg1
    -----------------------------------------------------------------------*/

    `ifndef CLASS_block1_reggroup1_reg1
    `define CLASS_block1_reggroup1_reg1
    typedef class chip_name_block;
        class block1_reggroup1_reg1 extends uvm_reg;
            `uvm_object_utils(block1_reggroup1_reg1)

            constraint  fld_enum
            {
                fld.value inside { chip_name_block::e1,chip_name_block::e2 };
            }

            rand uvm_reg_field fld;

            // Function : new
            function new(string name = "block1_reggroup1_reg1");
                super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
                add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

            endfunction

            // Function : build
            virtual function void build();
                this.fld = uvm_reg_field::type_id::create("fld");

                this.fld.configure(this, 32,  0, "RW", 0, chip_name_block::e2, 1, 1, 0);

            endfunction
        endclass
        `endif

        /*----------------------------------------------------------------------
        Class       : block1_reggroup1_reg2
        -----------------------------------------------------------------------*/

        `ifndef CLASS_block1_reggroup1_reg2
        `define CLASS_block1_reggroup1_reg2
        class block1_reggroup1_reg2 extends uvm_reg;
            `uvm_object_utils(block1_reggroup1_reg2)

            rand uvm_reg_field fld1;

            // Function : new
            function new(string name = "block1_reggroup1_reg2");
                super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
                add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

            endfunction

            // Function : build
            virtual function void build();
                this.fld1 = uvm_reg_field::type_id::create("fld1");

                this.fld1.configure(this, 32,  0, "RO", 0, 'd0, 1, 1, 0);

            endfunction
        endclass
        `endif

        /*----------------------------------------------------------------------
        Class       : block1_reggroup1
        -----------------------------------------------------------------------*/
        `ifndef CLASS_block1_reggroup1
        `define CLASS_block1_reggroup1
        class block1_reggroup1 extends uvm_reg_file;
            `uvm_object_utils(block1_reggroup1)

            rand block1_reggroup1_reg1 reg1;

            rand block1_reggroup1_reg2 reg2;

            // Function : new
            function new(string name = "block1_reggroup1");
                super.new(name);
            endfunction

            // Function : build
            virtual function void build();
                //create
                reg1   =   block1_reggroup1_reg1::type_id::create("reg1");
                reg2   =   block1_reggroup1_reg2::type_id::create("reg2");

                //config
                reg1.configure(get_block(), this, "reg1");
                reg2.configure(get_block(), this, "reg2");

                //build
                reg1.build();
                reg2.build();
            endfunction

            virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
                //add reg and regfiles
                mp.add_reg( reg1, offset +  'h0, "RW");
                mp.add_reg( reg2, offset +  'h4, "RW");
            endfunction

            virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
                reg1.set_offset(mp, offset +  'h0);
                reg2.set_offset(mp, offset +  'h4);
            endfunction
        endclass
        `endif

        /*----------------------------------------------------------------------
        Class      : block1_block
        -----------------------------------------------------------------------*/
        `ifndef CLASS_block1_block
        `define CLASS_block1_block
        class block1_block extends uvm_reg_block;
            `uvm_object_utils(block1_block)

            rand block1_reg1 reg1;

            rand block1_reggroup1 reggroup1;

            // Function : new
            function new(string name = "block1_block");
                super.new(name, UVM_NO_COVERAGE);
            endfunction

            // Function : build
            virtual function void build();
                //REG1
                reg1   =   block1_reg1::type_id::create("reg1");
                reg1.configure(this, null, "reg1");
                reg1.build();

                //REGGROUP1
                reggroup1   =   block1_reggroup1::type_id::create("reggroup1");
                reggroup1.configure(this, null, "reggroup1");
                reggroup1.build();

                //define default map and add reg/regfiles
                default_map= create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
                default_map.add_reg( reg1, 'h0, "RW");
                reggroup1.map( default_map, 'h4);

                lock_model();
            endfunction

        endclass : block1_block
        `endif

        /*----------------------------------------------------------------------
        Class       : block2_reggroup1_reg1
        -----------------------------------------------------------------------*/

        `ifndef CLASS_block2_reggroup1_reg1
        `define CLASS_block2_reggroup1_reg1
        class block2_reggroup1_reg1 extends uvm_reg;
            `uvm_object_utils(block2_reggroup1_reg1)

            rand uvm_reg_field fld;

            // Function : new
            function new(string name = "block2_reggroup1_reg1");
                super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
                add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

            endfunction

            // Function : build
            virtual function void build();
                this.fld = uvm_reg_field::type_id::create("fld");

                this.fld.configure(this, 32,  0, "RW", 0, 'd0, 1, 1, 0);

            endfunction
        endclass
        `endif

        /*----------------------------------------------------------------------
        Class       : block2_reggroup1_reg2
        -----------------------------------------------------------------------*/

        `ifndef CLASS_block2_reggroup1_reg2
        `define CLASS_block2_reggroup1_reg2
        class block2_reggroup1_reg2 extends uvm_reg;
            `uvm_object_utils(block2_reggroup1_reg2)

            rand uvm_reg_field fld1;

            // Function : new
            function new(string name = "block2_reggroup1_reg2");
                super.new(name, 32, build_coverage(UVM_NO_COVERAGE));
                add_coverage(build_coverage(UVM_NO_COVERAGE));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

            endfunction

            // Function : build
            virtual function void build();
                this.fld1 = uvm_reg_field::type_id::create("fld1");

                this.fld1.configure(this, 32,  0, "RO", 0, 'd0, 1, 1, 0);

            endfunction
        endclass
        `endif

        /*----------------------------------------------------------------------
        Class       : block2_reggroup1
        -----------------------------------------------------------------------*/
        `ifndef CLASS_block2_reggroup1
        `define CLASS_block2_reggroup1
        class block2_reggroup1 extends uvm_reg_file;
            `uvm_object_utils(block2_reggroup1)

            rand block2_reggroup1_reg1 reg1;

            rand block2_reggroup1_reg2 reg2;

            // Function : new
            function new(string name = "block2_reggroup1");
                super.new(name);
            endfunction

            // Function : build
            virtual function void build();
                //create
                reg1   =   block2_reggroup1_reg1::type_id::create("reg1");
                reg2   =   block2_reggroup1_reg2::type_id::create("reg2");

                //config
                reg1.configure(get_block(), this, "reg1");
                reg2.configure(get_block(), this, "reg2");

                //build
                reg1.build();
                reg2.build();
            endfunction

            virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
                //add reg and regfiles
                mp.add_reg( reg1, offset +  'h0, "RW");
                mp.add_reg( reg2, offset +  'h4, "RW");
            endfunction

            virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
                reg1.set_offset(mp, offset +  'h0);
                reg2.set_offset(mp, offset +  'h4);
            endfunction
        endclass
        `endif

        /*----------------------------------------------------------------------
        Class      : block2_block
        -----------------------------------------------------------------------*/
        `ifndef CLASS_block2_block
        `define CLASS_block2_block
        class block2_block extends uvm_reg_block;
            `uvm_object_utils(block2_block)

            rand block2_reggroup1 reggroup1;

            // Function : new
            function new(string name = "block2_block");
                super.new(name, UVM_NO_COVERAGE);
            endfunction

            // Function : build
            virtual function void build();
                //REGGROUP1
                reggroup1   =   block2_reggroup1::type_id::create("reggroup1");
                reggroup1.configure(this, null, "reggroup1");
                reggroup1.build();

                //define default map and add reg/regfiles
                default_map= create_map("default_map", 'hC, 4, UVM_LITTLE_ENDIAN, 1);
                reggroup1.map( default_map, 'h0);

                lock_model();
            endfunction

        endclass : block2_block
        `endif

        /*----------------------------------------------------------------------
        Class      : chip_name_block
        -----------------------------------------------------------------------*/
        `ifndef CLASS_chip_name_block
        `define CLASS_chip_name_block
        class chip_name_block extends uvm_reg_block;
            `uvm_object_utils(chip_name_block)

            typedef enum {
                e1  =  0,  //
                e2  =  1  //
            } enum_name;

            rand block1_block block1;

            rand block2_block block2;

            rand block1_block ref_name;

            // Function : new
            function new(string name = "chip_name_block");
                super.new(name, UVM_NO_COVERAGE);
            endfunction

            // Function : build
            virtual function void build();
                //BLOCK1
                block1   =   block1_block::type_id::create("block1");
                block1.configure(this, "block1");
                block1.build();

                //BLOCK2
                block2   =   block2_block::type_id::create("block2");
                block2.configure(this, "block2");
                block2.build();

                //REF_NAME
                ref_name   =   block1_block::type_id::create("ref_name");
                ref_name.configure(this, "ref_name");
                ref_name.build();

                //define default map and add reg/regfiles
                default_map= create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
                default_map.add_submap( block1.default_map, 'h0);
                default_map.add_submap( block2.default_map, 'hC);
                default_map.add_submap( ref_name.default_map, 'h14);

                lock_model();
            endfunction

        endclass : chip_name_block
        `endif
