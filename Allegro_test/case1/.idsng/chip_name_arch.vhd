--Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
--
--*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
-- created by        :
-- generated by      : Admin
-- generated from    : C:\Users\Admin\Documents\GitHub\git_test\Allegro_test\case1\case1.idsng
-- IDesignSpec rev   : idsbatch v4.16.26.2

--*** This code is generated with following settings ***
-- Reg Width                  : 32
-- Address Unit               : 8
-- C++ Types int              : hwint
-- Bus Type                   : AXI
-- BigEndian                  : false
-- LittleEndian               : false
-- Dist. Decode and Readback  : false
-----------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------
-- ARCHITECTURE : chip_name_e ENTITY
----------------------------------------------------------------------------

architecture rtl of chip_name_e is
    --: BLOCK1
    signal rdata_block1:  std_logic_vector(G_AXI_BUS_WIDTH - 1 downto 0) ;
    signal awvalid_block1:  std_logic ;
    signal wvalid_block1:  std_logic ;
    signal arvalid_block1:  std_logic ;
    signal rvalid_block1:  std_logic ;
    signal awready_block1:  std_logic ;
    signal wready_block1:  std_logic ;
    signal bresp_block1:  std_logic_vector(1 downto 0) ;
    signal bvalid_block1:  std_logic ;
    signal arready_block1:  std_logic ;
    signal rresp_block1:  std_logic_vector(1 downto 0) ;
    
    
    signal block1_select_wr : std_logic;
    signal block1_select_rd : std_logic;
    
    signal block1_wr_data_busy : std_logic;
    signal block1_wr_addr_busy : std_logic;
    signal block1_rd_busy : std_logic;
    
    signal block2_select_wr : std_logic;
    signal block2_select_rd : std_logic;
    
    signal block2_wr_data_busy : std_logic;
    signal block2_wr_addr_busy : std_logic;
    signal block2_rd_busy : std_logic;
    
    signal slave_bresp:  std_logic_vector(1 downto 0) ;
    signal slave_rresp:  std_logic_vector(1 downto 0) ;
    signal wready_sig :  std_logic ;
    signal bvalid_sig :  std_logic ;
    signal arready_sig:  std_logic ;
    signal awready_sig:  std_logic ;
    
    signal invalid_address_wr   : std_logic;
    signal invalid_address_rd   : std_logic;
    signal wr_error             : std_logic;
    signal rd_error             : std_logic;
    signal awvalid_ff           : std_logic;
    signal wvalid_ff            : std_logic;
    signal rresp_ff             : std_logic_vector(1 downto 0);
    signal bresp_ff             : std_logic_vector(1 downto 0);
    --: BLOCK2
    signal rdata_block2:  std_logic_vector(G_AXI_BUS_WIDTH - 1 downto 0) ;
    signal awvalid_block2:  std_logic ;
    signal wvalid_block2:  std_logic ;
    signal arvalid_block2:  std_logic ;
    signal rvalid_block2:  std_logic ;
    signal awready_block2:  std_logic ;
    signal wready_block2:  std_logic ;
    signal bresp_block2:  std_logic_vector(1 downto 0) ;
    signal bvalid_block2:  std_logic ;
    signal arready_block2:  std_logic ;
    signal rresp_block2:  std_logic_vector(1 downto 0) ;
    
    
    
    
    -- and_reduce function
    function and_reduce (arg : std_logic_vector )
    return std_logic is
    variable Upper, Lower : std_logic;
    variable Half : integer;
    variable BUS_int : std_logic_vector ( arg'length - 1 downto 0 );
    variable Result : std_logic;
    begin
        if (arg'LENGTH  <  1) then            -- In the case of a NULL range
            Result := '1';
        else
            BUS_int := to_ux01 (arg);
            if ( BUS_int'length = 1 ) then
                Result := BUS_int ( BUS_int'left );
            elsif ( BUS_int'length = 2 ) then
                Result := BUS_int ( BUS_int'right ) and BUS_int ( BUS_int'left );
            else
                Half := ( BUS_int'length + 1 ) / 2 + BUS_int'right;
                Upper := and_reduce ( BUS_int ( BUS_int'left downto Half ));
                Lower := and_reduce ( BUS_int ( Half - 1 downto BUS_int'right ));
                Result := Upper and Lower;
            end if;
        end if;
        return Result;
    end;
    -- End function and_reduce
    
    
    
    
    begin
        
        block1_select_wr <= '1' when ( (to_integer(unsigned(awaddr(G_AXI_ADDR_WIDTH -1 downto 0))) >= G_chip_block1_offset ) and (to_integer(unsigned(awaddr(G_AXI_ADDR_WIDTH -1 downto 0))) <= G_chip_block1_offset + 11)) else '0';
        block1_select_rd <= '1' when ( (to_integer(unsigned(araddr(G_AXI_ADDR_WIDTH -1 downto 0))) >= G_chip_block1_offset ) and (to_integer(unsigned(araddr(G_AXI_ADDR_WIDTH -1 downto 0))) <= G_chip_block1_offset + 11))  else '0';
        awvalid_block1 <=  (awvalid and not(block1_wr_addr_busy)  and not(and_reduce(bresp_ff) and not(bready and bvalid_sig)));
        wvalid_block1 <=  (wvalid and not(block1_wr_data_busy)  and not(and_reduce(bresp_ff) and not(bready and bvalid_sig)));
        arvalid_block1 <=  (arvalid and  not(rd_error)  and not(block2_rd_busy )and not(and_reduce(rresp_ff) and not(rready)));
        
        block1: entity work.block1_e
        generic map (
            G_AXI_BUS_WIDTH => G_AXI_BUS_WIDTH,
            G_AXI_ADDR_WIDTH => G_AXI_ADDR_WIDTH,
            G_block1_offset =>  G_chip_block1_offset
        )
        
        port map (
            
            
            --  BUS  : AXI
            aclk         => aclk,
            aresetn      => aresetn,
            awaddr       => awaddr,
            awvalid      => awvalid_block1,
            awready      => awready_block1,
            awprot       => awprot,
            wdata        => wdata,
            wvalid       => wvalid_block1,
            wready       => wready_block1,
            wstrb        => wstrb,
            bresp        => bresp_block1,
            bready       => bready,
            bvalid       => bvalid_block1,
            araddr       => araddr,
            arvalid      => arvalid_block1,
            arready      => arready_block1,
            arprot       => arprot,
            rdata        => rdata_block1,
            rvalid       => rvalid_block1,
            rready       => rready,
            rresp        => rresp_block1,
            -- XRSL IO
            
            reg_in => reg_in.block1,
            reg_out => reg_out.block1,
            reg_out_enb => reg_out_enb.block1,
            reg_in_enb => reg_in_enb.block1,
            ext_in => ext_in.block1,
            ext_out => ext_out.block1
        );
        
        block2_select_wr <= '1' when ( (to_integer(unsigned(awaddr(G_AXI_ADDR_WIDTH -1 downto 0))) >= G_chip_block2_offset ) and (to_integer(unsigned(awaddr(G_AXI_ADDR_WIDTH -1 downto 0))) <= G_chip_block2_offset + 19)) else '0';
        block2_select_rd <= '1' when ( (to_integer(unsigned(araddr(G_AXI_ADDR_WIDTH -1 downto 0))) >= G_chip_block2_offset ) and (to_integer(unsigned(araddr(G_AXI_ADDR_WIDTH -1 downto 0))) <= G_chip_block2_offset + 19))  else '0';
        awvalid_block2 <=  (awvalid and not(block2_wr_addr_busy)  and not(and_reduce(bresp_ff) and not(bready and bvalid_sig)));
        wvalid_block2 <=  (wvalid and not(block2_wr_data_busy)  and not(and_reduce(bresp_ff) and not(bready and bvalid_sig)));
        arvalid_block2 <=  (arvalid and  not(rd_error)  and not(block1_rd_busy )and not(and_reduce(rresp_ff) and not(rready)));
        
        block2: entity work.block2_e
        generic map (
            G_AXI_BUS_WIDTH => G_AXI_BUS_WIDTH,
            G_AXI_ADDR_WIDTH => G_AXI_ADDR_WIDTH,
            G_block2_offset =>  G_chip_block2_offset
        )
        
        port map (
            
            
            --  BUS  : AXI
            aclk         => aclk,
            aresetn      => aresetn,
            awaddr       => awaddr,
            awvalid      => awvalid_block2,
            awready      => awready_block2,
            awprot       => awprot,
            wdata        => wdata,
            wvalid       => wvalid_block2,
            wready       => wready_block2,
            wstrb        => wstrb,
            bresp        => bresp_block2,
            bready       => bready,
            bvalid       => bvalid_block2,
            araddr       => araddr,
            arvalid      => arvalid_block2,
            arready      => arready_block2,
            arprot       => arprot,
            rdata        => rdata_block2,
            rvalid       => rvalid_block2,
            rready       => rready,
            rresp        => rresp_block2,
            -- XRSL IO
            
            reg_in => reg_in.block2,
            reg_out => reg_out.block2,
            reg_out_enb => reg_out_enb.block2,
            reg_in_enb => reg_in_enb.block2,
            ext_in => ext_in.block2,
            ext_out => ext_out.block2
        );
        
        
        invalid_address_wr <= not(block1_select_wr or block2_select_wr) ;
        invalid_address_rd <= not(block1_select_rd or block2_select_rd) ;
        
        block1_wr_data_busy <= '1' when (awready_block2 = '0' or wready_block1 = '0') else '0';
        block1_wr_addr_busy <= '1' when (awready_block2 = '0') else '0';
        block1_rd_busy <= '1' when (arready_block1 = '0') else '0';
        
        block2_wr_data_busy <= '1' when (awready_block1 = '0' or wready_block2 = '0') else '0';
        block2_wr_addr_busy <= '1' when (awready_block1 = '0') else '0';
        block2_rd_busy <= '1' when (arready_block2 = '0') else '0';
        
        rdata       <= rdata_block1 or rdata_block2;
        rvalid      <= and_reduce(rresp_ff) or rvalid_block1 or rvalid_block2;
        awready_sig <= (wvalid_ff and bready) when and_reduce(bresp_ff) ='1' else awready_block1 and awready_block2;
        awready     <= awready_sig ;
        wready_sig  <= bready when and_reduce(bresp_ff) ='1' and  wvalid_ff ='1' else wready_block1 and wready_block2;
        wready      <= wready_sig;
        slave_bresp <= bresp_block1 or bresp_block2;
        bresp       <= (bresp_ff and ((wvalid_ff and awvalid_ff) & (wvalid_ff and awvalid_ff))) or slave_bresp;
        bvalid_sig  <= (and_reduce(bresp_ff) and (wvalid_ff and awvalid_ff)) or bvalid_block1 or bvalid_block2;
        bvalid      <= bvalid_sig;
        arready_sig <= rready when and_reduce(rresp_ff)='1' else arready_block1 and arready_block2;
        arready     <= arready_sig;
        slave_rresp <= rresp_block1 or rresp_block2;
        rresp       <= rresp_ff or slave_rresp;
        
        
        
        
        wr_error <= invalid_address_wr when (awvalid ='1' and awready_sig = '1') else '0';
        rd_error <= invalid_address_rd when (arvalid ='1' and arready_sig = '1') else '0';
        
        
        process(aclk)
        begin
            if rising_edge(aclk)then
                if aresetn = '0' then
                    
                    bresp_ff   <= "00" ;
                    rresp_ff   <= "00" ;
                    awvalid_ff <= '0'  ;
                    wvalid_ff  <= '0'  ;
                    
                else
                    if (awvalid_ff ='1' and (awvalid ='0' or awready_sig ='0'))then
                        awvalid_ff <=not(bvalid_sig and bready);
                    else
                        awvalid_ff <=(awvalid and awready_sig);
                    end if;
                    if (wvalid_ff ='1' and (wvalid ='0' or wready_sig ='0'))then
                        wvalid_ff <=not(bvalid_sig and bready);
                    else
                        wvalid_ff <=(wvalid and wready_sig);
                    end if;
                    if (rresp_ff ="11" and rd_error ='0')then
                        rresp_ff <= (not(rready) &  not(rready));
                    else
                        rresp_ff <=(rd_error &  rd_error);
                    end if;
                    if(awvalid_ff ='1' and and_reduce(bresp_ff)='1' and wr_error ='0' and wvalid_ff ='1') then
                        bresp_ff <= (not(bready) & not(bready));
                    elsif(awvalid_ff ='1' and and_reduce(bresp_ff)='1')then
                        bresp_ff <= bresp_ff;
                    elsif( bresp_ff ="11" and wr_error ='0')then
                        bresp_ff <= (not(bready) & not(bready));
                    else
                        bresp_ff <= ((wr_error and ((awvalid and awready_sig) or awvalid_ff)) & (wr_error and ((awvalid and awready_sig) or awvalid_ff)));
                    end if;
                end if;
            end if ;-- always clk
        end process ;
        
        
        
        
    end rtl;
-- end_arch
