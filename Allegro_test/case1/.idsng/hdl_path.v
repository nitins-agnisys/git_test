//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Admin
// generated from    : C:\Users\Admin\Documents\GitHub\git_test\Allegro_test\case1\hdl_path.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AXI
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

//------------------------------------------------
//  BLOCK : BLOCK_NAME MODULE
//
`define w1  12

module block_name_ids(
    
    // REGISTER : REG_NAME PORT SIGNAL
    reg_name_enb,
    reg_name_fld1_in,
    reg_name_fld1_in_enb,
    reg_name_fld1_r,
    
    
    // SECTION(EXTERNAL) : MEMORY_NAME PORT SIGNAL
    memory_name_rd_ack_in,
    memory_name_rd_data_in,
    memory_name_rd_valid_out,
    memory_name_wr_req_in,
    memory_name_wr_valid_out,
    
    
    
    //Signals  : SIGNALS
    S1,
    S2,
    
    
    raddress_out,
    address_out,
    wr_data_out,
    
    //AXI signals
    aclk,   // Bus clock
    aresetn,   // Reset
    awaddr,   // Write address
    awvalid,   // Write address valid : This signal indicates that write address is valid
    awready,   // Write address ready : This signal indicates that the slave is ready to accept an address
    awprot,   // Write Protection Type
    wdata,   // Write data
    wvalid,   // Write valid         : This signal indicates that valid write data and strobes are available
    wready,   // Write ready         : This signal indicates that the slave can accept the write data
    wstrb,   // Write Strobes
    bresp,   // Write Response
    bready,   // Response Ready
    bvalid,   // Response valid
    araddr,   // Read  address
    arvalid,   // Read address valid  : This signal indicates that the read address is valid and will remain stable until ARREADY is high
    arready,   // Read address ready  : This signal indicates that the slave is ready to accept an address
    arprot,   // Read Protection Type
    rdata,   // Read data
    rvalid,   // Read valid          : This signal indicates that the required read data is available and the read transfer can complete
    rready,   // Read ready          : This signal indicates that the master can accept the read data
    rresp   // Read Response
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 10;
    
    parameter block_offset  = {(addr_width){1'b0}};
    parameter  [0:0]  // synopsys enum  enum_name
    E1  =  1'h1    //
    ;
    
    
    // SECTION : MEMORY_NAME
    parameter memory_name_count         = 100;
    parameter memory_name_address_width = addr_width - 10;
    
    // REGISTER : REG_NAME
    parameter reg_name_count         = `w1;
    parameter reg_name_address_width = addr_width;
    
    
    parameter block_name_address_width = addr_width;
    
    
    //Signals  : SIGNALS
    input S1;
    output S2;
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME SIGNALS
    
    
    wire    reg_name_decode[reg_name_count-1 : 0];         // Write DECODE
    wire    reg_name_rdecode[reg_name_count-1 : 0];        // Read  DECODE
    wire    [reg_name_count-1 : 0]reg_name_wr_valid;       // WRITE VALID
    wire    [reg_name_count-1 : 0]reg_name_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] reg_name_rd_data[reg_name_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] reg_name_offset[reg_name_count-1 : 0];  // OFFSET
    wor   [bus_width-1 : 0] reg_name_rd_data_wor;
    output [reg_name_count-1 : 0] reg_name_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input  [reg_name_count-1 : 0] reg_name_fld1_in_enb ;      // FIELD : FLD1
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] reg_name_fld1_q[reg_name_count-1 : 0] ;      // FIELD : FLD1
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [reg_name_count*32-1 : 0] reg_name_fld1_r ;      // FIELD : FLD1
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [reg_name_count*32-1 : 0] reg_name_fld1_in ;      // FIELD : FLD1
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : MEMORY_NAME SIGNALS
    input   memory_name_rd_ack_in;
    input  [bus_width-1 : 0] memory_name_rd_data_in;
    output  memory_name_rd_valid_out;
    input   memory_name_wr_req_in;
    output  memory_name_wr_valid_out;
    wire    memory_name_decode;
    wire    memory_name_rdecode;
    wire    [64-1 : 0] memory_name_offset;
    wire     memory_name_rd_valid;
    wire     memory_name_wr_valid;
    wor     memory_name_wr_req_wor;
    wor     memory_name_rd_ack_wor;
    wor     memory_name_decode_wor;
    
    wire    [bus_width-1 : 0] memory_name_rd_data;
    wire    memory_name_write_error;
    wor     memory_name_write_error_wor;
    
    //-----------------------------------------------------
    
    
    output [addr_width-1:0] raddress_out;
    
    output [addr_width-1:0] address_out;
    output [bus_width-1:0] wr_data_out;
    wire  [bus_width-1:0] int_rd_data;
    wire  [bus_width-1:0] ext_rd_data;
    wire external_rd_valid;
    reg  rd_wait_state;
    wire external_rd_ack;
    wire external_wr_req;
    wire external_access;
    
    //AXI signals
    input aclk;
    input aresetn;
    input [addr_width-1 : 0] awaddr;
    input awvalid;
    output awready;
    input [2 : 0] awprot;
    wire  [2 : 0] awprot_i;
    input [bus_width-1 : 0] wdata;
    input wvalid;
    output wready;
    input [bus_width/8-1 : 0] wstrb;
    output [1 : 0] bresp;
    input bready;
    output bvalid;
    input [addr_width-1 : 0] araddr;
    input arvalid;
    output arready;
    input [2 : 0] arprot;
    wire  [2 : 0] arprot_i;
    output [bus_width-1 : 0] rdata;
    output rvalid;
    input rready;
    output [1 : 0] rresp;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire [addr_width-1 : 0] raddress;
    wire  wr_error;
    wire  rd_error;
    wire  wr_decode_error;
    wire  rd_decode_error;
    wire  wr_slave_select;
    wire  rd_slave_select;
    wire  [addr_width-1:0] slvwaddr;
    wire  [addr_width-1:0] slvraddr;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    axi_widget #(.addr_width(addr_width), .bus_width(bus_width)) axi(
            .aclk(aclk),
            .aresetn(aresetn),
            .awaddr(awaddr),
            .awvalid(awvalid),
            .awready(awready),
            .awprot(awprot),
            .awprot_i(awprot_i),
            .wdata(wdata),
            .wvalid(wvalid),
            .wready(wready),
            .wstrb(wstrb),
            .bresp(bresp),
            .bready(bready),
            .bvalid(bvalid),
            .araddr(araddr),
            .arvalid(arvalid),
            .arready(arready),
            .arprot(arprot),
            .arprot_i(arprot_i),
            .rdata(rdata),
            .rvalid(rvalid),
            .rready(rready),
            .rresp(rresp),
            .clk(clk),
            .reset_l(reset_l),
            .request(request),
            .wr_stb(wr_stb),
            .wr_decode_error(wr_decode_error),
            .rd_decode_error(rd_decode_error),
            .wr_slave_select(wr_slave_select),
            .rd_slave_select(rd_slave_select),
            .slvwaddr(slvwaddr),
            .slvraddr(slvraddr),
            .rd_stb(rd_stb),
            .rd_wait(rd_wait),
            .wr_error(wr_error),
            .rd_error(rd_error),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .raddress(raddress),
            .rd_data_vld(rd_data_vld),
            .byte_enb(byte_enb));
    //end widget
    
    assign raddress_out = raddress;
    assign address_out = address;
    assign wr_data_out = wr_data;
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    generate
        genvar reg_name_i;
        for( reg_name_i = 0; reg_name_i < reg_name_count; reg_name_i = reg_name_i + 1)
        begin : reg_name_gen
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  REG_NAME
            // ADDRESS       :  block_offset+'h320 + reg_name_i * 'h4                WIDTH : 32
            // HW ACCESS     :  READ-WRITE
            // SW ACCESS     :  READ-WRITE
            //
            // FIELDS   :
            //     31:0 : fld1  ( SW : Read-Write HW : Read-Write )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :
            //
            
            
            assign reg_name_wr_valid[reg_name_i] = reg_name_decode[reg_name_i] && wr_stb;
            assign reg_name_rd_valid[reg_name_i] = reg_name_rdecode[reg_name_i] && rd_stb;
            assign reg_name_enb[reg_name_i]      = reg_name_wr_valid[reg_name_i];
            assign reg_name_offset[reg_name_i] = block_offset+'h320 + reg_name_i * 'h4;
            assign reg_name_decode[reg_name_i]  = (address[reg_name_address_width-1 : 0]    == reg_name_offset[reg_name_i][reg_name_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            assign reg_name_rdecode[reg_name_i] = (raddress[reg_name_address_width-1 : 0]   == reg_name_offset[reg_name_i][reg_name_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            
            //----------------------------------------------------------------------------
            // FIELD  : FLD1
            // HW ACCESS  :  READ-WRITE                          WIDTH  :  32
            // SW ACCESS  :  READ-WRITE                          OFFSET :  0
            //-----------------------------------------------------------------
            // DESCRIPTION   :
            //
            
            always @(posedge clk)
                
                begin
                if (!reset_l)
                    begin
                        
                        reg_name_fld1_q[reg_name_i]  <= E1;
                    end
                else
                    begin
                    if (reg_name_fld1_in_enb[reg_name_i])   // FLD1 : HW Write
                        begin
                            reg_name_fld1_q[reg_name_i] <= reg_name_fld1_in[(reg_name_i) *32+31 :  (reg_name_i) *32 ];
                        end
                    else
                        begin
                            
                        if (reg_name_wr_valid[reg_name_i])   // FLD1 : SW Write
                            begin
                                reg_name_fld1_q[reg_name_i] <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (reg_name_fld1_q[reg_name_i] & (~reg_enb[31 : 0]));
                            end
                            
                        end  // sw_write_close
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            // ===================================================
            // HW OUTPUT READ DATA FOR EACH FIELD
            assign reg_name_fld1_r[(reg_name_i) *32+31 :  (reg_name_i) *32 ]  =  reg_name_fld1_q[reg_name_i] ;    // Field : FLD1
            
            
            assign reg_name_rd_data[reg_name_i] = reg_name_rd_valid[reg_name_i] ? {reg_name_fld1_q[reg_name_i]} : 32'b00000000000000000000000000000000;
            assign reg_name_rd_data_wor = reg_name_rd_data[reg_name_i];
            
            
        end //reg_name_gen
    endgenerate
    
    
    assign memory_name_offset       = (block_offset/'h400) +'h0;
    assign memory_name_decode       = ((address[addr_width - 1 : 0] >= block_offset +  'h0) && (address[addr_width - 1 : 0] <= block_offset +  'h31F)) ? 1'b1 : 1'b0;
    assign memory_name_rdecode       = ((raddress[addr_width - 1 : 0] >=block_offset +  'h0) && (raddress[addr_width - 1 : 0] <=block_offset +  'h31F)) ? 1'b1 : 1'b0;
    assign memory_name_wr_valid     = memory_name_decode &&  wr_stb;
    assign memory_name_rd_valid     = memory_name_rdecode && rd_stb && rd_wait_state;
    assign memory_name_wr_valid_out = memory_name_wr_valid;
    assign memory_name_rd_valid_out = memory_name_rd_valid;
    assign memory_name_decode_wor   = memory_name_rdecode;
    
    assign memory_name_wr_req_wor   = memory_name_wr_req_in;
    assign memory_name_rd_ack_wor   = memory_name_rd_ack_in;
    
    assign memory_name_rd_data      = memory_name_rd_ack_in ? memory_name_rd_data_in : 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign memory_name_write_error  = memory_name_decode && wr_stb;
    assign memory_name_write_error_wor  = memory_name_write_error;
    
    
    
    
    
    assign rd_data = int_rd_data | ext_rd_data ;
    
    assign int_rd_data = (~external_access)? ( reg_name_rd_data_wor) : {bus_width{1'b0}};
    
    assign ext_rd_data = (external_rd_ack == 1'b1)? ( memory_name_rd_data ): {bus_width{1'b0}} ;
    
    
    
    
    assign wr_error = memory_name_write_error_wor;
    
    assign rd_error = 0;
    
    assign wr_decode_error = 0;
    
    assign rd_decode_error = 0;
    
    assign external_rd_valid = memory_name_rd_valid;
    // END external_rd_valid
    
    assign external_rd_ack = memory_name_rd_ack_wor;
    // END external_rd_ack
    
    assign external_wr_req = memory_name_wr_req_wor;
    // END external_wr_req
    
    assign external_access = (memory_name_decode_wor) & rd_stb;
    // END external_access
    
    always @(posedge clk)
        begin
        if ( !reset_l )
            begin
                rd_wait_state <= 1'b1;
            end
        else
            begin
                case(rd_wait_state)
                    1'b1:
                    begin
                    if (external_rd_valid == 1'b1 && external_rd_ack == 1'b0 )
                        begin
                            rd_wait_state <= 1'b0;
                        end
                    end
                    1'b0:
                    begin
                    if (external_rd_ack == 1'b1)
                        begin
                            rd_wait_state <= 1'b1;
                        end
                    end
                endcase
            end
    end // always END
    
    
    assign request     = external_wr_req;
    assign rd_data_vld = external_rd_ack |(~external_access & rd_stb & rd_wait_state);
    assign rd_wait     = external_rd_valid ? external_rd_ack : ( rd_data_vld | rd_wait_state);
    
    assign wr_slave_select = ((slvwaddr[addr_width - 1 : 0]  >= block_offset) && (slvwaddr[addr_width - 1 : 0]  <= block_offset + 'h34F)) ? 1'b1 : 1'b0;
    assign rd_slave_select = ((slvraddr[addr_width - 1 : 0]  >= block_offset) && (slvraddr[addr_width - 1 : 0]  <= block_offset + 'h34F)) ? 1'b1 : 1'b0;
    assign S2 =  ;
    
endmodule
