//*************Agnisys**************** fadfasdfsdfsd
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Saurabh
// generated from    : C:\Users\Anupam\Documents\GitHub\git_test\Allegro_test\test99\test113.idsng
// IDesignSpec rev   : idsbatch v 6.16.4.7

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 16
// C++ Types int              : hwint
// Bus Type                   : WISHBONE
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

module chip_name_ids(
    b1_idsrg1_enb,
    b1_idsrg1_f1_in,
    b1_idsrg1_f1_in_enb,
    b1_idsrg1_f1_r,
    b1_idsrg1_f2_in,
    b1_idsrg1_f2_in_enb,
    b1_idsrg1_f2_r,
    b1_idsrg1_f3_in,
    b1_idsrg1_f3_in_enb,
    b1_idsrg1_f3_r,
    
    b2_idsrg1_enb,
    b2_idsrg1_f1_in,
    b2_idsrg1_f1_in_enb,
    b2_idsrg1_f1_r,
    b2_idsrg1_f2_in,
    b2_idsrg1_f2_in_enb,
    b2_idsrg1_f2_r,
    b2_idsrg1_f3_in,
    b2_idsrg1_f3_in_enb,
    b2_idsrg1_f3_r,
    b2_idsref_sub_blk_rg1_enb,
    b2_idsref_sub_blk_rg1_f1_in,
    b2_idsref_sub_blk_rg1_f1_in_enb,
    b2_idsref_sub_blk_rg1_f1_r,
    b2_idsref_sub_blk_rg1_f2_in,
    b2_idsref_sub_blk_rg1_f2_in_enb,
    b2_idsref_sub_blk_rg1_f2_r,
    b2_idsref_sub_blk_rg1_f3_in,
    b2_idsref_sub_blk_rg1_f3_in_enb,
    b2_idsref_sub_blk_rg1_f3_r,
    
    
    //WISHBONE signals
    
    clk_i,    // Bus clock
    rst_i,    // Reset
    sel_i,    // Select    : It indicates where valid data is placed on the [DAT_I()]
    we_i,    // Direction : This signal indicates whether the current local bus cycle is a READ or WRITE cycle
    stb_i,    // Write strobes : This signal indicates indicates that the SLAVE is selected
    dat_i,    // Write data
    adr_i,    // Address bus
    ack_o,    // when asserted, indicates the termination of a normal bus cycle
    dat_o,    // Read data
    cyc_i,    // indicates that a valid bus cycle is in progress.
    rty_o,    // indicates that the interface is not ready to accept or send data.
    err_o    // indicates an abnormal cycle termination.
    
    );
    
    
    
    parameter chip_offset = 'h0;
    
    parameter b1_ids_offset = chip_offset + 'h0;
    
    parameter b2_ids_offset = chip_offset + 'h2;
    parameter addr_width  = 3;
    parameter bus_width   = 32;
    
    //WISHBONE signals
    input clk_i;
    input rst_i;
    input [bus_width/8-1 : 0] sel_i;
    input we_i;
    input stb_i;
    input [bus_width-1 : 0] dat_i;
    input [addr_width-1 : 0] adr_i;
    output ack_o;
    output [bus_width-1 : 0] dat_o;
    input cyc_i;
    output rty_o;
    output err_o;
    
    wire [bus_width-1:0] b1_ids_dat_o;
    wire b1_ids_rty_o;
    wire b1_ids_err_o;
    wire b1_ids_ack_o;
    
    wire [bus_width-1:0] b2_ids_dat_o;
    wire b2_ids_rty_o;
    wire b2_ids_err_o;
    wire b2_ids_ack_o;
    
    //b1_ids
    output   b1_idsrg1_enb;
    input  [7 : 0] b1_idsrg1_f1_in;
    input   b1_idsrg1_f1_in_enb;
    output [7 : 0] b1_idsrg1_f1_r;
    input  [2 : 0] b1_idsrg1_f2_in;
    input   b1_idsrg1_f2_in_enb;
    output [2 : 0] b1_idsrg1_f2_r;
    input  [2 : 0] b1_idsrg1_f3_in;
    input   b1_idsrg1_f3_in_enb;
    output [2 : 0] b1_idsrg1_f3_r;
    
    
    
    
    b1_ids #(.addr_width(addr_width),.block_offset( b1_ids_offset)) b1_idsinst(
    .rg1_enb(b1_idsrg1_enb),
    .rg1_f1_in(b1_idsrg1_f1_in),
    .rg1_f1_in_enb(b1_idsrg1_f1_in_enb),
    .rg1_f1_r(b1_idsrg1_f1_r),
    .rg1_f2_in(b1_idsrg1_f2_in),
    .rg1_f2_in_enb(b1_idsrg1_f2_in_enb),
    .rg1_f2_r(b1_idsrg1_f2_r),
    .rg1_f3_in(b1_idsrg1_f3_in),
    .rg1_f3_in_enb(b1_idsrg1_f3_in_enb),
    .rg1_f3_r(b1_idsrg1_f3_r),
    
    .clk_i(clk_i),
    .rst_i(rst_i),
    .sel_i(sel_i),
    .we_i(we_i),
    .stb_i(stb_i),
    .dat_i(dat_i),
    .adr_i(adr_i),
    .ack_o(b1_ids_ack_o),
    .dat_o(b1_ids_dat_o),
    .cyc_i(cyc_i),
    .rty_o(b1_ids_rty_o),
    .err_o(b1_ids_err_o));
    
    //b2_ids
    output   b2_idsrg1_enb;
    input  [7 : 0] b2_idsrg1_f1_in;
    input   b2_idsrg1_f1_in_enb;
    output [7 : 0] b2_idsrg1_f1_r;
    input  [2 : 0] b2_idsrg1_f2_in;
    input   b2_idsrg1_f2_in_enb;
    output [2 : 0] b2_idsrg1_f2_r;
    input  [2 : 0] b2_idsrg1_f3_in;
    input   b2_idsrg1_f3_in_enb;
    output [2 : 0] b2_idsrg1_f3_r;
    
    
    output   b2_idsref_sub_blk_rg1_enb;
    input  [7 : 0] b2_idsref_sub_blk_rg1_f1_in;
    input   b2_idsref_sub_blk_rg1_f1_in_enb;
    output [7 : 0] b2_idsref_sub_blk_rg1_f1_r;
    input  [2 : 0] b2_idsref_sub_blk_rg1_f2_in;
    input   b2_idsref_sub_blk_rg1_f2_in_enb;
    output [2 : 0] b2_idsref_sub_blk_rg1_f2_r;
    input  [2 : 0] b2_idsref_sub_blk_rg1_f3_in;
    input   b2_idsref_sub_blk_rg1_f3_in_enb;
    output [2 : 0] b2_idsref_sub_blk_rg1_f3_r;
    
    
    
    
    b2_ids #(.addr_width(addr_width),.block_offset( b2_ids_offset)) b2_idsinst(
    .rg1_enb(b2_idsrg1_enb),
    .rg1_f1_in(b2_idsrg1_f1_in),
    .rg1_f1_in_enb(b2_idsrg1_f1_in_enb),
    .rg1_f1_r(b2_idsrg1_f1_r),
    .rg1_f2_in(b2_idsrg1_f2_in),
    .rg1_f2_in_enb(b2_idsrg1_f2_in_enb),
    .rg1_f2_r(b2_idsrg1_f2_r),
    .rg1_f3_in(b2_idsrg1_f3_in),
    .rg1_f3_in_enb(b2_idsrg1_f3_in_enb),
    .rg1_f3_r(b2_idsrg1_f3_r),
    .ref_sub_blk_rg1_enb(b2_idsref_sub_blk_rg1_enb),
    .ref_sub_blk_rg1_f1_in(b2_idsref_sub_blk_rg1_f1_in),
    .ref_sub_blk_rg1_f1_in_enb(b2_idsref_sub_blk_rg1_f1_in_enb),
    .ref_sub_blk_rg1_f1_r(b2_idsref_sub_blk_rg1_f1_r),
    .ref_sub_blk_rg1_f2_in(b2_idsref_sub_blk_rg1_f2_in),
    .ref_sub_blk_rg1_f2_in_enb(b2_idsref_sub_blk_rg1_f2_in_enb),
    .ref_sub_blk_rg1_f2_r(b2_idsref_sub_blk_rg1_f2_r),
    .ref_sub_blk_rg1_f3_in(b2_idsref_sub_blk_rg1_f3_in),
    .ref_sub_blk_rg1_f3_in_enb(b2_idsref_sub_blk_rg1_f3_in_enb),
    .ref_sub_blk_rg1_f3_r(b2_idsref_sub_blk_rg1_f3_r),
    
    .clk_i(clk_i),
    .rst_i(rst_i),
    .sel_i(sel_i),
    .we_i(we_i),
    .stb_i(stb_i),
    .dat_i(dat_i),
    .adr_i(adr_i),
    .ack_o(b2_ids_ack_o),
    .dat_o(b2_ids_dat_o),
    .cyc_i(cyc_i),
    .rty_o(b2_ids_rty_o),
    .err_o(b2_ids_err_o));
    
    
    
    
    assign dat_o = b1_ids_dat_o | b2_ids_dat_o;
    assign rty_o = b1_ids_rty_o | b2_ids_rty_o;
    assign err_o = b1_ids_err_o | b2_ids_err_o;
    assign ack_o = b1_ids_ack_o | b2_ids_ack_o;
    
endmodule

//------------------------------------------------
//  BLOCK : B1 MODULE
//

module b1_ids(
    
    // REGISTER : RG1 PORT SIGNAL
    rg1_enb,
    rg1_f1_in,
    rg1_f1_in_enb,
    rg1_f1_r,
    
    rg1_f2_in,
    rg1_f2_in_enb,
    rg1_f2_r,
    
    rg1_f3_in,
    rg1_f3_in_enb,
    rg1_f3_r,
    
    
    
    //WISHBONE signals
    clk_i,   // Bus clock
    rst_i,   // Reset
    sel_i,   // Select    : It indicates where valid data is placed on the [DAT_I()]
    we_i,   // Direction : This signal indicates whether the current local bus cycle is a READ or WRITE cycle
    stb_i,   // Write strobes : This signal indicates indicates that the SLAVE is selected
    dat_i,   // Write data
    adr_i,   // Address bus
    ack_o,   // when asserted, indicates the termination of a normal bus cycle
    dat_o,   // Read data
    cyc_i,   // indicates that a valid bus cycle is in progress.
    rty_o,   // indicates that the interface is not ready to accept or send data.
    err_o   // indicates an abnormal cycle termination.
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 1;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    
    parameter b1_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : RG1 SIGNALS
    
    
    wire    rg1_decode;         // DECODE
    wire    rg1_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] rg1_rd_data;          // READ DATA
    wire    [64-1 : 0] rg1_offset;  // OFFSET
    output  rg1_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   rg1_f1_in_enb ;      // FIELD : F1
    input   rg1_f2_in_enb ;      // FIELD : F2
    input   rg1_f3_in_enb ;      // FIELD : F3
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [7 : 0] rg1_f1_q ;      // FIELD : F1
    reg  [2 : 0] rg1_f2_q ;      // FIELD : F2
    reg  [2 : 0] rg1_f3_q ;      // FIELD : F3
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [7 : 0] rg1_f1_r ;      // FIELD : F1
    output   [2 : 0] rg1_f2_r ;      // FIELD : F2
    output   [2 : 0] rg1_f3_r ;      // FIELD : F3
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [7 : 0] rg1_f1_in ;      // FIELD : F1
    input    [2 : 0] rg1_f2_in ;      // FIELD : F2
    input    [2 : 0] rg1_f3_in ;      // FIELD : F3
    
    //-----------------------------------------------------
    
    
    
    //WISHBONE signals
    input clk_i;
    input rst_i;
    input [bus_width/8-1 : 0] sel_i;
    input we_i;
    input stb_i;
    input [bus_width-1 : 0] dat_i;
    input [addr_width-1 : 0] adr_i;
    output ack_o;
    output [bus_width-1 : 0] dat_o;
    input cyc_i;
    output rty_o;
    output err_o;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire  error;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    wishbone_widget #(.addr_width(addr_width), .bus_width(bus_width)) WB(
            .clk_i(clk_i),
            .rst_i(rst_i),
            .adr_i(adr_i),
            .dat_i(dat_i),
            .dat_o(dat_o),
            .ack_o(ack_o),
            .cyc_i(cyc_i),
            .sel_i(sel_i),
            .stb_i(stb_i),
            .we_i(we_i),
            .err_o(err_o),
            .clk(clk),
            .reset_l(reset_l),
            .byte_enb(byte_enb),
            .request(request),
            .wr_stb(wr_stb),
            .rd_stb(rd_stb),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .rd_data_vld(rd_data_vld),
            .rd_wait(rd_wait),
            .rty_o(rty_o),
            .error(error));
    //end widget
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  RG1
    // ADDRESS       :  block_offset+'h0                WIDTH : 16
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:7 : f1  ( SW : Read-Write HW : Read-Write )
    //     8:10 : f2  ( SW : Read-Write HW : Read-Write )
    //    14:12 : f3  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign rg1_wr_valid = rg1_decode && wr_stb;
    assign rg1_enb      = rg1_wr_valid;
    assign rg1_offset = block_offset+'h0;
    assign rg1_decode  = (address[b1_address_width-1 : 0]    == rg1_offset[b1_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  8
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  NICE WORK
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                rg1_f1_q  <= 8'd0;
            end
        else
            begin
            if (rg1_f1_in_enb)   // F1 : HW Write
                begin
                    rg1_f1_q <= rg1_f1_in;
                end
            else
                begin
                    
                if (rg1_wr_valid)   // F1 : SW Write
                    begin
                        rg1_f1_q <=  ( wr_data[7 : 0] & reg_enb[7 : 0] ) | (rg1_f1_q & (~reg_enb[7 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                rg1_f2_q  <= 3'd0;
            end
        else
            begin
            if (rg1_f2_in_enb)   // F2 : HW Write
                begin
                    rg1_f2_q <= rg1_f2_in;
                end
            else
                begin
                    
                if (rg1_wr_valid)   // F2 : SW Write
                    begin
                        rg1_f2_q <=  ( wr_data[10 : 8] & reg_enb[10 : 8] ) | (rg1_f2_q & (~reg_enb[10 : 8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F3
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                rg1_f3_q  <= 3'd0;
            end
        else
            begin
            if (rg1_f3_in_enb)   // F3 : HW Write
                begin
                    rg1_f3_q <= rg1_f3_in;
                end
            else
                begin
                    
                if (rg1_wr_valid)   // F3 : SW Write
                    begin
                        rg1_f3_q <=  ( wr_data[14 : 12] & reg_enb[14 : 12] ) | (rg1_f3_q & (~reg_enb[14 : 12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign rg1_f1_r  =  rg1_f1_q ;    // Field : F1
    assign rg1_f2_r  =  rg1_f2_q ;    // Field : F2
    assign rg1_f3_r  =  rg1_f3_q ;    // Field : F3
    
    
    assign rg1_rd_data = rg1_decode ? {1'b0 ,rg1_f3_q , 1'b0 ,rg1_f2_q , rg1_f1_q} : 16'b0000000000000000;
    
    
    
    
    assign rd_data = rg1_rd_data ;
    
    
    assign error = 0;
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    
endmodule

//------------------------------------------------
//  BLOCK : B2 MODULE
//

module b2_ids(
    
    // REGISTER : RG1 PORT SIGNAL
    rg1_enb,
    rg1_f1_in,
    rg1_f1_in_enb,
    rg1_f1_r,
    
    rg1_f2_in,
    rg1_f2_in_enb,
    rg1_f2_r,
    
    rg1_f3_in,
    rg1_f3_in_enb,
    rg1_f3_r,
    
    
    // REGISTER : RG1 PORT SIGNAL
    ref_sub_blk_rg1_enb,
    ref_sub_blk_rg1_f1_in,
    ref_sub_blk_rg1_f1_in_enb,
    ref_sub_blk_rg1_f1_r,
    
    ref_sub_blk_rg1_f2_in,
    ref_sub_blk_rg1_f2_in_enb,
    ref_sub_blk_rg1_f2_r,
    
    ref_sub_blk_rg1_f3_in,
    ref_sub_blk_rg1_f3_in_enb,
    ref_sub_blk_rg1_f3_r,
    
    
    
    //WISHBONE signals
    clk_i,   // Bus clock
    rst_i,   // Reset
    sel_i,   // Select    : It indicates where valid data is placed on the [DAT_I()]
    we_i,   // Direction : This signal indicates whether the current local bus cycle is a READ or WRITE cycle
    stb_i,   // Write strobes : This signal indicates indicates that the SLAVE is selected
    dat_i,   // Write data
    adr_i,   // Address bus
    ack_o,   // when asserted, indicates the termination of a normal bus cycle
    dat_o,   // Read data
    cyc_i,   // indicates that a valid bus cycle is in progress.
    rty_o,   // indicates that the interface is not ready to accept or send data.
    err_o   // indicates an abnormal cycle termination.
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 2;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : REF_SUB_BLK
    parameter ref_sub_blk_count         = 1;
    parameter ref_sub_blk_address_width = addr_width;
    
    
    parameter b2_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : RG1 SIGNALS
    
    
    wire    rg1_decode;         // DECODE
    wire    rg1_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] rg1_rd_data;          // READ DATA
    wire    [64-1 : 0] rg1_offset;  // OFFSET
    output  rg1_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   rg1_f1_in_enb ;      // FIELD : F1
    input   rg1_f2_in_enb ;      // FIELD : F2
    input   rg1_f3_in_enb ;      // FIELD : F3
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [7 : 0] rg1_f1_q ;      // FIELD : F1
    reg  [2 : 0] rg1_f2_q ;      // FIELD : F2
    reg  [2 : 0] rg1_f3_q ;      // FIELD : F3
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [7 : 0] rg1_f1_r ;      // FIELD : F1
    output   [2 : 0] rg1_f2_r ;      // FIELD : F2
    output   [2 : 0] rg1_f3_r ;      // FIELD : F3
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [7 : 0] rg1_f1_in ;      // FIELD : F1
    input    [2 : 0] rg1_f2_in ;      // FIELD : F2
    input    [2 : 0] rg1_f3_in ;      // FIELD : F3
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : RG1 SIGNALS
    
    
    wire    ref_sub_blk_rg1_decode;         // DECODE
    wire    ref_sub_blk_rg1_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] ref_sub_blk_rg1_rd_data;          // READ DATA
    wire    [64-1 : 0] ref_sub_blk_rg1_offset;  // OFFSET
    output  ref_sub_blk_rg1_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   ref_sub_blk_rg1_f1_in_enb ;      // FIELD : F1
    input   ref_sub_blk_rg1_f2_in_enb ;      // FIELD : F2
    input   ref_sub_blk_rg1_f3_in_enb ;      // FIELD : F3
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [7 : 0] ref_sub_blk_rg1_f1_q ;      // FIELD : F1
    reg  [2 : 0] ref_sub_blk_rg1_f2_q ;      // FIELD : F2
    reg  [2 : 0] ref_sub_blk_rg1_f3_q ;      // FIELD : F3
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [7 : 0] ref_sub_blk_rg1_f1_r ;      // FIELD : F1
    output   [2 : 0] ref_sub_blk_rg1_f2_r ;      // FIELD : F2
    output   [2 : 0] ref_sub_blk_rg1_f3_r ;      // FIELD : F3
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [7 : 0] ref_sub_blk_rg1_f1_in ;      // FIELD : F1
    input    [2 : 0] ref_sub_blk_rg1_f2_in ;      // FIELD : F2
    input    [2 : 0] ref_sub_blk_rg1_f3_in ;      // FIELD : F3
    
    //-----------------------------------------------------
    
    
    
    //WISHBONE signals
    input clk_i;
    input rst_i;
    input [bus_width/8-1 : 0] sel_i;
    input we_i;
    input stb_i;
    input [bus_width-1 : 0] dat_i;
    input [addr_width-1 : 0] adr_i;
    output ack_o;
    output [bus_width-1 : 0] dat_o;
    input cyc_i;
    output rty_o;
    output err_o;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire  error;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    wishbone_widget #(.addr_width(addr_width), .bus_width(bus_width)) WB(
            .clk_i(clk_i),
            .rst_i(rst_i),
            .adr_i(adr_i),
            .dat_i(dat_i),
            .dat_o(dat_o),
            .ack_o(ack_o),
            .cyc_i(cyc_i),
            .sel_i(sel_i),
            .stb_i(stb_i),
            .we_i(we_i),
            .err_o(err_o),
            .clk(clk),
            .reset_l(reset_l),
            .byte_enb(byte_enb),
            .request(request),
            .wr_stb(wr_stb),
            .rd_stb(rd_stb),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .address(address),
            .rd_data_vld(rd_data_vld),
            .rd_wait(rd_wait),
            .rty_o(rty_o),
            .error(error));
    //end widget
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  RG1
    // ADDRESS       :  block_offset+'h0                WIDTH : 16
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:7 : f1  ( SW : Read-Write HW : Read-Write )
    //     8:10 : f2  ( SW : Read-Write HW : Read-Write )
    //    14:12 : f3  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign rg1_wr_valid = rg1_decode && wr_stb;
    assign rg1_enb      = rg1_wr_valid;
    assign rg1_offset = block_offset+'h0;
    assign rg1_decode  = (address[b2_address_width-1 : 0]    == rg1_offset[b2_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  8
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  NICE WORK
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                rg1_f1_q  <= 8'd0;
            end
        else
            begin
            if (rg1_f1_in_enb)   // F1 : HW Write
                begin
                    rg1_f1_q <= rg1_f1_in;
                end
            else
                begin
                    
                if (rg1_wr_valid)   // F1 : SW Write
                    begin
                        rg1_f1_q <=  ( wr_data[7 : 0] & reg_enb[7 : 0] ) | (rg1_f1_q & (~reg_enb[7 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                rg1_f2_q  <= 3'd0;
            end
        else
            begin
            if (rg1_f2_in_enb)   // F2 : HW Write
                begin
                    rg1_f2_q <= rg1_f2_in;
                end
            else
                begin
                    
                if (rg1_wr_valid)   // F2 : SW Write
                    begin
                        rg1_f2_q <=  ( wr_data[10 : 8] & reg_enb[10 : 8] ) | (rg1_f2_q & (~reg_enb[10 : 8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F3
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                rg1_f3_q  <= 3'd0;
            end
        else
            begin
            if (rg1_f3_in_enb)   // F3 : HW Write
                begin
                    rg1_f3_q <= rg1_f3_in;
                end
            else
                begin
                    
                if (rg1_wr_valid)   // F3 : SW Write
                    begin
                        rg1_f3_q <=  ( wr_data[14 : 12] & reg_enb[14 : 12] ) | (rg1_f3_q & (~reg_enb[14 : 12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign rg1_f1_r  =  rg1_f1_q ;    // Field : F1
    assign rg1_f2_r  =  rg1_f2_q ;    // Field : F2
    assign rg1_f3_r  =  rg1_f3_q ;    // Field : F3
    
    
    assign rg1_rd_data = rg1_decode ? {1'b0 ,rg1_f3_q , 1'b0 ,rg1_f2_q , rg1_f1_q} : 16'b0000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  RG1
    // ADDRESS       :  block_offset+'h2 + 'h0                WIDTH : 16
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:7 : f1  ( SW : Read-Write HW : Read-Write )
    //     8:10 : f2  ( SW : Read-Write HW : Read-Write )
    //    14:12 : f3  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign ref_sub_blk_rg1_wr_valid = ref_sub_blk_rg1_decode && wr_stb;
    assign ref_sub_blk_rg1_enb      = ref_sub_blk_rg1_wr_valid;
    assign ref_sub_blk_rg1_offset = block_offset+'h2 + 'h0;
    assign ref_sub_blk_rg1_decode  = (address[ref_sub_blk_address_width-1 : 0]    == ref_sub_blk_rg1_offset[ref_sub_blk_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F1
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  8
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  NICE WORK
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                ref_sub_blk_rg1_f1_q <= 8'd0;
            end
        else
            begin
            if (ref_sub_blk_rg1_f1_in_enb)   // F1 : HW Write
                begin
                    ref_sub_blk_rg1_f1_q <= ref_sub_blk_rg1_f1_in;
                end
            else
                begin
                    
                if (ref_sub_blk_rg1_wr_valid)   // F1 : SW Write
                    begin
                        ref_sub_blk_rg1_f1_q <=  ( wr_data[7 : 0] & reg_enb[7 : 0] ) | (ref_sub_blk_rg1_f1_q & (~reg_enb[7 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F2
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                ref_sub_blk_rg1_f2_q <= 3'd0;
            end
        else
            begin
            if (ref_sub_blk_rg1_f2_in_enb)   // F2 : HW Write
                begin
                    ref_sub_blk_rg1_f2_q <= ref_sub_blk_rg1_f2_in;
                end
            else
                begin
                    
                if (ref_sub_blk_rg1_wr_valid)   // F2 : SW Write
                    begin
                        ref_sub_blk_rg1_f2_q <=  ( wr_data[10 : 8] & reg_enb[10 : 8] ) | (ref_sub_blk_rg1_f2_q & (~reg_enb[10 : 8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : F3
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                ref_sub_blk_rg1_f3_q <= 3'd0;
            end
        else
            begin
            if (ref_sub_blk_rg1_f3_in_enb)   // F3 : HW Write
                begin
                    ref_sub_blk_rg1_f3_q <= ref_sub_blk_rg1_f3_in;
                end
            else
                begin
                    
                if (ref_sub_blk_rg1_wr_valid)   // F3 : SW Write
                    begin
                        ref_sub_blk_rg1_f3_q <=  ( wr_data[14 : 12] & reg_enb[14 : 12] ) | (ref_sub_blk_rg1_f3_q & (~reg_enb[14 : 12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign ref_sub_blk_rg1_f1_r =  ref_sub_blk_rg1_f1_q;    // Field : F1
    assign ref_sub_blk_rg1_f2_r =  ref_sub_blk_rg1_f2_q;    // Field : F2
    assign ref_sub_blk_rg1_f3_r =  ref_sub_blk_rg1_f3_q;    // Field : F3
    
    
    assign ref_sub_blk_rg1_rd_data = ref_sub_blk_rg1_decode ? {1'b0 ,ref_sub_blk_rg1_f3_q , 1'b0 ,ref_sub_blk_rg1_f2_q , ref_sub_blk_rg1_f1_q} : 16'b0000000000000000;
    
    
    
    
    
    assign rd_data = rg1_rd_data |
    ref_sub_blk_rg1_rd_data ;
    
    
    assign error = 0;
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    
endmodule
