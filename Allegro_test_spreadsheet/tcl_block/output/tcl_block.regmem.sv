//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Agnisys
// generated from    : C:\Users\Agnisys\Desktop\workspace\Allegro_test\tcl_block\tcl_block.idsng
// IDesignSpec rev   : idsbatch v4.16.26.2

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : PROPRIETARY
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------
/*----------------------------------------------------------------------
Class       : tclblock_regname
-----------------------------------------------------------------------*/

`ifndef CLASS_tclblock_regname
`define CLASS_tclblock_regname
class tclblock_regname extends uvm_reg;
    `uvm_object_utils(tclblock_regname)

    rand uvm_reg_field f1;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[0])
        {
            illegal_bins b_x = {1,2};
        }
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[1])
        {
            illegal_bins b_x = {1,2};
        }
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[2])
        {
            illegal_bins b_x = {1,2};
        }
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[3])
        {
            illegal_bins b_x = {1,2};
        }

    endgroup

    covergroup wr_cg_vals;

        f1 : coverpoint f1.value[31:0];

    endgroup

    covergroup rd_cg_vals;

        f1 : coverpoint f1.value[31:0];

    endgroup

    // Function : new
    function new(string name = "tclblock_regname");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.f1 = uvm_reg_field::type_id::create("f1");

        this.f1.configure(this, 32,  0, "RW", 0, 'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class      : tclblock_block
-----------------------------------------------------------------------*/
`ifndef CLASS_tclblock_block
`define CLASS_tclblock_block
class tclblock_block extends uvm_reg_block;
    `uvm_object_utils(tclblock_block)

    rand tclblock_regname regname;

    local uvm_reg_addr_t m_offset;
    covergroup cg_addr;

        regname : coverpoint m_offset
        {
            bins hit =  { 'h0};
        }

    endgroup

    // Function : new
    function new(string name = "tclblock_block");
        super.new(name, build_coverage(UVM_CVR_ADDR_MAP));

        if (has_coverage(UVM_CVR_ADDR_MAP)) begin
            cg_addr = new();
        end
    endfunction

    // Function : build
    virtual function void build();
        //REG_NAME
        regname   =   tclblock_regname::type_id::create("regname");
        regname.configure(this, null, "regname");
        regname.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
        default_map.add_reg( regname, 'h0, "RW");

        lock_model();
    endfunction

    protected virtual function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map map);
        if (get_coverage(UVM_CVR_ADDR_MAP))  begin

            m_offset  = offset;
            cg_addr.sample();
            if (this.get_parent() != null) begin
                this.get_parent().sample(m_offset+'h0,is_read,map);
            end
        end

    endfunction
endclass : tclblock_block
`endif
